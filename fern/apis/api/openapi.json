{
  "openapi": "3.0.0",
  "paths": {
    "/call": {
      "post": {
        "operationId": "CallController_create",
        "summary": "HEYOOOOO MAKE Aaaaa blah CALL hey oooooo oooo yah yah yah yuftyd",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateCallDTO"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/Call"
                    },
                    {
                      "$ref": "#/components/schemas/CallBatchResponse"
                    }
                  ]
                }
              }
            }
          }
        },
        "tags": [
          "Calls"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "get": {
        "operationId": "CallController_findAll",
        "summary": "List Calls",
        "parameters": [
          {
            "name": "id",
            "required": false,
            "in": "query",
            "description": "This is the unique identifier for the call.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "assistantId",
            "required": false,
            "in": "query",
            "description": "This will return calls with the specified assistantId.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "phoneNumberId",
            "required": false,
            "in": "query",
            "description": "This is the phone number that will be used for the call. To use a transient number, use `phoneNumber` instead.\n\nOnly relevant for `outboundPhoneCall` and `inboundPhoneCall` type.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "This is the maximum number of items to return. Defaults to 100.",
            "schema": {
              "minimum": 0,
              "maximum": 1000,
              "type": "number"
            }
          },
          {
            "name": "createdAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Call"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Calls"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/call/{id}": {
      "get": {
        "operationId": "CallController_findOne",
        "summary": "Get Call",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Call"
                }
              }
            }
          }
        },
        "tags": [
          "Calls"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "patch": {
        "operationId": "CallController_update",
        "summary": "Update Call",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateCallDTO"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Call"
                }
              }
            }
          }
        },
        "tags": [
          "Calls"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "CallController_deleteCallData",
        "summary": "Delete Call Data",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Call"
                }
              }
            }
          }
        },
        "tags": [
          "Calls"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/chat": {
      "get": {
        "operationId": "ChatController_listChats",
        "summary": "List Chats",
        "parameters": [
          {
            "name": "assistantId",
            "required": false,
            "in": "query",
            "description": "This is the unique identifier for the assistant that will be used for the chat.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workflowId",
            "required": false,
            "in": "query",
            "description": "This is the unique identifier for the workflow that will be used for the chat.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sessionId",
            "required": false,
            "in": "query",
            "description": "This is the unique identifier for the session that will be used for the chat.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "required": false,
            "in": "query",
            "description": "This is the page number to return. Defaults to 1.",
            "schema": {
              "minimum": 1,
              "type": "number"
            }
          },
          {
            "name": "sortOrder",
            "required": false,
            "in": "query",
            "description": "This is the sort order for pagination. Defaults to 'DESC'.",
            "schema": {
              "enum": [
                "ASC",
                "DESC"
              ],
              "type": "string"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "This is the maximum number of items to return. Defaults to 100.",
            "schema": {
              "minimum": 0,
              "maximum": 1000,
              "type": "number"
            }
          },
          {
            "name": "createdAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatPaginatedResponse"
                }
              }
            }
          }
        },
        "tags": [
          "Chats"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "post": {
        "operationId": "ChatController_createChat",
        "summary": "Create Chat",
        "description": "Creates a new chat. Requires at least one of: assistantId/assistant, sessionId, or previousChatId. Note: sessionId and previousChatId are mutually exclusive.",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateChatDTO"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Chat response - either non-streaming chat or streaming",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/Chat"
                    },
                    {
                      "$ref": "#/components/schemas/CreateChatStreamResponse"
                    }
                  ]
                }
              }
            }
          },
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        },
        "tags": [
          "Chats"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/chat/{id}": {
      "get": {
        "operationId": "ChatController_getChat",
        "summary": "Get Chat",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Chat"
                }
              }
            }
          }
        },
        "tags": [
          "Chats"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "ChatController_deleteChat",
        "summary": "Delete Chat",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Chat"
                }
              }
            }
          }
        },
        "tags": [
          "Chats"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/chat/responses": {
      "post": {
        "operationId": "ChatController_createOpenAIChat",
        "summary": "Create Chat (OpenAI Compatible)",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OpenAIResponsesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OpenAI Responses API format - either non-streaming or streaming",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/ResponseObject"
                    },
                    {
                      "$ref": "#/components/schemas/ResponseTextDeltaEvent"
                    },
                    {
                      "$ref": "#/components/schemas/ResponseTextDoneEvent"
                    },
                    {
                      "$ref": "#/components/schemas/ResponseCompletedEvent"
                    },
                    {
                      "$ref": "#/components/schemas/ResponseErrorEvent"
                    }
                  ]
                }
              }
            }
          },
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        },
        "tags": [
          "Chats"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/session": {
      "post": {
        "operationId": "SessionController_create",
        "summary": "Create Session",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateSessionDTO"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Session"
                }
              }
            }
          }
        },
        "tags": [
          "Sessions"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "get": {
        "operationId": "SessionController_findAllPaginated",
        "summary": "List Sessions",
        "parameters": [
          {
            "name": "name",
            "required": false,
            "in": "query",
            "description": "This is the name of the session to filter by.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "assistantId",
            "required": false,
            "in": "query",
            "description": "This is the ID of the assistant to filter sessions by.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workflowId",
            "required": false,
            "in": "query",
            "description": "This is the ID of the workflow to filter sessions by.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "required": false,
            "in": "query",
            "description": "This is the page number to return. Defaults to 1.",
            "schema": {
              "minimum": 1,
              "type": "number"
            }
          },
          {
            "name": "sortOrder",
            "required": false,
            "in": "query",
            "description": "This is the sort order for pagination. Defaults to 'DESC'.",
            "schema": {
              "enum": [
                "ASC",
                "DESC"
              ],
              "type": "string"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "This is the maximum number of items to return. Defaults to 100.",
            "schema": {
              "minimum": 0,
              "maximum": 1000,
              "type": "number"
            }
          },
          {
            "name": "createdAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SessionPaginatedResponse"
                }
              }
            }
          }
        },
        "tags": [
          "Sessions"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/session/{id}": {
      "get": {
        "operationId": "SessionController_findOne",
        "summary": "Get Session",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Session"
                }
              }
            }
          }
        },
        "tags": [
          "Sessions"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "patch": {
        "operationId": "SessionController_update",
        "summary": "Update Session",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateSessionDTO"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Session"
                }
              }
            }
          }
        },
        "tags": [
          "Sessions"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "SessionController_remove",
        "summary": "Delete Session",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Session"
                }
              }
            }
          }
        },
        "tags": [
          "Sessions"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/assistant": {
      "post": {
        "operationId": "AssistantController_create",
        "summary": "Create Assistant",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Assistant"
                }
              }
            }
          }
        },
        "tags": [
          "Assistants"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "get": {
        "operationId": "AssistantController_findAll",
        "summary": "List Assistants",
        "parameters": [
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "This is the maximum number of items to return. Defaults to 100.",
            "schema": {
              "minimum": 0,
              "maximum": 1000,
              "type": "number"
            }
          },
          {
            "name": "createdAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Assistant"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Assistants"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/assistant/{id}": {
      "get": {
        "operationId": "AssistantController_findOne",
        "summary": "Get Assistant",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Assistant"
                }
              }
            }
          }
        },
        "tags": [
          "Assistants"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "patch": {
        "operationId": "AssistantController_update",
        "summary": "Update Assistant",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateAssistantDTO"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Assistant"
                }
              }
            }
          }
        },
        "tags": [
          "Assistants"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "AssistantController_remove",
        "summary": "Delete Assistant",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Assistant"
                }
              }
            }
          }
        },
        "tags": [
          "Assistants"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/phone-number": {
      "post": {
        "operationId": "PhoneNumberController_create",
        "summary": "Create Phone Number",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                    "title": "ByoPhoneNumber"
                  },
                  {
                    "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                    "title": "TwilioPhoneNumber"
                  },
                  {
                    "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                    "title": "VonagePhoneNumber"
                  },
                  {
                    "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                    "title": "VapiPhoneNumber"
                  },
                  {
                    "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                    "title": "TelnyxPhoneNumber"
                  }
                ],
                "discriminator": {
                  "propertyName": "provider",
                  "mapping": {
                    "byo-phone-number": "#/components/schemas/CreateByoPhoneNumberDTO",
                    "twilio": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                    "vonage": "#/components/schemas/CreateVonagePhoneNumberDTO",
                    "vapi": "#/components/schemas/CreateVapiPhoneNumberDTO",
                    "telnyx": "#/components/schemas/CreateTelnyxPhoneNumberDTO"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "title": "PhoneNumber",
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/ByoPhoneNumber",
                      "title": "ByoPhoneNumber"
                    },
                    {
                      "$ref": "#/components/schemas/TwilioPhoneNumber",
                      "title": "TwilioPhoneNumber"
                    },
                    {
                      "$ref": "#/components/schemas/VonagePhoneNumber",
                      "title": "VonagePhoneNumber"
                    },
                    {
                      "$ref": "#/components/schemas/VapiPhoneNumber",
                      "title": "VapiPhoneNumber"
                    },
                    {
                      "$ref": "#/components/schemas/TelnyxPhoneNumber",
                      "title": "TelnyxPhoneNumber"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "provider",
                    "mapping": {
                      "byo-phone-number": "#/components/schemas/ByoPhoneNumber",
                      "twilio": "#/components/schemas/TwilioPhoneNumber",
                      "vonage": "#/components/schemas/VonagePhoneNumber",
                      "vapi": "#/components/schemas/VapiPhoneNumber",
                      "telnyx": "#/components/schemas/TelnyxPhoneNumber"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Phone Numbers"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "get": {
        "operationId": "PhoneNumberController_findAll",
        "summary": "List Phone Numbers",
        "parameters": [
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "This is the maximum number of items to return. Defaults to 100.",
            "schema": {
              "minimum": 0,
              "maximum": 1000,
              "type": "number"
            }
          },
          {
            "name": "createdAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "title": "PhoneNumber",
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/ByoPhoneNumber",
                        "title": "ByoPhoneNumber"
                      },
                      {
                        "$ref": "#/components/schemas/TwilioPhoneNumber",
                        "title": "TwilioPhoneNumber"
                      },
                      {
                        "$ref": "#/components/schemas/VonagePhoneNumber",
                        "title": "VonagePhoneNumber"
                      },
                      {
                        "$ref": "#/components/schemas/VapiPhoneNumber",
                        "title": "VapiPhoneNumber"
                      },
                      {
                        "$ref": "#/components/schemas/TelnyxPhoneNumber",
                        "title": "TelnyxPhoneNumber"
                      }
                    ],
                    "discriminator": {
                      "propertyName": "provider",
                      "mapping": {
                        "byo-phone-number": "#/components/schemas/ByoPhoneNumber",
                        "twilio": "#/components/schemas/TwilioPhoneNumber",
                        "vonage": "#/components/schemas/VonagePhoneNumber",
                        "vapi": "#/components/schemas/VapiPhoneNumber",
                        "telnyx": "#/components/schemas/TelnyxPhoneNumber"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Phone Numbers"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/phone-number/{id}": {
      "get": {
        "operationId": "PhoneNumberController_findOne",
        "summary": "Get Phone Number",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "title": "PhoneNumber",
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/ByoPhoneNumber",
                      "title": "ByoPhoneNumber"
                    },
                    {
                      "$ref": "#/components/schemas/TwilioPhoneNumber",
                      "title": "TwilioPhoneNumber"
                    },
                    {
                      "$ref": "#/components/schemas/VonagePhoneNumber",
                      "title": "VonagePhoneNumber"
                    },
                    {
                      "$ref": "#/components/schemas/VapiPhoneNumber",
                      "title": "VapiPhoneNumber"
                    },
                    {
                      "$ref": "#/components/schemas/TelnyxPhoneNumber",
                      "title": "TelnyxPhoneNumber"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "provider",
                    "mapping": {
                      "byo-phone-number": "#/components/schemas/ByoPhoneNumber",
                      "twilio": "#/components/schemas/TwilioPhoneNumber",
                      "vonage": "#/components/schemas/VonagePhoneNumber",
                      "vapi": "#/components/schemas/VapiPhoneNumber",
                      "telnyx": "#/components/schemas/TelnyxPhoneNumber"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Phone Numbers"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "patch": {
        "operationId": "PhoneNumberController_update",
        "summary": "Update Phone Number",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/UpdateByoPhoneNumberDTO",
                    "title": "ByoPhoneNumber"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateTwilioPhoneNumberDTO",
                    "title": "TwilioPhoneNumber"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateVonagePhoneNumberDTO",
                    "title": "VonagePhoneNumber"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateVapiPhoneNumberDTO",
                    "title": "VapiPhoneNumber"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateTelnyxPhoneNumberDTO",
                    "title": "TelnyxPhoneNumber"
                  }
                ],
                "discriminator": {
                  "propertyName": "provider",
                  "mapping": {
                    "byo-phone-number": "#/components/schemas/UpdateByoPhoneNumberDTO",
                    "twilio": "#/components/schemas/UpdateTwilioPhoneNumberDTO",
                    "vonage": "#/components/schemas/UpdateVonagePhoneNumberDTO",
                    "vapi": "#/components/schemas/UpdateVapiPhoneNumberDTO",
                    "telnyx": "#/components/schemas/UpdateTelnyxPhoneNumberDTO"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "title": "PhoneNumber",
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/ByoPhoneNumber",
                      "title": "ByoPhoneNumber"
                    },
                    {
                      "$ref": "#/components/schemas/TwilioPhoneNumber",
                      "title": "TwilioPhoneNumber"
                    },
                    {
                      "$ref": "#/components/schemas/VonagePhoneNumber",
                      "title": "VonagePhoneNumber"
                    },
                    {
                      "$ref": "#/components/schemas/VapiPhoneNumber",
                      "title": "VapiPhoneNumber"
                    },
                    {
                      "$ref": "#/components/schemas/TelnyxPhoneNumber",
                      "title": "TelnyxPhoneNumber"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "provider",
                    "mapping": {
                      "byo-phone-number": "#/components/schemas/ByoPhoneNumber",
                      "twilio": "#/components/schemas/TwilioPhoneNumber",
                      "vonage": "#/components/schemas/VonagePhoneNumber",
                      "vapi": "#/components/schemas/VapiPhoneNumber",
                      "telnyx": "#/components/schemas/TelnyxPhoneNumber"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Phone Numbers"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "PhoneNumberController_remove",
        "summary": "Delete Phone Number",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "title": "PhoneNumber",
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/ByoPhoneNumber",
                      "title": "ByoPhoneNumber"
                    },
                    {
                      "$ref": "#/components/schemas/TwilioPhoneNumber",
                      "title": "TwilioPhoneNumber"
                    },
                    {
                      "$ref": "#/components/schemas/VonagePhoneNumber",
                      "title": "VonagePhoneNumber"
                    },
                    {
                      "$ref": "#/components/schemas/VapiPhoneNumber",
                      "title": "VapiPhoneNumber"
                    },
                    {
                      "$ref": "#/components/schemas/TelnyxPhoneNumber",
                      "title": "TelnyxPhoneNumber"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "provider",
                    "mapping": {
                      "byo-phone-number": "#/components/schemas/ByoPhoneNumber",
                      "twilio": "#/components/schemas/TwilioPhoneNumber",
                      "vonage": "#/components/schemas/VonagePhoneNumber",
                      "vapi": "#/components/schemas/VapiPhoneNumber",
                      "telnyx": "#/components/schemas/TelnyxPhoneNumber"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Phone Numbers"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/tool": {
      "post": {
        "operationId": "ToolController_create",
        "summary": "Create Tool",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/CreateDtmfToolDTO",
                    "title": "DtmfTool"
                  },
                  {
                    "$ref": "#/components/schemas/CreateEndCallToolDTO",
                    "title": "EndCallTool"
                  },
                  {
                    "$ref": "#/components/schemas/CreateFunctionToolDTO",
                    "title": "FunctionTool"
                  },
                  {
                    "$ref": "#/components/schemas/CreateGhlToolDTO",
                    "title": "GhlTool"
                  },
                  {
                    "$ref": "#/components/schemas/CreateMakeToolDTO",
                    "title": "MakeTool"
                  },
                  {
                    "$ref": "#/components/schemas/CreateTransferCallToolDTO",
                    "title": "TransferCallTool"
                  },
                  {
                    "$ref": "#/components/schemas/CreateOutputToolDTO",
                    "title": "OutputTool"
                  },
                  {
                    "$ref": "#/components/schemas/CreateBashToolDTO",
                    "title": "BashTool"
                  },
                  {
                    "$ref": "#/components/schemas/CreateComputerToolDTO",
                    "title": "ComputerTool"
                  },
                  {
                    "$ref": "#/components/schemas/CreateTextEditorToolDTO",
                    "title": "TextEditorTool"
                  },
                  {
                    "$ref": "#/components/schemas/CreateQueryToolDTO",
                    "title": "QueryTool"
                  },
                  {
                    "$ref": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                    "title": "GoogleCalendarCreateEventTool"
                  },
                  {
                    "$ref": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                    "title": "GoogleSheetsRowAppendTool"
                  },
                  {
                    "$ref": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                    "title": "GoogleCalendarCheckAvailabilityTool"
                  },
                  {
                    "$ref": "#/components/schemas/CreateSlackSendMessageToolDTO",
                    "title": "SlackSendMessageTool"
                  },
                  {
                    "$ref": "#/components/schemas/CreateSmsToolDTO",
                    "title": "SmsSendTool"
                  },
                  {
                    "$ref": "#/components/schemas/CreateMcpToolDTO",
                    "title": "McpTool"
                  },
                  {
                    "$ref": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                    "title": "GoHighLevelCalendarAvailabilityTool"
                  },
                  {
                    "$ref": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                    "title": "GoHighLevelCalendarEventCreateTool"
                  },
                  {
                    "$ref": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                    "title": "GoHighLevelContactCreateTool"
                  },
                  {
                    "$ref": "#/components/schemas/CreateGoHighLevelContactGetToolDTO",
                    "title": "GoHighLevelContactGetTool"
                  }
                ],
                "discriminator": {
                  "propertyName": "type",
                  "mapping": {
                    "dtmf": "#/components/schemas/CreateDtmfToolDTO",
                    "endCall": "#/components/schemas/CreateEndCallToolDTO",
                    "function": "#/components/schemas/CreateFunctionToolDTO",
                    "ghl": "#/components/schemas/CreateGhlToolDTO",
                    "make": "#/components/schemas/CreateMakeToolDTO",
                    "transferCall": "#/components/schemas/CreateTransferCallToolDTO",
                    "output": "#/components/schemas/CreateOutputToolDTO",
                    "bash": "#/components/schemas/CreateBashToolDTO",
                    "computer": "#/components/schemas/CreateComputerToolDTO",
                    "textEditor": "#/components/schemas/CreateTextEditorToolDTO",
                    "query": "#/components/schemas/CreateQueryToolDTO",
                    "google.calendar.event.create": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                    "google.sheets.row.append": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                    "google.calendar.availability.check": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                    "slack.message.send": "#/components/schemas/CreateSlackSendMessageToolDTO",
                    "sms": "#/components/schemas/CreateSmsToolDTO",
                    "mcp": "#/components/schemas/CreateMcpToolDTO",
                    "gohighlevel.calendar.availability.check": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                    "gohighlevel.calendar.event.create": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                    "gohighlevel.contact.create": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                    "gohighlevel.contact.get": "#/components/schemas/CreateGoHighLevelContactGetToolDTO"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/DtmfTool",
                      "title": "DtmfTool"
                    },
                    {
                      "$ref": "#/components/schemas/EndCallTool",
                      "title": "EndCallTool"
                    },
                    {
                      "$ref": "#/components/schemas/FunctionTool",
                      "title": "FunctionTool"
                    },
                    {
                      "$ref": "#/components/schemas/GhlTool",
                      "title": "GhlTool"
                    },
                    {
                      "$ref": "#/components/schemas/MakeTool",
                      "title": "MakeTool"
                    },
                    {
                      "$ref": "#/components/schemas/TransferCallTool",
                      "title": "TransferCallTool"
                    },
                    {
                      "$ref": "#/components/schemas/OutputTool",
                      "title": "OutputTool"
                    },
                    {
                      "$ref": "#/components/schemas/BashTool",
                      "title": "BashTool"
                    },
                    {
                      "$ref": "#/components/schemas/ComputerTool",
                      "title": "ComputerTool"
                    },
                    {
                      "$ref": "#/components/schemas/TextEditorTool",
                      "title": "TextEditorTool"
                    },
                    {
                      "$ref": "#/components/schemas/QueryTool",
                      "title": "QueryTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoogleCalendarCreateEventTool",
                      "title": "GoogleCalendarCreateEventTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoogleSheetsRowAppendTool",
                      "title": "GoogleSheetsRowAppendTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoogleCalendarCheckAvailabilityTool",
                      "title": "GoogleCalendarCheckAvailabilityTool"
                    },
                    {
                      "$ref": "#/components/schemas/SlackSendMessageTool",
                      "title": "SlackSendMessageTool"
                    },
                    {
                      "$ref": "#/components/schemas/SmsTool",
                      "title": "SmsSendTool"
                    },
                    {
                      "$ref": "#/components/schemas/McpTool",
                      "title": "McpTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoHighLevelCalendarAvailabilityTool",
                      "title": "GoHighLevelCalendarAvailabilityTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoHighLevelCalendarEventCreateTool",
                      "title": "GoHighLevelCalendarEventCreateTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoHighLevelContactCreateTool",
                      "title": "GoHighLevelContactCreateTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoHighLevelContactGetTool",
                      "title": "GoHighLevelContactGetTool"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "type",
                    "mapping": {
                      "dtmf": "#/components/schemas/DtmfTool",
                      "endCall": "#/components/schemas/EndCallTool",
                      "function": "#/components/schemas/FunctionTool",
                      "ghl": "#/components/schemas/GhlTool",
                      "make": "#/components/schemas/MakeTool",
                      "transferCall": "#/components/schemas/TransferCallTool",
                      "output": "#/components/schemas/OutputTool",
                      "bash": "#/components/schemas/BashTool",
                      "computer": "#/components/schemas/ComputerTool",
                      "textEditor": "#/components/schemas/TextEditorTool",
                      "query": "#/components/schemas/QueryTool",
                      "google.calendar.event.create": "#/components/schemas/GoogleCalendarCreateEventTool",
                      "google.sheets.row.append": "#/components/schemas/GoogleSheetsRowAppendTool",
                      "google.calendar.availability.check": "#/components/schemas/GoogleCalendarCheckAvailabilityTool",
                      "slack.message.send": "#/components/schemas/SlackSendMessageTool",
                      "sms": "#/components/schemas/SmsTool",
                      "mcp": "#/components/schemas/McpTool",
                      "gohighlevel.calendar.availability.check": "#/components/schemas/GoHighLevelCalendarAvailabilityTool",
                      "gohighlevel.calendar.event.create": "#/components/schemas/GoHighLevelCalendarEventCreateTool",
                      "gohighlevel.contact.create": "#/components/schemas/GoHighLevelContactCreateTool",
                      "gohighlevel.contact.get": "#/components/schemas/GoHighLevelContactGetTool"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Tools"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "get": {
        "operationId": "ToolController_findAll",
        "summary": "List Tools",
        "parameters": [
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "This is the maximum number of items to return. Defaults to 100.",
            "schema": {
              "minimum": 0,
              "maximum": 1000,
              "type": "number"
            }
          },
          {
            "name": "createdAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/DtmfTool",
                        "title": "DtmfTool"
                      },
                      {
                        "$ref": "#/components/schemas/EndCallTool",
                        "title": "EndCallTool"
                      },
                      {
                        "$ref": "#/components/schemas/FunctionTool",
                        "title": "FunctionTool"
                      },
                      {
                        "$ref": "#/components/schemas/GhlTool",
                        "title": "GhlTool"
                      },
                      {
                        "$ref": "#/components/schemas/MakeTool",
                        "title": "MakeTool"
                      },
                      {
                        "$ref": "#/components/schemas/TransferCallTool",
                        "title": "TransferCallTool"
                      },
                      {
                        "$ref": "#/components/schemas/OutputTool",
                        "title": "OutputTool"
                      },
                      {
                        "$ref": "#/components/schemas/BashTool",
                        "title": "BashTool"
                      },
                      {
                        "$ref": "#/components/schemas/ComputerTool",
                        "title": "ComputerTool"
                      },
                      {
                        "$ref": "#/components/schemas/TextEditorTool",
                        "title": "TextEditorTool"
                      },
                      {
                        "$ref": "#/components/schemas/QueryTool",
                        "title": "QueryTool"
                      },
                      {
                        "$ref": "#/components/schemas/GoogleCalendarCreateEventTool",
                        "title": "GoogleCalendarCreateEventTool"
                      },
                      {
                        "$ref": "#/components/schemas/GoogleSheetsRowAppendTool",
                        "title": "GoogleSheetsRowAppendTool"
                      },
                      {
                        "$ref": "#/components/schemas/GoogleCalendarCheckAvailabilityTool",
                        "title": "GoogleCalendarCheckAvailabilityTool"
                      },
                      {
                        "$ref": "#/components/schemas/SlackSendMessageTool",
                        "title": "SlackSendMessageTool"
                      },
                      {
                        "$ref": "#/components/schemas/SmsTool",
                        "title": "SmsSendTool"
                      },
                      {
                        "$ref": "#/components/schemas/McpTool",
                        "title": "McpTool"
                      },
                      {
                        "$ref": "#/components/schemas/GoHighLevelCalendarAvailabilityTool",
                        "title": "GoHighLevelCalendarAvailabilityTool"
                      },
                      {
                        "$ref": "#/components/schemas/GoHighLevelCalendarEventCreateTool",
                        "title": "GoHighLevelCalendarEventCreateTool"
                      },
                      {
                        "$ref": "#/components/schemas/GoHighLevelContactCreateTool",
                        "title": "GoHighLevelContactCreateTool"
                      },
                      {
                        "$ref": "#/components/schemas/GoHighLevelContactGetTool",
                        "title": "GoHighLevelContactGetTool"
                      }
                    ],
                    "discriminator": {
                      "propertyName": "type",
                      "mapping": {
                        "dtmf": "#/components/schemas/DtmfTool",
                        "endCall": "#/components/schemas/EndCallTool",
                        "function": "#/components/schemas/FunctionTool",
                        "ghl": "#/components/schemas/GhlTool",
                        "make": "#/components/schemas/MakeTool",
                        "transferCall": "#/components/schemas/TransferCallTool",
                        "output": "#/components/schemas/OutputTool",
                        "bash": "#/components/schemas/BashTool",
                        "computer": "#/components/schemas/ComputerTool",
                        "textEditor": "#/components/schemas/TextEditorTool",
                        "query": "#/components/schemas/QueryTool",
                        "google.calendar.event.create": "#/components/schemas/GoogleCalendarCreateEventTool",
                        "google.sheets.row.append": "#/components/schemas/GoogleSheetsRowAppendTool",
                        "google.calendar.availability.check": "#/components/schemas/GoogleCalendarCheckAvailabilityTool",
                        "slack.message.send": "#/components/schemas/SlackSendMessageTool",
                        "sms": "#/components/schemas/SmsTool",
                        "mcp": "#/components/schemas/McpTool",
                        "gohighlevel.calendar.availability.check": "#/components/schemas/GoHighLevelCalendarAvailabilityTool",
                        "gohighlevel.calendar.event.create": "#/components/schemas/GoHighLevelCalendarEventCreateTool",
                        "gohighlevel.contact.create": "#/components/schemas/GoHighLevelContactCreateTool",
                        "gohighlevel.contact.get": "#/components/schemas/GoHighLevelContactGetTool"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Tools"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/tool/{id}": {
      "get": {
        "operationId": "ToolController_findOne",
        "summary": "Get Tool",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/DtmfTool",
                      "title": "DtmfTool"
                    },
                    {
                      "$ref": "#/components/schemas/EndCallTool",
                      "title": "EndCallTool"
                    },
                    {
                      "$ref": "#/components/schemas/FunctionTool",
                      "title": "FunctionTool"
                    },
                    {
                      "$ref": "#/components/schemas/GhlTool",
                      "title": "GhlTool"
                    },
                    {
                      "$ref": "#/components/schemas/MakeTool",
                      "title": "MakeTool"
                    },
                    {
                      "$ref": "#/components/schemas/TransferCallTool",
                      "title": "TransferCallTool"
                    },
                    {
                      "$ref": "#/components/schemas/OutputTool",
                      "title": "OutputTool"
                    },
                    {
                      "$ref": "#/components/schemas/BashTool",
                      "title": "BashTool"
                    },
                    {
                      "$ref": "#/components/schemas/ComputerTool",
                      "title": "ComputerTool"
                    },
                    {
                      "$ref": "#/components/schemas/TextEditorTool",
                      "title": "TextEditorTool"
                    },
                    {
                      "$ref": "#/components/schemas/QueryTool",
                      "title": "QueryTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoogleCalendarCreateEventTool",
                      "title": "GoogleCalendarCreateEventTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoogleSheetsRowAppendTool",
                      "title": "GoogleSheetsRowAppendTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoogleCalendarCheckAvailabilityTool",
                      "title": "GoogleCalendarCheckAvailabilityTool"
                    },
                    {
                      "$ref": "#/components/schemas/SlackSendMessageTool",
                      "title": "SlackSendMessageTool"
                    },
                    {
                      "$ref": "#/components/schemas/SmsTool",
                      "title": "SmsSendTool"
                    },
                    {
                      "$ref": "#/components/schemas/McpTool",
                      "title": "McpTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoHighLevelCalendarAvailabilityTool",
                      "title": "GoHighLevelCalendarAvailabilityTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoHighLevelCalendarEventCreateTool",
                      "title": "GoHighLevelCalendarEventCreateTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoHighLevelContactCreateTool",
                      "title": "GoHighLevelContactCreateTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoHighLevelContactGetTool",
                      "title": "GoHighLevelContactGetTool"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "type",
                    "mapping": {
                      "dtmf": "#/components/schemas/DtmfTool",
                      "endCall": "#/components/schemas/EndCallTool",
                      "function": "#/components/schemas/FunctionTool",
                      "ghl": "#/components/schemas/GhlTool",
                      "make": "#/components/schemas/MakeTool",
                      "transferCall": "#/components/schemas/TransferCallTool",
                      "output": "#/components/schemas/OutputTool",
                      "bash": "#/components/schemas/BashTool",
                      "computer": "#/components/schemas/ComputerTool",
                      "textEditor": "#/components/schemas/TextEditorTool",
                      "query": "#/components/schemas/QueryTool",
                      "google.calendar.event.create": "#/components/schemas/GoogleCalendarCreateEventTool",
                      "google.sheets.row.append": "#/components/schemas/GoogleSheetsRowAppendTool",
                      "google.calendar.availability.check": "#/components/schemas/GoogleCalendarCheckAvailabilityTool",
                      "slack.message.send": "#/components/schemas/SlackSendMessageTool",
                      "sms": "#/components/schemas/SmsTool",
                      "mcp": "#/components/schemas/McpTool",
                      "gohighlevel.calendar.availability.check": "#/components/schemas/GoHighLevelCalendarAvailabilityTool",
                      "gohighlevel.calendar.event.create": "#/components/schemas/GoHighLevelCalendarEventCreateTool",
                      "gohighlevel.contact.create": "#/components/schemas/GoHighLevelContactCreateTool",
                      "gohighlevel.contact.get": "#/components/schemas/GoHighLevelContactGetTool"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Tools"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "patch": {
        "operationId": "ToolController_update",
        "summary": "Update Tool",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/UpdateDtmfToolDTO",
                    "title": "DtmfTool"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateEndCallToolDTO",
                    "title": "EndCallTool"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateFunctionToolDTO",
                    "title": "FunctionTool"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateGhlToolDTO",
                    "title": "GhlTool"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateMakeToolDTO",
                    "title": "MakeTool"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateTransferCallToolDTO",
                    "title": "TransferCallTool"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateOutputToolDTO",
                    "title": "OutputTool"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateBashToolDTO",
                    "title": "BashTool"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateComputerToolDTO",
                    "title": "ComputerTool"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateTextEditorToolDTO",
                    "title": "TextEditorTool"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateQueryToolDTO",
                    "title": "QueryTool"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateGoogleCalendarCreateEventToolDTO",
                    "title": "GoogleCalendarCreateEventTool"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateGoogleSheetsRowAppendToolDTO",
                    "title": "GoogleSheetsRowAppendTool"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateGoogleCalendarCheckAvailabilityToolDTO",
                    "title": "GoogleCalendarCheckAvailabilityTool"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateSlackSendMessageToolDTO",
                    "title": "SlackSendMessageTool"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateSmsToolDTO",
                    "title": "SmsSendTool"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateMcpToolDTO",
                    "title": "McpTool"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateGoHighLevelCalendarAvailabilityToolDTO",
                    "title": "GoHighLevelCalendarAvailabilityTool"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateGoHighLevelCalendarEventCreateToolDTO",
                    "title": "GoHighLevelCalendarEventCreateTool"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateGoHighLevelContactCreateToolDTO",
                    "title": "GoHighLevelContactCreateTool"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateGoHighLevelContactGetToolDTO",
                    "title": "GoHighLevelContactGetTool"
                  }
                ],
                "discriminator": {
                  "propertyName": "type",
                  "mapping": {
                    "dtmf": "#/components/schemas/UpdateDtmfToolDTO",
                    "endCall": "#/components/schemas/UpdateEndCallToolDTO",
                    "function": "#/components/schemas/UpdateFunctionToolDTO",
                    "ghl": "#/components/schemas/UpdateGhlToolDTO",
                    "make": "#/components/schemas/UpdateMakeToolDTO",
                    "transferCall": "#/components/schemas/UpdateTransferCallToolDTO",
                    "output": "#/components/schemas/UpdateOutputToolDTO",
                    "bash": "#/components/schemas/UpdateBashToolDTO",
                    "computer": "#/components/schemas/UpdateComputerToolDTO",
                    "textEditor": "#/components/schemas/UpdateTextEditorToolDTO",
                    "query": "#/components/schemas/UpdateQueryToolDTO",
                    "google.calendar.event.create": "#/components/schemas/UpdateGoogleCalendarCreateEventToolDTO",
                    "google.sheets.row.append": "#/components/schemas/UpdateGoogleSheetsRowAppendToolDTO",
                    "google.calendar.availability.check": "#/components/schemas/UpdateGoogleCalendarCheckAvailabilityToolDTO",
                    "slack.message.send": "#/components/schemas/UpdateSlackSendMessageToolDTO",
                    "sms": "#/components/schemas/UpdateSmsToolDTO",
                    "mcp": "#/components/schemas/UpdateMcpToolDTO",
                    "gohighlevel.calendar.availability.check": "#/components/schemas/UpdateGoHighLevelCalendarAvailabilityToolDTO",
                    "gohighlevel.calendar.event.create": "#/components/schemas/UpdateGoHighLevelCalendarEventCreateToolDTO",
                    "gohighlevel.contact.create": "#/components/schemas/UpdateGoHighLevelContactCreateToolDTO",
                    "gohighlevel.contact.get": "#/components/schemas/UpdateGoHighLevelContactGetToolDTO"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/DtmfTool",
                      "title": "DtmfTool"
                    },
                    {
                      "$ref": "#/components/schemas/EndCallTool",
                      "title": "EndCallTool"
                    },
                    {
                      "$ref": "#/components/schemas/FunctionTool",
                      "title": "FunctionTool"
                    },
                    {
                      "$ref": "#/components/schemas/GhlTool",
                      "title": "GhlTool"
                    },
                    {
                      "$ref": "#/components/schemas/MakeTool",
                      "title": "MakeTool"
                    },
                    {
                      "$ref": "#/components/schemas/TransferCallTool",
                      "title": "TransferCallTool"
                    },
                    {
                      "$ref": "#/components/schemas/OutputTool",
                      "title": "OutputTool"
                    },
                    {
                      "$ref": "#/components/schemas/BashTool",
                      "title": "BashTool"
                    },
                    {
                      "$ref": "#/components/schemas/ComputerTool",
                      "title": "ComputerTool"
                    },
                    {
                      "$ref": "#/components/schemas/TextEditorTool",
                      "title": "TextEditorTool"
                    },
                    {
                      "$ref": "#/components/schemas/QueryTool",
                      "title": "QueryTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoogleCalendarCreateEventTool",
                      "title": "GoogleCalendarCreateEventTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoogleSheetsRowAppendTool",
                      "title": "GoogleSheetsRowAppendTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoogleCalendarCheckAvailabilityTool",
                      "title": "GoogleCalendarCheckAvailabilityTool"
                    },
                    {
                      "$ref": "#/components/schemas/SlackSendMessageTool",
                      "title": "SlackSendMessageTool"
                    },
                    {
                      "$ref": "#/components/schemas/SmsTool",
                      "title": "SmsSendTool"
                    },
                    {
                      "$ref": "#/components/schemas/McpTool",
                      "title": "McpTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoHighLevelCalendarAvailabilityTool",
                      "title": "GoHighLevelCalendarAvailabilityTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoHighLevelCalendarEventCreateTool",
                      "title": "GoHighLevelCalendarEventCreateTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoHighLevelContactCreateTool",
                      "title": "GoHighLevelContactCreateTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoHighLevelContactGetTool",
                      "title": "GoHighLevelContactGetTool"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "type",
                    "mapping": {
                      "dtmf": "#/components/schemas/DtmfTool",
                      "endCall": "#/components/schemas/EndCallTool",
                      "function": "#/components/schemas/FunctionTool",
                      "ghl": "#/components/schemas/GhlTool",
                      "make": "#/components/schemas/MakeTool",
                      "transferCall": "#/components/schemas/TransferCallTool",
                      "output": "#/components/schemas/OutputTool",
                      "bash": "#/components/schemas/BashTool",
                      "computer": "#/components/schemas/ComputerTool",
                      "textEditor": "#/components/schemas/TextEditorTool",
                      "query": "#/components/schemas/QueryTool",
                      "google.calendar.event.create": "#/components/schemas/GoogleCalendarCreateEventTool",
                      "google.sheets.row.append": "#/components/schemas/GoogleSheetsRowAppendTool",
                      "google.calendar.availability.check": "#/components/schemas/GoogleCalendarCheckAvailabilityTool",
                      "slack.message.send": "#/components/schemas/SlackSendMessageTool",
                      "sms": "#/components/schemas/SmsTool",
                      "mcp": "#/components/schemas/McpTool",
                      "gohighlevel.calendar.availability.check": "#/components/schemas/GoHighLevelCalendarAvailabilityTool",
                      "gohighlevel.calendar.event.create": "#/components/schemas/GoHighLevelCalendarEventCreateTool",
                      "gohighlevel.contact.create": "#/components/schemas/GoHighLevelContactCreateTool",
                      "gohighlevel.contact.get": "#/components/schemas/GoHighLevelContactGetTool"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Tools"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "ToolController_remove",
        "summary": "Delete Tool",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/DtmfTool",
                      "title": "DtmfTool"
                    },
                    {
                      "$ref": "#/components/schemas/EndCallTool",
                      "title": "EndCallTool"
                    },
                    {
                      "$ref": "#/components/schemas/FunctionTool",
                      "title": "FunctionTool"
                    },
                    {
                      "$ref": "#/components/schemas/GhlTool",
                      "title": "GhlTool"
                    },
                    {
                      "$ref": "#/components/schemas/MakeTool",
                      "title": "MakeTool"
                    },
                    {
                      "$ref": "#/components/schemas/TransferCallTool",
                      "title": "TransferCallTool"
                    },
                    {
                      "$ref": "#/components/schemas/OutputTool",
                      "title": "OutputTool"
                    },
                    {
                      "$ref": "#/components/schemas/BashTool",
                      "title": "BashTool"
                    },
                    {
                      "$ref": "#/components/schemas/ComputerTool",
                      "title": "ComputerTool"
                    },
                    {
                      "$ref": "#/components/schemas/TextEditorTool",
                      "title": "TextEditorTool"
                    },
                    {
                      "$ref": "#/components/schemas/QueryTool",
                      "title": "QueryTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoogleCalendarCreateEventTool",
                      "title": "GoogleCalendarCreateEventTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoogleSheetsRowAppendTool",
                      "title": "GoogleSheetsRowAppendTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoogleCalendarCheckAvailabilityTool",
                      "title": "GoogleCalendarCheckAvailabilityTool"
                    },
                    {
                      "$ref": "#/components/schemas/SlackSendMessageTool",
                      "title": "SlackSendMessageTool"
                    },
                    {
                      "$ref": "#/components/schemas/SmsTool",
                      "title": "SmsSendTool"
                    },
                    {
                      "$ref": "#/components/schemas/McpTool",
                      "title": "McpTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoHighLevelCalendarAvailabilityTool",
                      "title": "GoHighLevelCalendarAvailabilityTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoHighLevelCalendarEventCreateTool",
                      "title": "GoHighLevelCalendarEventCreateTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoHighLevelContactCreateTool",
                      "title": "GoHighLevelContactCreateTool"
                    },
                    {
                      "$ref": "#/components/schemas/GoHighLevelContactGetTool",
                      "title": "GoHighLevelContactGetTool"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "type",
                    "mapping": {
                      "dtmf": "#/components/schemas/DtmfTool",
                      "endCall": "#/components/schemas/EndCallTool",
                      "function": "#/components/schemas/FunctionTool",
                      "ghl": "#/components/schemas/GhlTool",
                      "make": "#/components/schemas/MakeTool",
                      "transferCall": "#/components/schemas/TransferCallTool",
                      "output": "#/components/schemas/OutputTool",
                      "bash": "#/components/schemas/BashTool",
                      "computer": "#/components/schemas/ComputerTool",
                      "textEditor": "#/components/schemas/TextEditorTool",
                      "query": "#/components/schemas/QueryTool",
                      "google.calendar.event.create": "#/components/schemas/GoogleCalendarCreateEventTool",
                      "google.sheets.row.append": "#/components/schemas/GoogleSheetsRowAppendTool",
                      "google.calendar.availability.check": "#/components/schemas/GoogleCalendarCheckAvailabilityTool",
                      "slack.message.send": "#/components/schemas/SlackSendMessageTool",
                      "sms": "#/components/schemas/SmsTool",
                      "mcp": "#/components/schemas/McpTool",
                      "gohighlevel.calendar.availability.check": "#/components/schemas/GoHighLevelCalendarAvailabilityTool",
                      "gohighlevel.calendar.event.create": "#/components/schemas/GoHighLevelCalendarEventCreateTool",
                      "gohighlevel.contact.create": "#/components/schemas/GoHighLevelContactCreateTool",
                      "gohighlevel.contact.get": "#/components/schemas/GoHighLevelContactGetTool"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Tools"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/file": {
      "post": {
        "operationId": "FileController_create",
        "summary": "Upload File",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/CreateFileDTO"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "File uploaded successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/File"
                }
              }
            }
          },
          "400": {
            "description": "Invalid file"
          }
        },
        "tags": [
          "Files"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "get": {
        "operationId": "FileController_findAll",
        "summary": "List Files",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/File"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Files"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/file/{id}": {
      "get": {
        "operationId": "FileController_findOne",
        "summary": "Get File",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/File"
                }
              }
            }
          }
        },
        "tags": [
          "Files"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "patch": {
        "operationId": "FileController_update",
        "summary": "Update File",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateFileDTO"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/File"
                }
              }
            }
          }
        },
        "tags": [
          "Files"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "FileController_remove",
        "summary": "Delete File",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/File"
                }
              }
            }
          }
        },
        "tags": [
          "Files"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/knowledge-base": {
      "post": {
        "operationId": "KnowledgeBaseController_create",
        "summary": "Create Knowledge Base",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/CreateTrieveKnowledgeBaseDTO",
                    "title": "TrieveKnowledgeBaseDTO"
                  },
                  {
                    "$ref": "#/components/schemas/CreateCustomKnowledgeBaseDTO",
                    "title": "CustomKnowledgeBaseDTO"
                  }
                ],
                "discriminator": {
                  "propertyName": "provider",
                  "mapping": {
                    "trieve": "#/components/schemas/CreateTrieveKnowledgeBaseDTO",
                    "custom-knowledge-base": "#/components/schemas/CreateCustomKnowledgeBaseDTO"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TrieveKnowledgeBase",
                      "title": "TrieveKnowledgeBase"
                    },
                    {
                      "$ref": "#/components/schemas/CustomKnowledgeBase",
                      "title": "CustomKnowledgeBase"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "provider",
                    "mapping": {
                      "trieve": "#/components/schemas/TrieveKnowledgeBase",
                      "custom-knowledge-base": "#/components/schemas/CustomKnowledgeBase"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Knowledge Base"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "get": {
        "operationId": "KnowledgeBaseController_findAll",
        "summary": "List Knowledge Bases",
        "parameters": [
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "This is the maximum number of items to return. Defaults to 100.",
            "schema": {
              "minimum": 0,
              "maximum": 1000,
              "type": "number"
            }
          },
          {
            "name": "createdAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/TrieveKnowledgeBase",
                        "title": "TrieveKnowledgeBase"
                      },
                      {
                        "$ref": "#/components/schemas/CustomKnowledgeBase",
                        "title": "CustomKnowledgeBase"
                      }
                    ],
                    "discriminator": {
                      "propertyName": "provider",
                      "mapping": {
                        "trieve": "#/components/schemas/TrieveKnowledgeBase",
                        "custom-knowledge-base": "#/components/schemas/CustomKnowledgeBase"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Knowledge Base"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/knowledge-base/{id}": {
      "get": {
        "operationId": "KnowledgeBaseController_findOne",
        "summary": "Get Knowledge Base",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TrieveKnowledgeBase",
                      "title": "TrieveKnowledgeBase"
                    },
                    {
                      "$ref": "#/components/schemas/CustomKnowledgeBase",
                      "title": "CustomKnowledgeBase"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "provider",
                    "mapping": {
                      "trieve": "#/components/schemas/TrieveKnowledgeBase",
                      "custom-knowledge-base": "#/components/schemas/CustomKnowledgeBase"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Knowledge Base"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "patch": {
        "operationId": "KnowledgeBaseController_update",
        "summary": "Update Knowledge Base",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/UpdateTrieveKnowledgeBaseDTO",
                    "title": "UpdateTrieveKnowledgeBaseDTO"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateCustomKnowledgeBaseDTO",
                    "title": "UpdateCustomKnowledgeBaseDTO"
                  }
                ],
                "discriminator": {
                  "propertyName": "provider",
                  "mapping": {
                    "trieve": "#/components/schemas/UpdateTrieveKnowledgeBaseDTO",
                    "custom-knowledge-base": "#/components/schemas/UpdateCustomKnowledgeBaseDTO"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TrieveKnowledgeBase",
                      "title": "TrieveKnowledgeBase"
                    },
                    {
                      "$ref": "#/components/schemas/CustomKnowledgeBase",
                      "title": "CustomKnowledgeBase"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "provider",
                    "mapping": {
                      "trieve": "#/components/schemas/TrieveKnowledgeBase",
                      "custom-knowledge-base": "#/components/schemas/CustomKnowledgeBase"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Knowledge Base"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "KnowledgeBaseController_remove",
        "summary": "Delete Knowledge Base",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TrieveKnowledgeBase",
                      "title": "TrieveKnowledgeBase"
                    },
                    {
                      "$ref": "#/components/schemas/CustomKnowledgeBase",
                      "title": "CustomKnowledgeBase"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "provider",
                    "mapping": {
                      "trieve": "#/components/schemas/TrieveKnowledgeBase",
                      "custom-knowledge-base": "#/components/schemas/CustomKnowledgeBase"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Knowledge Base"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/workflow": {
      "get": {
        "operationId": "WorkflowController_findAll",
        "summary": "[BETA] Get Workflows",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Workflow"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Workflow"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "post": {
        "operationId": "WorkflowController_create",
        "summary": "[BETA] Create Workflow",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateWorkflowDTO"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Workflow"
                }
              }
            }
          }
        },
        "tags": [
          "Workflow"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/workflow/{id}": {
      "get": {
        "operationId": "WorkflowController_findOne",
        "summary": "[BETA] Get Workflow",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Workflow"
                }
              }
            }
          }
        },
        "tags": [
          "Workflow"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "WorkflowController_delete",
        "summary": "[BETA] Delete Workflow",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Workflow"
                }
              }
            }
          }
        },
        "tags": [
          "Workflow"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "patch": {
        "operationId": "WorkflowController_update",
        "summary": "[BETA] Update Workflow",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateWorkflowDTO"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Workflow"
                }
              }
            }
          }
        },
        "tags": [
          "Workflow"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/squad": {
      "post": {
        "operationId": "SquadController_create",
        "summary": "Create Squad",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateSquadDTO"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Squad"
                }
              }
            }
          }
        },
        "tags": [
          "Squads"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "get": {
        "operationId": "SquadController_findAll",
        "summary": "List Squads",
        "parameters": [
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "This is the maximum number of items to return. Defaults to 100.",
            "schema": {
              "minimum": 0,
              "maximum": 1000,
              "type": "number"
            }
          },
          {
            "name": "createdAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Squad"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Squads"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/squad/{id}": {
      "get": {
        "operationId": "SquadController_findOne",
        "summary": "Get Squad",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Squad"
                }
              }
            }
          }
        },
        "tags": [
          "Squads"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "patch": {
        "operationId": "SquadController_update",
        "summary": "Update Squad",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateSquadDTO"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Squad"
                }
              }
            }
          }
        },
        "tags": [
          "Squads"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "SquadController_remove",
        "summary": "Delete Squad",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Squad"
                }
              }
            }
          }
        },
        "tags": [
          "Squads"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/test-suite": {
      "get": {
        "operationId": "TestSuiteController_findAllPaginated",
        "summary": "List Test Suites",
        "parameters": [
          {
            "name": "page",
            "required": false,
            "in": "query",
            "description": "This is the page number to return. Defaults to 1.",
            "schema": {
              "minimum": 1,
              "type": "number"
            }
          },
          {
            "name": "sortOrder",
            "required": false,
            "in": "query",
            "description": "This is the sort order for pagination. Defaults to 'DESC'.",
            "schema": {
              "enum": [
                "ASC",
                "DESC"
              ],
              "type": "string"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "This is the maximum number of items to return. Defaults to 100.",
            "schema": {
              "minimum": 0,
              "maximum": 1000,
              "type": "number"
            }
          },
          {
            "name": "createdAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TestSuitesPaginatedResponse"
                }
              }
            }
          }
        },
        "tags": [
          "Test Suites"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "post": {
        "operationId": "TestSuiteController_create",
        "summary": "Create Test Suite",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateTestSuiteDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TestSuite"
                }
              }
            }
          }
        },
        "tags": [
          "Test Suites"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/test-suite/{id}": {
      "get": {
        "operationId": "TestSuiteController_findOne",
        "summary": "Get Test Suite",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TestSuite"
                }
              }
            }
          }
        },
        "tags": [
          "Test Suites"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "patch": {
        "operationId": "TestSuiteController_update",
        "summary": "Update Test Suite",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateTestSuiteDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TestSuite"
                }
              }
            }
          }
        },
        "tags": [
          "Test Suites"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "TestSuiteController_remove",
        "summary": "Delete Test Suite",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TestSuite"
                }
              }
            }
          }
        },
        "tags": [
          "Test Suites"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/test-suite/{testSuiteId}/test": {
      "get": {
        "operationId": "TestSuiteTestController_findAllPaginated",
        "summary": "List Tests",
        "parameters": [
          {
            "name": "testSuiteId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "required": false,
            "in": "query",
            "description": "This is the page number to return. Defaults to 1.",
            "schema": {
              "minimum": 1,
              "type": "number"
            }
          },
          {
            "name": "sortOrder",
            "required": false,
            "in": "query",
            "description": "This is the sort order for pagination. Defaults to 'DESC'.",
            "schema": {
              "enum": [
                "ASC",
                "DESC"
              ],
              "type": "string"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "This is the maximum number of items to return. Defaults to 100.",
            "schema": {
              "minimum": 0,
              "maximum": 1000,
              "type": "number"
            }
          },
          {
            "name": "createdAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TestSuiteTestsPaginatedResponse"
                }
              }
            }
          }
        },
        "tags": [
          "Test Suite Tests"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "post": {
        "operationId": "TestSuiteTestController_create",
        "summary": "Create Test",
        "parameters": [
          {
            "name": "testSuiteId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/CreateTestSuiteTestVoiceDto",
                    "title": "TestSuiteTestVoice"
                  },
                  {
                    "$ref": "#/components/schemas/CreateTestSuiteTestChatDto",
                    "title": "TestSuiteTestChat"
                  }
                ],
                "discriminator": {
                  "propertyName": "type",
                  "mapping": {
                    "voice": "#/components/schemas/CreateTestSuiteTestVoiceDto",
                    "chat": "#/components/schemas/CreateTestSuiteTestChatDto"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TestSuiteTestVoice",
                      "title": "Voice"
                    },
                    {
                      "$ref": "#/components/schemas/TestSuiteTestChat",
                      "title": "Chat"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "type",
                    "mapping": {
                      "voice": "#/components/schemas/TestSuiteTestVoice",
                      "chat": "#/components/schemas/TestSuiteTestChat"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Test Suite Tests"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/test-suite/{testSuiteId}/test/{id}": {
      "get": {
        "operationId": "TestSuiteTestController_findOne",
        "summary": "Get Test",
        "parameters": [
          {
            "name": "testSuiteId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TestSuiteTestVoice",
                      "title": "Voice"
                    },
                    {
                      "$ref": "#/components/schemas/TestSuiteTestChat",
                      "title": "Chat"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "type",
                    "mapping": {
                      "voice": "#/components/schemas/TestSuiteTestVoice",
                      "chat": "#/components/schemas/TestSuiteTestChat"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Test Suite Tests"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "patch": {
        "operationId": "TestSuiteTestController_update",
        "summary": "Update Test",
        "parameters": [
          {
            "name": "testSuiteId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/UpdateTestSuiteTestVoiceDto",
                    "title": "TestSuiteTestVoice"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateTestSuiteTestChatDto",
                    "title": "TestSuiteTestChat"
                  }
                ],
                "discriminator": {
                  "propertyName": "type",
                  "mapping": {
                    "voice": "#/components/schemas/UpdateTestSuiteTestVoiceDto",
                    "chat": "#/components/schemas/UpdateTestSuiteTestChatDto"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TestSuiteTestVoice",
                      "title": "Voice"
                    },
                    {
                      "$ref": "#/components/schemas/TestSuiteTestChat",
                      "title": "Chat"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "type",
                    "mapping": {
                      "voice": "#/components/schemas/TestSuiteTestVoice",
                      "chat": "#/components/schemas/TestSuiteTestChat"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Test Suite Tests"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "TestSuiteTestController_remove",
        "summary": "Delete Test",
        "parameters": [
          {
            "name": "testSuiteId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TestSuiteTestVoice",
                      "title": "Voice"
                    },
                    {
                      "$ref": "#/components/schemas/TestSuiteTestChat",
                      "title": "Chat"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "type",
                    "mapping": {
                      "voice": "#/components/schemas/TestSuiteTestVoice",
                      "chat": "#/components/schemas/TestSuiteTestChat"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Test Suite Tests"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/test-suite/{testSuiteId}/run": {
      "get": {
        "operationId": "TestSuiteRunController_findAllPaginated",
        "summary": "List Test Suite Runs",
        "parameters": [
          {
            "name": "testSuiteId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "required": false,
            "in": "query",
            "description": "This is the page number to return. Defaults to 1.",
            "schema": {
              "minimum": 1,
              "type": "number"
            }
          },
          {
            "name": "sortOrder",
            "required": false,
            "in": "query",
            "description": "This is the sort order for pagination. Defaults to 'DESC'.",
            "schema": {
              "enum": [
                "ASC",
                "DESC"
              ],
              "type": "string"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "This is the maximum number of items to return. Defaults to 100.",
            "schema": {
              "minimum": 0,
              "maximum": 1000,
              "type": "number"
            }
          },
          {
            "name": "createdAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TestSuiteRunsPaginatedResponse"
                }
              }
            }
          }
        },
        "tags": [
          "Test Suite Runs"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "post": {
        "operationId": "TestSuiteRunController_create",
        "summary": "Create Test Suite Run",
        "parameters": [
          {
            "name": "testSuiteId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateTestSuiteRunDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TestSuiteRun"
                }
              }
            }
          }
        },
        "tags": [
          "Test Suite Runs"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/test-suite/{testSuiteId}/run/{id}": {
      "get": {
        "operationId": "TestSuiteRunController_findOne",
        "summary": "Get Test Suite Run",
        "parameters": [
          {
            "name": "testSuiteId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TestSuiteRun"
                }
              }
            }
          }
        },
        "tags": [
          "Test Suite Runs"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "patch": {
        "operationId": "TestSuiteRunController_update",
        "summary": "Update Test Suite Run",
        "parameters": [
          {
            "name": "testSuiteId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateTestSuiteRunDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TestSuiteRun"
                }
              }
            }
          }
        },
        "tags": [
          "Test Suite Runs"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "TestSuiteRunController_remove",
        "summary": "Delete Test Suite Run",
        "parameters": [
          {
            "name": "testSuiteId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TestSuiteRun"
                }
              }
            }
          }
        },
        "tags": [
          "Test Suite Runs"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/analytics": {
      "post": {
        "operationId": "AnalyticsController_query",
        "summary": "Create Analytics Queries",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AnalyticsQueryDTO"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/AnalyticsQueryResult"
                  }
                }
              }
            }
          },
          "201": {
            "description": ""
          }
        },
        "tags": [
          "Analytics"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/logs": {
      "get": {
        "operationId": "LoggingController_logsQuery",
        "summary": "Get Logs",
        "deprecated": true,
        "parameters": [
          {
            "name": "type",
            "required": false,
            "in": "query",
            "description": "This is the type of the log.",
            "schema": {
              "enum": [
                "API",
                "Webhook",
                "Call",
                "Provider"
              ],
              "type": "string"
            }
          },
          {
            "name": "webhookType",
            "required": false,
            "in": "query",
            "description": "This is the type of the webhook, given the log is from a webhook.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "assistantId",
            "required": false,
            "in": "query",
            "description": "This is the ID of the assistant.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "phoneNumberId",
            "required": false,
            "in": "query",
            "description": "This is the ID of the phone number.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "customerId",
            "required": false,
            "in": "query",
            "description": "This is the ID of the customer.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "squadId",
            "required": false,
            "in": "query",
            "description": "This is the ID of the squad.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "callId",
            "required": false,
            "in": "query",
            "description": "This is the ID of the call.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "required": false,
            "in": "query",
            "description": "This is the page number to return. Defaults to 1.",
            "schema": {
              "minimum": 1,
              "type": "number"
            }
          },
          {
            "name": "sortOrder",
            "required": false,
            "in": "query",
            "description": "This is the sort order for pagination. Defaults to 'DESC'.",
            "schema": {
              "enum": [
                "ASC",
                "DESC"
              ],
              "type": "string"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "This is the maximum number of items to return. Defaults to 100.",
            "schema": {
              "minimum": 0,
              "maximum": 1000,
              "type": "number"
            }
          },
          {
            "name": "createdAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "createdAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the createdAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLt",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtGe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is greater than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          },
          {
            "name": "updatedAtLe",
            "required": false,
            "in": "query",
            "description": "This will return items where the updatedAt is less than or equal to the specified value.",
            "schema": {
              "format": "date-time",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LogsPaginatedResponse"
                }
              }
            }
          }
        },
        "tags": [
          "Logs"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "LoggingController_logsDeleteQuery",
        "summary": "Delete Logs",
        "deprecated": true,
        "parameters": [
          {
            "name": "type",
            "required": false,
            "in": "query",
            "description": "This is the type of the log.",
            "schema": {
              "enum": [
                "API",
                "Webhook",
                "Call",
                "Provider"
              ],
              "type": "string"
            }
          },
          {
            "name": "assistantId",
            "required": false,
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "phoneNumberId",
            "required": false,
            "in": "query",
            "description": "This is the ID of the phone number.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "customerId",
            "required": false,
            "in": "query",
            "description": "This is the ID of the customer.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "squadId",
            "required": false,
            "in": "query",
            "description": "This is the ID of the squad.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "callId",
            "required": false,
            "in": "query",
            "description": "This is the ID of the call.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Logs"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    }
  },
  "info": {
    "title": "Vapi API",
    "description": "Voice AI for developers.",
    "version": "1.0",
    "contact": {}
  },
  "tags": [],
  "servers": [
    {
      "url": "https://api.vapi.ai"
    }
  ],
  "components": {
    "securitySchemes": {
      "bearer": {
        "scheme": "bearer",
        "bearerFormat": "Bearer",
        "type": "http",
        "description": "Retrieve your API Key from [Dashboard](dashboard.vapi.ai)."
      }
    },
    "schemas": {
      "AnalysisCostBreakdown": {
        "type": "object",
        "properties": {
          "summary": {
            "type": "number",
            "description": "This is the cost to summarize the call."
          },
          "summaryPromptTokens": {
            "type": "number",
            "description": "This is the number of prompt tokens used to summarize the call."
          },
          "summaryCompletionTokens": {
            "type": "number",
            "description": "This is the number of completion tokens used to summarize the call."
          },
          "structuredData": {
            "type": "number",
            "description": "This is the cost to extract structured data from the call."
          },
          "structuredDataPromptTokens": {
            "type": "number",
            "description": "This is the number of prompt tokens used to extract structured data from the call."
          },
          "structuredDataCompletionTokens": {
            "type": "number",
            "description": "This is the number of completion tokens used to extract structured data from the call."
          },
          "successEvaluation": {
            "type": "number",
            "description": "This is the cost to evaluate if the call was successful."
          },
          "successEvaluationPromptTokens": {
            "type": "number",
            "description": "This is the number of prompt tokens used to evaluate if the call was successful."
          },
          "successEvaluationCompletionTokens": {
            "type": "number",
            "description": "This is the number of completion tokens used to evaluate if the call was successful."
          }
        }
      },
      "CostBreakdown": {
        "type": "object",
        "properties": {
          "transport": {
            "type": "number",
            "description": "This is the cost of the transport provider, like Twilio or Vonage."
          },
          "stt": {
            "type": "number",
            "description": "This is the cost of the speech-to-text service."
          },
          "llm": {
            "type": "number",
            "description": "This is the cost of the language model."
          },
          "tts": {
            "type": "number",
            "description": "This is the cost of the text-to-speech service."
          },
          "vapi": {
            "type": "number",
            "description": "This is the cost of Vapi."
          },
          "total": {
            "type": "number",
            "description": "This is the total cost of the call."
          },
          "llmPromptTokens": {
            "type": "number",
            "description": "This is the LLM prompt tokens used for the call."
          },
          "llmCompletionTokens": {
            "type": "number",
            "description": "This is the LLM completion tokens used for the call."
          },
          "ttsCharacters": {
            "type": "number",
            "description": "This is the TTS characters used for the call."
          },
          "analysisCostBreakdown": {
            "description": "This is the cost of the analysis.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnalysisCostBreakdown"
              }
            ]
          }
        }
      },
      "TranscriptPlan": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "This determines whether the transcript is stored in `call.artifact.transcript`. Defaults to true.\n\n@default true",
            "example": true
          },
          "assistantName": {
            "type": "string",
            "description": "This is the name of the assistant in the transcript. Defaults to 'AI'.\n\nUsage:\n- If you want to change the name of the assistant in the transcript, set this. Example, here is what the transcript would look like with `assistantName` set to 'Buyer':\n```\nUser: Hello, how are you?\nBuyer: I'm fine.\nUser: Do you want to buy a car?\nBuyer: No.\n```\n\n@default 'AI'"
          },
          "userName": {
            "type": "string",
            "description": "This is the name of the user in the transcript. Defaults to 'User'.\n\nUsage:\n- If you want to change the name of the user in the transcript, set this. Example, here is what the transcript would look like with `userName` set to 'Seller':\n```\nSeller: Hello, how are you?\nAI: I'm fine.\nSeller: Do you want to buy a car?\nAI: No.\n```\n\n@default 'User'"
          }
        }
      },
      "ArtifactPlan": {
        "type": "object",
        "properties": {
          "recordingEnabled": {
            "type": "boolean",
            "description": "This determines whether assistant's calls are recorded. Defaults to true.\n\nUsage:\n- If you don't want to record the calls, set this to false.\n- If you want to record the calls when `assistant.hipaaEnabled` (deprecated) or `assistant.compliancePlan.hipaaEnabled` explicity set this to true and make sure to provide S3 or GCP credentials on the Provider Credentials page in the Dashboard.\n\nYou can find the recording at `call.artifact.recordingUrl` and `call.artifact.stereoRecordingUrl` after the call is ended.\n\n@default true",
            "example": true
          },
          "recordingFormat": {
            "type": "string",
            "description": "This determines the format of the recording. Defaults to `wav;l16`.\n\n@default 'wav;l16'",
            "enum": [
              "wav;l16",
              "mp3"
            ]
          },
          "videoRecordingEnabled": {
            "type": "boolean",
            "description": "This determines whether the video is recorded during the call. Defaults to false. Only relevant for `webCall` type.\n\nYou can find the video recording at `call.artifact.videoRecordingUrl` after the call is ended.\n\n@default false",
            "example": false
          },
          "pcapEnabled": {
            "type": "boolean",
            "description": "This determines whether the SIP packet capture is enabled. Defaults to true. Only relevant for `phone` type calls where phone number's provider is `vapi` or `byo-phone-number`.\n\nYou can find the packet capture at `call.artifact.pcapUrl` after the call is ended.\n\n@default true",
            "example": true
          },
          "pcapS3PathPrefix": {
            "type": "string",
            "description": "This is the path where the SIP packet capture will be uploaded. This is only used if you have provided S3 or GCP credentials on the Provider Credentials page in the Dashboard.\n\nIf credential.s3PathPrefix or credential.bucketPlan.path is set, this will append to it.\n\nUsage:\n- If you want to upload the packet capture to a specific path, set this to the path. Example: `/my-assistant-captures`.\n- If you want to upload the packet capture to the root of the bucket, set this to `/`.\n\n@default '/'",
            "example": "/pcaps"
          },
          "transcriptPlan": {
            "description": "This is the plan for `call.artifact.transcript`. To disable, set `transcriptPlan.enabled` to false.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TranscriptPlan"
              }
            ]
          },
          "recordingPath": {
            "type": "string",
            "description": "This is the path where the recording will be uploaded. This is only used if you have provided S3 or GCP credentials on the Provider Credentials page in the Dashboard.\n\nIf credential.s3PathPrefix or credential.bucketPlan.path is set, this will append to it.\n\nUsage:\n- If you want to upload the recording to a specific path, set this to the path. Example: `/my-assistant-recordings`.\n- If you want to upload the recording to the root of the bucket, set this to `/`.\n\n@default '/'"
          }
        }
      },
      "Analysis": {
        "type": "object",
        "properties": {
          "summary": {
            "type": "string",
            "description": "This is the summary of the call. Customize by setting `assistant.analysisPlan.summaryPrompt`."
          },
          "structuredData": {
            "type": "object",
            "description": "This is the structured data extracted from the call. Customize by setting `assistant.analysisPlan.structuredDataPrompt` and/or `assistant.analysisPlan.structuredDataSchema`."
          },
          "structuredDataMulti": {
            "description": "This is the structured data catalog of the call. Customize by setting `assistant.analysisPlan.structuredDataMultiPlan`.",
            "type": "array",
            "items": {
              "type": "object"
            }
          },
          "successEvaluation": {
            "type": "string",
            "description": "This is the evaluation of the call. Customize by setting `assistant.analysisPlan.successEvaluationPrompt` and/or `assistant.analysisPlan.successEvaluationRubric`."
          }
        }
      },
      "Monitor": {
        "type": "object",
        "properties": {
          "listenUrl": {
            "type": "string",
            "description": "This is the URL where the assistant's calls can be listened to in real-time. To enable, set `assistant.monitorPlan.listenEnabled` to `true`."
          },
          "controlUrl": {
            "type": "string",
            "description": "This is the URL where the assistant's calls can be controlled in real-time. To enable, set `assistant.monitorPlan.controlEnabled` to `true`."
          }
        }
      },
      "OpenAIMessage": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string",
            "nullable": true,
            "maxLength": 100000000
          },
          "role": {
            "type": "string",
            "enum": [
              "assistant",
              "function",
              "user",
              "system",
              "tool"
            ]
          }
        },
        "required": [
          "content",
          "role"
        ]
      },
      "Mono": {
        "type": "object",
        "properties": {
          "combinedUrl": {
            "type": "string",
            "description": "This is the combined recording url for the call. To enable, set `assistant.artifactPlan.recordingEnabled`."
          },
          "assistantUrl": {
            "type": "string",
            "description": "This is the mono recording url for the assistant. To enable, set `assistant.artifactPlan.recordingEnabled`."
          },
          "customerUrl": {
            "type": "string",
            "description": "This is the mono recording url for the customer. To enable, set `assistant.artifactPlan.recordingEnabled`."
          }
        }
      },
      "Recording": {
        "type": "object",
        "properties": {
          "stereoUrl": {
            "type": "string",
            "description": "This is the stereo recording url for the call. To enable, set `assistant.artifactPlan.recordingEnabled`."
          },
          "videoUrl": {
            "type": "string",
            "description": "This is the video recording url for the call. To enable, set `assistant.artifactPlan.videoRecordingEnabled`."
          },
          "videoRecordingStartDelaySeconds": {
            "type": "number",
            "description": "This is video recording start delay in ms. To enable, set `assistant.artifactPlan.videoRecordingEnabled`. This can be used to align the playback of the recording with artifact.messages timestamps."
          },
          "mono": {
            "description": "This is the mono recording url for the call. To enable, set `assistant.artifactPlan.recordingEnabled`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Mono"
              }
            ]
          }
        }
      },
      "NodeArtifact": {
        "type": "object",
        "properties": {
          "nodeName": {
            "type": "string",
            "description": "This is the node id."
          },
          "messages": {
            "description": "This is the messages that were spoken during the node.",
            "type": "array",
            "items": {
              "type": "object"
            }
          },
          "variables": {
            "type": "object",
            "description": "This is the object containing the variables extracted from the node."
          }
        }
      },
      "Artifact": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that were spoken during the call.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/UserMessage",
                  "title": "UserMessage"
                },
                {
                  "$ref": "#/components/schemas/SystemMessage",
                  "title": "SystemMessage"
                },
                {
                  "$ref": "#/components/schemas/BotMessage",
                  "title": "BotMessage"
                },
                {
                  "$ref": "#/components/schemas/ToolCallMessage",
                  "title": "ToolCallMessage"
                },
                {
                  "$ref": "#/components/schemas/ToolCallResultMessage",
                  "title": "ToolCallResultMessage"
                }
              ]
            }
          },
          "messagesOpenAIFormatted": {
            "description": "These are the messages that were spoken during the call, formatted for OpenAI.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            }
          },
          "recordingUrl": {
            "type": "string",
            "description": "This is the recording url for the call. To enable, set `assistant.artifactPlan.recordingEnabled`.",
            "deprecated": true
          },
          "stereoRecordingUrl": {
            "type": "string",
            "description": "This is the stereo recording url for the call. To enable, set `assistant.artifactPlan.recordingEnabled`.",
            "deprecated": true
          },
          "videoRecordingUrl": {
            "type": "string",
            "description": "This is video recording url for the call. To enable, set `assistant.artifactPlan.videoRecordingEnabled`.",
            "deprecated": true
          },
          "videoRecordingStartDelaySeconds": {
            "type": "number",
            "description": "This is video recording start delay in ms. To enable, set `assistant.artifactPlan.videoRecordingEnabled`. This can be used to align the playback of the recording with artifact.messages timestamps.",
            "deprecated": true
          },
          "recording": {
            "description": "This is the recording url for the call. To enable, set `assistant.artifactPlan.recordingEnabled`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Recording"
              }
            ]
          },
          "transcript": {
            "type": "string",
            "description": "This is the transcript of the call. This is derived from `artifact.messages` but provided for convenience."
          },
          "pcapUrl": {
            "type": "string",
            "description": "This is the packet capture url for the call. This is only available for `phone` type calls where phone number's provider is `vapi` or `byo-phone-number`."
          },
          "nodes": {
            "description": "This is the history of workflow nodes that were executed during the call.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NodeArtifact"
            }
          },
          "variables": {
            "type": "object",
            "description": "This is the state of variables at the end of the workflow execution."
          }
        }
      },
      "FallbackTranscriberPlan": {
        "type": "object",
        "properties": {
          "transcribers": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/FallbackAssemblyAITranscriber",
                  "title": "AssemblyAI"
                },
                {
                  "$ref": "#/components/schemas/FallbackAzureSpeechTranscriber",
                  "title": "Azure"
                },
                {
                  "$ref": "#/components/schemas/FallbackCustomTranscriber",
                  "title": "Custom"
                },
                {
                  "$ref": "#/components/schemas/FallbackDeepgramTranscriber",
                  "title": "Deepgram"
                },
                {
                  "$ref": "#/components/schemas/FallbackElevenLabsTranscriber",
                  "title": "ElevenLabs"
                },
                {
                  "$ref": "#/components/schemas/FallbackGladiaTranscriber",
                  "title": "Gladia"
                },
                {
                  "$ref": "#/components/schemas/FallbackGoogleTranscriber",
                  "title": "Google"
                },
                {
                  "$ref": "#/components/schemas/FallbackTalkscriberTranscriber",
                  "title": "Talkscriber"
                },
                {
                  "$ref": "#/components/schemas/FallbackSpeechmaticsTranscriber",
                  "title": "Speechmatics"
                },
                {
                  "$ref": "#/components/schemas/FallbackOpenAITranscriber",
                  "title": "OpenAI"
                }
              ]
            }
          }
        },
        "required": [
          "transcribers"
        ]
      },
      "AssemblyAITranscriber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the transcription provider that will be used.",
            "enum": [
              "assembly-ai"
            ]
          },
          "language": {
            "type": "string",
            "description": "This is the language that will be set for the transcription.",
            "enum": [
              "en"
            ]
          },
          "confidenceThreshold": {
            "type": "number",
            "description": "Transcripts below this confidence threshold will be discarded.\n\n@default 0.4",
            "minimum": 0,
            "maximum": 1,
            "example": 0.4
          },
          "realtimeUrl": {
            "type": "string",
            "description": "The WebSocket URL that the transcriber connects to."
          },
          "wordBoost": {
            "description": "Add up to 2500 characters of custom vocabulary.",
            "type": "array",
            "items": {
              "type": "string",
              "maxLength": 2500
            }
          },
          "endUtteranceSilenceThreshold": {
            "type": "number",
            "description": "The duration of the end utterance silence threshold in milliseconds."
          },
          "disablePartialTranscripts": {
            "type": "boolean",
            "description": "Disable partial transcripts.\nSet to `true` to not receive partial transcripts. Defaults to `false`."
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackTranscriberPlan"
              }
            ]
          }
        },
        "required": [
          "provider"
        ]
      },
      "AzureSpeechTranscriber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the transcription provider that will be used.",
            "enum": [
              "azure"
            ]
          },
          "language": {
            "type": "string",
            "description": "This is the language that will be set for the transcription. The list of languages Azure supports can be found here: https://learn.microsoft.com/en-us/azure/ai-services/speech-service/language-support?tabs=stt",
            "enum": [
              "af-ZA",
              "am-ET",
              "ar-AE",
              "ar-BH",
              "ar-DZ",
              "ar-EG",
              "ar-IL",
              "ar-IQ",
              "ar-JO",
              "ar-KW",
              "ar-LB",
              "ar-LY",
              "ar-MA",
              "ar-OM",
              "ar-PS",
              "ar-QA",
              "ar-SA",
              "ar-SY",
              "ar-TN",
              "ar-YE",
              "az-AZ",
              "bg-BG",
              "bn-IN",
              "bs-BA",
              "ca-ES",
              "cs-CZ",
              "cy-GB",
              "da-DK",
              "de-AT",
              "de-CH",
              "de-DE",
              "el-GR",
              "en-AU",
              "en-CA",
              "en-GB",
              "en-GH",
              "en-HK",
              "en-IE",
              "en-IN",
              "en-KE",
              "en-NG",
              "en-NZ",
              "en-PH",
              "en-SG",
              "en-TZ",
              "en-US",
              "en-ZA",
              "es-AR",
              "es-BO",
              "es-CL",
              "es-CO",
              "es-CR",
              "es-CU",
              "es-DO",
              "es-EC",
              "es-ES",
              "es-GQ",
              "es-GT",
              "es-HN",
              "es-MX",
              "es-NI",
              "es-PA",
              "es-PE",
              "es-PR",
              "es-PY",
              "es-SV",
              "es-US",
              "es-UY",
              "es-VE",
              "et-EE",
              "eu-ES",
              "fa-IR",
              "fi-FI",
              "fil-PH",
              "fr-BE",
              "fr-CA",
              "fr-CH",
              "fr-FR",
              "ga-IE",
              "gl-ES",
              "gu-IN",
              "he-IL",
              "hi-IN",
              "hr-HR",
              "hu-HU",
              "hy-AM",
              "id-ID",
              "is-IS",
              "it-CH",
              "it-IT",
              "ja-JP",
              "jv-ID",
              "ka-GE",
              "kk-KZ",
              "km-KH",
              "kn-IN",
              "ko-KR",
              "lo-LA",
              "lt-LT",
              "lv-LV",
              "mk-MK",
              "ml-IN",
              "mn-MN",
              "mr-IN",
              "ms-MY",
              "mt-MT",
              "my-MM",
              "nb-NO",
              "ne-NP",
              "nl-BE",
              "nl-NL",
              "pa-IN",
              "pl-PL",
              "ps-AF",
              "pt-BR",
              "pt-PT",
              "ro-RO",
              "ru-RU",
              "si-LK",
              "sk-SK",
              "sl-SI",
              "so-SO",
              "sq-AL",
              "sr-RS",
              "sv-SE",
              "sw-KE",
              "sw-TZ",
              "ta-IN",
              "te-IN",
              "th-TH",
              "tr-TR",
              "uk-UA",
              "ur-IN",
              "uz-UZ",
              "vi-VN",
              "wuu-CN",
              "yue-CN",
              "zh-CN",
              "zh-CN-shandong",
              "zh-CN-sichuan",
              "zh-HK",
              "zh-TW",
              "zu-ZA"
            ]
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackTranscriberPlan"
              }
            ]
          }
        },
        "required": [
          "provider"
        ]
      },
      "BackoffPlan": {
        "type": "object",
        "properties": {
          "type": {
            "type": "object",
            "description": "This is the type of backoff plan to use. Defaults to fixed.\n\n@default fixed",
            "enum": [
              "fixed",
              "exponential"
            ],
            "example": "fixed"
          },
          "maxRetries": {
            "type": "number",
            "description": "This is the maximum number of retries to attempt if the request fails. Defaults to 0 (no retries).\n\n@default 0",
            "minimum": 0,
            "maximum": 10,
            "example": 0
          },
          "baseDelaySeconds": {
            "type": "number",
            "description": "This is the base delay in seconds. For linear backoff, this is the delay between each retry. For exponential backoff, this is the initial delay.",
            "minimum": 0,
            "maximum": 10,
            "example": 1
          }
        },
        "required": [
          "type",
          "maxRetries",
          "baseDelaySeconds"
        ]
      },
      "Server": {
        "type": "object",
        "properties": {
          "timeoutSeconds": {
            "type": "number",
            "description": "This is the timeout in seconds for the request. Defaults to 20 seconds.\n\n@default 20",
            "minimum": 1,
            "maximum": 300,
            "example": 20
          },
          "url": {
            "type": "string",
            "description": "This is where the request will be sent."
          },
          "headers": {
            "type": "object",
            "description": "These are the headers to include in the request.\n\nEach key-value pair represents a header name and its value."
          },
          "backoffPlan": {
            "description": "This is the backoff plan if the request fails. Defaults to undefined (the request will not be retried).\n\n@default undefined (the request will not be retried)",
            "allOf": [
              {
                "$ref": "#/components/schemas/BackoffPlan"
              }
            ]
          }
        }
      },
      "CustomTranscriber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the transcription provider that will be used. Use `custom-transcriber` for providers that are not natively supported.",
            "enum": [
              "custom-transcriber"
            ]
          },
          "server": {
            "description": "This is where the transcription request will be sent.\n\nUsage:\n1. Vapi will initiate a websocket connection with `server.url`.\n\n2. Vapi will send an initial text frame with the sample rate. Format:\n```\n    {\n      \"type\": \"start\",\n      \"encoding\": \"linear16\", // 16-bit raw PCM format\n      \"container\": \"raw\",\n      \"sampleRate\": {{sampleRate}},\n      \"channels\": 2 // customer is channel 0, assistant is channel 1\n    }\n```\n\n3. Vapi will send the audio data in 16-bit raw PCM format as binary frames.\n\n4. You can read the messages something like this:\n```\nws.on('message', (data, isBinary) => {\n  if (isBinary) {\n    pcmBuffer = Buffer.concat([pcmBuffer, data]);\n    console.log(`Received PCM data, buffer size: ${pcmBuffer.length}`);\n  } else {\n    console.log('Received message:', JSON.parse(data.toString()));\n  }\n});\n```\n\n5. You will respond with transcriptions as you have them. Format:\n```\n {\n    \"type\": \"transcriber-response\",\n    \"transcription\": \"Hello, world!\",\n    \"channel\": \"customer\" | \"assistant\"\n }\n```",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackTranscriberPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "server"
        ]
      },
      "DeepgramTranscriber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the transcription provider that will be used.",
            "enum": [
              "deepgram"
            ]
          },
          "model": {
            "description": "This is the Deepgram model that will be used. A list of models can be found here: https://developers.deepgram.com/docs/models-languages-overview",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "nova-3",
                  "nova-3-general",
                  "nova-3-medical",
                  "nova-2",
                  "nova-2-general",
                  "nova-2-meeting",
                  "nova-2-phonecall",
                  "nova-2-finance",
                  "nova-2-conversationalai",
                  "nova-2-voicemail",
                  "nova-2-video",
                  "nova-2-medical",
                  "nova-2-drivethru",
                  "nova-2-automotive",
                  "nova",
                  "nova-general",
                  "nova-phonecall",
                  "nova-medical",
                  "enhanced",
                  "enhanced-general",
                  "enhanced-meeting",
                  "enhanced-phonecall",
                  "enhanced-finance",
                  "base",
                  "base-general",
                  "base-meeting",
                  "base-phonecall",
                  "base-finance",
                  "base-conversationalai",
                  "base-voicemail",
                  "base-video",
                  "whisper"
                ]
              },
              {
                "type": "string"
              }
            ]
          },
          "language": {
            "type": "string",
            "description": "This is the language that will be set for the transcription. The list of languages Deepgram supports can be found here: https://developers.deepgram.com/docs/models-languages-overview",
            "enum": [
              "ar",
              "az",
              "ba",
              "bg",
              "br",
              "ca",
              "cs",
              "da",
              "da-DK",
              "de",
              "de-CH",
              "el",
              "en",
              "en-AU",
              "en-GB",
              "en-IN",
              "en-NZ",
              "en-US",
              "es",
              "es-419",
              "es-LATAM",
              "et",
              "eu",
              "fi",
              "fr",
              "fr-CA",
              "ha",
              "haw",
              "he",
              "hi",
              "hi-Latn",
              "hu",
              "id",
              "is",
              "it",
              "ja",
              "jw",
              "kn",
              "ko",
              "ko-KR",
              "ln",
              "lt",
              "lv",
              "mk",
              "ms",
              "multi",
              "nl",
              "nl-BE",
              "no",
              "pl",
              "pt",
              "pt-BR",
              "ro",
              "ru",
              "sk",
              "sl",
              "sn",
              "so",
              "sr",
              "su",
              "sv",
              "sv-SE",
              "ta",
              "taq",
              "th",
              "th-TH",
              "tr",
              "tt",
              "uk",
              "ur",
              "vi",
              "yo",
              "zh",
              "zh-CN",
              "zh-HK",
              "zh-Hans",
              "zh-Hant",
              "zh-TW"
            ]
          },
          "smartFormat": {
            "type": "boolean",
            "description": "This will be use smart format option provided by Deepgram. It's default disabled because it can sometimes format numbers as times but it's getting better.",
            "example": false
          },
          "codeSwitchingEnabled": {
            "type": "boolean",
            "description": "This automatically switches the transcriber's language when the customer's language changes. Defaults to false.\n\nUsage:\n- If your customers switch languages mid-call, you can set this to true.\n\nNote:\n- To detect language changes, Vapi uses a custom trained model. Languages supported (X = limited support):\n  1. Arabic\n  2. Bengali\n  3. Cantonese\n  4. Chinese\n  5. Chinese Simplified (X)\n  6. Chinese Traditional (X)\n  7. English\n  8. Farsi (X)\n  9. French\n  10. German\n  11. Haitian Creole (X)\n  12. Hindi\n  13. Italian\n  14. Japanese\n  15. Korean\n  16. Portuguese\n  17. Russian\n  18. Spanish\n  19. Thai\n  20. Urdu\n  21. Vietnamese\n- To receive `language-change-detected` webhook events, add it to `assistant.serverMessages`.\n\n@default false",
            "example": false
          },
          "mipOptOut": {
            "type": "boolean",
            "description": "If set to true, this will add mip_opt_out=true as a query parameter of all API requests. See https://developers.deepgram.com/docs/the-deepgram-model-improvement-partnership-program#want-to-opt-out\n\nThis will only be used if you are using your own Deepgram API key.\n\n@default false",
            "example": false,
            "default": false
          },
          "numerals": {
            "type": "boolean",
            "description": "If set to true, this will cause deepgram to convert spoken numbers to literal numerals. For example, \"my phone number is nine-seven-two...\" would become \"my phone number is 972...\"\n\n@default false",
            "example": false
          },
          "confidenceThreshold": {
            "type": "number",
            "description": "Transcripts below this confidence threshold will be discarded.\n\n@default 0.4",
            "minimum": 0,
            "maximum": 1,
            "example": 0.4
          },
          "keywords": {
            "description": "These keywords are passed to the transcription model to help it pick up use-case specific words. Anything that may not be a common word, like your company name, should be added here.",
            "type": "array",
            "items": {
              "type": "string",
              "pattern": "/^\\p{L}[\\p{L}\\d]*(?::[+-]?\\d+)?$/u"
            }
          },
          "keyterm": {
            "description": "Keyterm Prompting allows you improve Keyword Recall Rate (KRR) for important keyterms or phrases up to 90%.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "endpointing": {
            "type": "number",
            "description": "This is the timeout after which Deepgram will send transcription on user silence. You can read in-depth documentation here: https://developers.deepgram.com/docs/endpointing.\n\nHere are the most important bits:\n- Defaults to 10. This is recommended for most use cases to optimize for latency.\n- 10 can cause some missing transcriptions since because of the shorter context. This mostly happens for one-word utterances. For those uses cases, it's recommended to try 300. It will add a bit of latency but the quality and reliability of the experience will be better.\n- If neither 10 nor 300 work, contact support@vapi.ai and we'll find another solution.\n\n@default 10",
            "minimum": 10,
            "maximum": 500
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackTranscriberPlan"
              }
            ]
          }
        },
        "required": [
          "provider"
        ]
      },
      "ElevenLabsTranscriber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the transcription provider that will be used.",
            "enum": [
              "11labs"
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used for the transcription.",
            "enum": [
              "scribe_v1"
            ]
          },
          "language": {
            "type": "string",
            "enum": [
              "aa",
              "ab",
              "ae",
              "af",
              "ak",
              "am",
              "an",
              "ar",
              "as",
              "av",
              "ay",
              "az",
              "ba",
              "be",
              "bg",
              "bh",
              "bi",
              "bm",
              "bn",
              "bo",
              "br",
              "bs",
              "ca",
              "ce",
              "ch",
              "co",
              "cr",
              "cs",
              "cu",
              "cv",
              "cy",
              "da",
              "de",
              "dv",
              "dz",
              "ee",
              "el",
              "en",
              "eo",
              "es",
              "et",
              "eu",
              "fa",
              "ff",
              "fi",
              "fj",
              "fo",
              "fr",
              "fy",
              "ga",
              "gd",
              "gl",
              "gn",
              "gu",
              "gv",
              "ha",
              "he",
              "hi",
              "ho",
              "hr",
              "ht",
              "hu",
              "hy",
              "hz",
              "ia",
              "id",
              "ie",
              "ig",
              "ii",
              "ik",
              "io",
              "is",
              "it",
              "iu",
              "ja",
              "jv",
              "ka",
              "kg",
              "ki",
              "kj",
              "kk",
              "kl",
              "km",
              "kn",
              "ko",
              "kr",
              "ks",
              "ku",
              "kv",
              "kw",
              "ky",
              "la",
              "lb",
              "lg",
              "li",
              "ln",
              "lo",
              "lt",
              "lu",
              "lv",
              "mg",
              "mh",
              "mi",
              "mk",
              "ml",
              "mn",
              "mr",
              "ms",
              "mt",
              "my",
              "na",
              "nb",
              "nd",
              "ne",
              "ng",
              "nl",
              "nn",
              "no",
              "nr",
              "nv",
              "ny",
              "oc",
              "oj",
              "om",
              "or",
              "os",
              "pa",
              "pi",
              "pl",
              "ps",
              "pt",
              "qu",
              "rm",
              "rn",
              "ro",
              "ru",
              "rw",
              "sa",
              "sc",
              "sd",
              "se",
              "sg",
              "si",
              "sk",
              "sl",
              "sm",
              "sn",
              "so",
              "sq",
              "sr",
              "ss",
              "st",
              "su",
              "sv",
              "sw",
              "ta",
              "te",
              "tg",
              "th",
              "ti",
              "tk",
              "tl",
              "tn",
              "to",
              "tr",
              "ts",
              "tt",
              "tw",
              "ty",
              "ug",
              "uk",
              "ur",
              "uz",
              "ve",
              "vi",
              "vo",
              "wa",
              "wo",
              "xh",
              "yi",
              "yue",
              "yo",
              "za",
              "zh",
              "zu"
            ]
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackTranscriberPlan"
              }
            ]
          }
        },
        "required": [
          "provider"
        ]
      },
      "GladiaTranscriber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the transcription provider that will be used.",
            "enum": [
              "gladia"
            ]
          },
          "model": {
            "description": "This is the Gladia model that will be used. Default is 'fast'",
            "oneOf": [
              {
                "enum": [
                  "fast",
                  "accurate"
                ]
              }
            ]
          },
          "languageBehaviour": {
            "description": "Defines how the transcription model detects the audio language. Default value is 'automatic single language'.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "manual",
                  "automatic single language",
                  "automatic multiple languages"
                ]
              }
            ]
          },
          "language": {
            "type": "string",
            "description": "Defines the language to use for the transcription. Required when languageBehaviour is 'manual'.",
            "enum": [
              "af",
              "sq",
              "am",
              "ar",
              "hy",
              "as",
              "az",
              "ba",
              "eu",
              "be",
              "bn",
              "bs",
              "br",
              "bg",
              "ca",
              "zh",
              "hr",
              "cs",
              "da",
              "nl",
              "en",
              "et",
              "fo",
              "fi",
              "fr",
              "gl",
              "ka",
              "de",
              "el",
              "gu",
              "ht",
              "ha",
              "haw",
              "he",
              "hi",
              "hu",
              "is",
              "id",
              "it",
              "ja",
              "jv",
              "kn",
              "kk",
              "km",
              "ko",
              "lo",
              "la",
              "lv",
              "ln",
              "lt",
              "lb",
              "mk",
              "mg",
              "ms",
              "ml",
              "mt",
              "mi",
              "mr",
              "mn",
              "my",
              "ne",
              "no",
              "nn",
              "oc",
              "ps",
              "fa",
              "pl",
              "pt",
              "pa",
              "ro",
              "ru",
              "sa",
              "sr",
              "sn",
              "sd",
              "si",
              "sk",
              "sl",
              "so",
              "es",
              "su",
              "sw",
              "sv",
              "tl",
              "tg",
              "ta",
              "tt",
              "te",
              "th",
              "bo",
              "tr",
              "tk",
              "uk",
              "ur",
              "uz",
              "vi",
              "cy",
              "yi",
              "yo"
            ]
          },
          "transcriptionHint": {
            "type": "string",
            "description": "Provides a custom vocabulary to the model to improve accuracy of transcribing context specific words, technical terms, names, etc. If empty, this argument is ignored.\n Warning : Please be aware that the transcription_hint field has a character limit of 600. If you provide a transcription_hint longer than 600 characters, it will be automatically truncated to meet this limit.",
            "maxLength": 600,
            "example": "custom vocabulary"
          },
          "prosody": {
            "type": "boolean",
            "description": "If prosody is true, you will get a transcription that can contain prosodies i.e. (laugh) (giggles) (malefic laugh) (toss) (music) Default value is false.",
            "example": false
          },
          "audioEnhancer": {
            "type": "boolean",
            "description": "If true, audio will be pre-processed to improve accuracy but latency will increase. Default value is false.",
            "example": false
          },
          "confidenceThreshold": {
            "type": "number",
            "description": "Transcripts below this confidence threshold will be discarded.\n\n@default 0.4",
            "minimum": 0,
            "maximum": 1,
            "example": 0.4
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackTranscriberPlan"
              }
            ]
          }
        },
        "required": [
          "provider"
        ]
      },
      "SpeechmaticsTranscriber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the transcription provider that will be used.",
            "enum": [
              "speechmatics"
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used for the transcription.",
            "enum": [
              "default"
            ]
          },
          "language": {
            "type": "string",
            "enum": [
              "auto",
              "ar",
              "ba",
              "eu",
              "be",
              "bn",
              "bg",
              "yue",
              "ca",
              "hr",
              "cs",
              "da",
              "nl",
              "en",
              "eo",
              "et",
              "fi",
              "fr",
              "gl",
              "de",
              "el",
              "he",
              "hi",
              "hu",
              "id",
              "ia",
              "ga",
              "it",
              "ja",
              "ko",
              "lv",
              "lt",
              "ms",
              "mt",
              "cmn",
              "mr",
              "mn",
              "no",
              "fa",
              "pl",
              "pt",
              "ro",
              "ru",
              "sk",
              "sl",
              "es",
              "sw",
              "sv",
              "ta",
              "th",
              "tr",
              "uk",
              "ur",
              "ug",
              "vi",
              "cy"
            ]
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackTranscriberPlan"
              }
            ]
          }
        },
        "required": [
          "provider"
        ]
      },
      "TalkscriberTranscriber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the transcription provider that will be used.",
            "enum": [
              "talkscriber"
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used for the transcription.",
            "enum": [
              "whisper"
            ]
          },
          "language": {
            "type": "string",
            "description": "This is the language that will be set for the transcription. The list of languages Whisper supports can be found here: https://github.com/openai/whisper/blob/main/whisper/tokenizer.py",
            "enum": [
              "en",
              "zh",
              "de",
              "es",
              "ru",
              "ko",
              "fr",
              "ja",
              "pt",
              "tr",
              "pl",
              "ca",
              "nl",
              "ar",
              "sv",
              "it",
              "id",
              "hi",
              "fi",
              "vi",
              "he",
              "uk",
              "el",
              "ms",
              "cs",
              "ro",
              "da",
              "hu",
              "ta",
              "no",
              "th",
              "ur",
              "hr",
              "bg",
              "lt",
              "la",
              "mi",
              "ml",
              "cy",
              "sk",
              "te",
              "fa",
              "lv",
              "bn",
              "sr",
              "az",
              "sl",
              "kn",
              "et",
              "mk",
              "br",
              "eu",
              "is",
              "hy",
              "ne",
              "mn",
              "bs",
              "kk",
              "sq",
              "sw",
              "gl",
              "mr",
              "pa",
              "si",
              "km",
              "sn",
              "yo",
              "so",
              "af",
              "oc",
              "ka",
              "be",
              "tg",
              "sd",
              "gu",
              "am",
              "yi",
              "lo",
              "uz",
              "fo",
              "ht",
              "ps",
              "tk",
              "nn",
              "mt",
              "sa",
              "lb",
              "my",
              "bo",
              "tl",
              "mg",
              "as",
              "tt",
              "haw",
              "ln",
              "ha",
              "ba",
              "jw",
              "su",
              "yue"
            ]
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackTranscriberPlan"
              }
            ]
          }
        },
        "required": [
          "provider"
        ]
      },
      "GoogleTranscriber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the transcription provider that will be used.",
            "enum": [
              "google"
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used for the transcription.",
            "enum": [
              "gemini-2.5-pro-preview-05-06",
              "gemini-2.5-flash-preview-05-20",
              "gemini-2.5-flash-preview-04-17",
              "gemini-2.0-flash-thinking-exp",
              "gemini-2.0-pro-exp-02-05",
              "gemini-2.0-flash",
              "gemini-2.0-flash-lite",
              "gemini-2.0-flash-lite-preview-02-05",
              "gemini-2.0-flash-exp",
              "gemini-2.0-flash-realtime-exp",
              "gemini-1.5-flash",
              "gemini-1.5-flash-002",
              "gemini-1.5-pro",
              "gemini-1.5-pro-002",
              "gemini-1.0-pro"
            ]
          },
          "language": {
            "type": "string",
            "description": "This is the language that will be set for the transcription.",
            "enum": [
              "Multilingual",
              "Arabic",
              "Bengali",
              "Bulgarian",
              "Chinese",
              "Croatian",
              "Czech",
              "Danish",
              "Dutch",
              "English",
              "Estonian",
              "Finnish",
              "French",
              "German",
              "Greek",
              "Hebrew",
              "Hindi",
              "Hungarian",
              "Indonesian",
              "Italian",
              "Japanese",
              "Korean",
              "Latvian",
              "Lithuanian",
              "Norwegian",
              "Polish",
              "Portuguese",
              "Romanian",
              "Russian",
              "Serbian",
              "Slovak",
              "Slovenian",
              "Spanish",
              "Swahili",
              "Swedish",
              "Thai",
              "Turkish",
              "Ukrainian",
              "Vietnamese"
            ]
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackTranscriberPlan"
              }
            ]
          }
        },
        "required": [
          "provider"
        ]
      },
      "OpenAITranscriber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the transcription provider that will be used.",
            "enum": [
              "openai"
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used for the transcription.",
            "enum": [
              "gpt-4o-transcribe",
              "gpt-4o-mini-transcribe"
            ]
          },
          "language": {
            "type": "string",
            "description": "This is the language that will be set for the transcription.",
            "enum": [
              "af",
              "ar",
              "hy",
              "az",
              "be",
              "bs",
              "bg",
              "ca",
              "zh",
              "hr",
              "cs",
              "da",
              "nl",
              "en",
              "et",
              "fi",
              "fr",
              "gl",
              "de",
              "el",
              "he",
              "hi",
              "hu",
              "is",
              "id",
              "it",
              "ja",
              "kn",
              "kk",
              "ko",
              "lv",
              "lt",
              "mk",
              "ms",
              "mr",
              "mi",
              "ne",
              "no",
              "fa",
              "pl",
              "pt",
              "ro",
              "ru",
              "sr",
              "sk",
              "sl",
              "es",
              "sw",
              "sv",
              "tl",
              "ta",
              "th",
              "tr",
              "uk",
              "ur",
              "vi",
              "cy"
            ]
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackTranscriberPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "model"
        ]
      },
      "FallbackAssemblyAITranscriber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the transcription provider that will be used.",
            "enum": [
              "assembly-ai"
            ]
          },
          "language": {
            "type": "string",
            "description": "This is the language that will be set for the transcription.",
            "enum": [
              "en"
            ]
          },
          "confidenceThreshold": {
            "type": "number",
            "description": "Transcripts below this confidence threshold will be discarded.\n\n@default 0.4",
            "minimum": 0,
            "maximum": 1,
            "example": 0.4
          },
          "realtimeUrl": {
            "type": "string",
            "description": "The WebSocket URL that the transcriber connects to."
          },
          "wordBoost": {
            "description": "Add up to 2500 characters of custom vocabulary.",
            "type": "array",
            "items": {
              "type": "string",
              "maxLength": 2500
            }
          },
          "endUtteranceSilenceThreshold": {
            "type": "number",
            "description": "The duration of the end utterance silence threshold in milliseconds."
          },
          "disablePartialTranscripts": {
            "type": "boolean",
            "description": "Disable partial transcripts.\nSet to `true` to not receive partial transcripts. Defaults to `false`."
          }
        },
        "required": [
          "provider"
        ]
      },
      "FallbackAzureSpeechTranscriber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the transcription provider that will be used.",
            "enum": [
              "azure"
            ]
          },
          "language": {
            "type": "string",
            "description": "This is the language that will be set for the transcription. The list of languages Azure supports can be found here: https://learn.microsoft.com/en-us/azure/ai-services/speech-service/language-support?tabs=stt",
            "enum": [
              "af-ZA",
              "am-ET",
              "ar-AE",
              "ar-BH",
              "ar-DZ",
              "ar-EG",
              "ar-IL",
              "ar-IQ",
              "ar-JO",
              "ar-KW",
              "ar-LB",
              "ar-LY",
              "ar-MA",
              "ar-OM",
              "ar-PS",
              "ar-QA",
              "ar-SA",
              "ar-SY",
              "ar-TN",
              "ar-YE",
              "az-AZ",
              "bg-BG",
              "bn-IN",
              "bs-BA",
              "ca-ES",
              "cs-CZ",
              "cy-GB",
              "da-DK",
              "de-AT",
              "de-CH",
              "de-DE",
              "el-GR",
              "en-AU",
              "en-CA",
              "en-GB",
              "en-GH",
              "en-HK",
              "en-IE",
              "en-IN",
              "en-KE",
              "en-NG",
              "en-NZ",
              "en-PH",
              "en-SG",
              "en-TZ",
              "en-US",
              "en-ZA",
              "es-AR",
              "es-BO",
              "es-CL",
              "es-CO",
              "es-CR",
              "es-CU",
              "es-DO",
              "es-EC",
              "es-ES",
              "es-GQ",
              "es-GT",
              "es-HN",
              "es-MX",
              "es-NI",
              "es-PA",
              "es-PE",
              "es-PR",
              "es-PY",
              "es-SV",
              "es-US",
              "es-UY",
              "es-VE",
              "et-EE",
              "eu-ES",
              "fa-IR",
              "fi-FI",
              "fil-PH",
              "fr-BE",
              "fr-CA",
              "fr-CH",
              "fr-FR",
              "ga-IE",
              "gl-ES",
              "gu-IN",
              "he-IL",
              "hi-IN",
              "hr-HR",
              "hu-HU",
              "hy-AM",
              "id-ID",
              "is-IS",
              "it-CH",
              "it-IT",
              "ja-JP",
              "jv-ID",
              "ka-GE",
              "kk-KZ",
              "km-KH",
              "kn-IN",
              "ko-KR",
              "lo-LA",
              "lt-LT",
              "lv-LV",
              "mk-MK",
              "ml-IN",
              "mn-MN",
              "mr-IN",
              "ms-MY",
              "mt-MT",
              "my-MM",
              "nb-NO",
              "ne-NP",
              "nl-BE",
              "nl-NL",
              "pa-IN",
              "pl-PL",
              "ps-AF",
              "pt-BR",
              "pt-PT",
              "ro-RO",
              "ru-RU",
              "si-LK",
              "sk-SK",
              "sl-SI",
              "so-SO",
              "sq-AL",
              "sr-RS",
              "sv-SE",
              "sw-KE",
              "sw-TZ",
              "ta-IN",
              "te-IN",
              "th-TH",
              "tr-TR",
              "uk-UA",
              "ur-IN",
              "uz-UZ",
              "vi-VN",
              "wuu-CN",
              "yue-CN",
              "zh-CN",
              "zh-CN-shandong",
              "zh-CN-sichuan",
              "zh-HK",
              "zh-TW",
              "zu-ZA"
            ]
          }
        },
        "required": [
          "provider"
        ]
      },
      "FallbackCustomTranscriber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the transcription provider that will be used. Use `custom-transcriber` for providers that are not natively supported.",
            "enum": [
              "custom-transcriber"
            ]
          },
          "server": {
            "description": "This is where the transcription request will be sent.\n\nUsage:\n1. Vapi will initiate a websocket connection with `server.url`.\n\n2. Vapi will send an initial text frame with the sample rate. Format:\n```\n    {\n      \"type\": \"start\",\n      \"encoding\": \"linear16\", // 16-bit raw PCM format\n      \"container\": \"raw\",\n      \"sampleRate\": {{sampleRate}},\n      \"channels\": 2 // customer is channel 0, assistant is channel 1\n    }\n```\n\n3. Vapi will send the audio data in 16-bit raw PCM format as binary frames.\n\n4. You can read the messages something like this:\n```\nws.on('message', (data, isBinary) => {\n  if (isBinary) {\n    pcmBuffer = Buffer.concat([pcmBuffer, data]);\n    console.log(`Received PCM data, buffer size: ${pcmBuffer.length}`);\n  } else {\n    console.log('Received message:', JSON.parse(data.toString()));\n  }\n});\n```\n\n5. You will respond with transcriptions as you have them. Format:\n```\n {\n    \"type\": \"transcriber-response\",\n    \"transcription\": \"Hello, world!\",\n    \"channel\": \"customer\" | \"assistant\"\n }\n```",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          }
        },
        "required": [
          "provider",
          "server"
        ]
      },
      "FallbackDeepgramTranscriber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the transcription provider that will be used.",
            "enum": [
              "deepgram"
            ]
          },
          "model": {
            "description": "This is the Deepgram model that will be used. A list of models can be found here: https://developers.deepgram.com/docs/models-languages-overview",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "nova-3",
                  "nova-3-general",
                  "nova-3-medical",
                  "nova-2",
                  "nova-2-general",
                  "nova-2-meeting",
                  "nova-2-phonecall",
                  "nova-2-finance",
                  "nova-2-conversationalai",
                  "nova-2-voicemail",
                  "nova-2-video",
                  "nova-2-medical",
                  "nova-2-drivethru",
                  "nova-2-automotive",
                  "nova",
                  "nova-general",
                  "nova-phonecall",
                  "nova-medical",
                  "enhanced",
                  "enhanced-general",
                  "enhanced-meeting",
                  "enhanced-phonecall",
                  "enhanced-finance",
                  "base",
                  "base-general",
                  "base-meeting",
                  "base-phonecall",
                  "base-finance",
                  "base-conversationalai",
                  "base-voicemail",
                  "base-video",
                  "whisper"
                ]
              },
              {
                "type": "string"
              }
            ]
          },
          "language": {
            "type": "string",
            "description": "This is the language that will be set for the transcription. The list of languages Deepgram supports can be found here: https://developers.deepgram.com/docs/models-languages-overview",
            "enum": [
              "ar",
              "az",
              "ba",
              "bg",
              "br",
              "ca",
              "cs",
              "da",
              "da-DK",
              "de",
              "de-CH",
              "el",
              "en",
              "en-AU",
              "en-GB",
              "en-IN",
              "en-NZ",
              "en-US",
              "es",
              "es-419",
              "es-LATAM",
              "et",
              "eu",
              "fi",
              "fr",
              "fr-CA",
              "ha",
              "haw",
              "he",
              "hi",
              "hi-Latn",
              "hu",
              "id",
              "is",
              "it",
              "ja",
              "jw",
              "kn",
              "ko",
              "ko-KR",
              "ln",
              "lt",
              "lv",
              "mk",
              "ms",
              "multi",
              "nl",
              "nl-BE",
              "no",
              "pl",
              "pt",
              "pt-BR",
              "ro",
              "ru",
              "sk",
              "sl",
              "sn",
              "so",
              "sr",
              "su",
              "sv",
              "sv-SE",
              "ta",
              "taq",
              "th",
              "th-TH",
              "tr",
              "tt",
              "uk",
              "ur",
              "vi",
              "yo",
              "zh",
              "zh-CN",
              "zh-HK",
              "zh-Hans",
              "zh-Hant",
              "zh-TW"
            ]
          },
          "smartFormat": {
            "type": "boolean",
            "description": "This will be use smart format option provided by Deepgram. It's default disabled because it can sometimes format numbers as times but it's getting better.",
            "example": false
          },
          "codeSwitchingEnabled": {
            "type": "boolean",
            "description": "This automatically switches the transcriber's language when the customer's language changes. Defaults to false.\n\nUsage:\n- If your customers switch languages mid-call, you can set this to true.\n\nNote:\n- To detect language changes, Vapi uses a custom trained model. Languages supported (X = limited support):\n  1. Arabic\n  2. Bengali\n  3. Cantonese\n  4. Chinese\n  5. Chinese Simplified (X)\n  6. Chinese Traditional (X)\n  7. English\n  8. Farsi (X)\n  9. French\n  10. German\n  11. Haitian Creole (X)\n  12. Hindi\n  13. Italian\n  14. Japanese\n  15. Korean\n  16. Portuguese\n  17. Russian\n  18. Spanish\n  19. Thai\n  20. Urdu\n  21. Vietnamese\n- To receive `language-change-detected` webhook events, add it to `assistant.serverMessages`.\n\n@default false",
            "example": false
          },
          "mipOptOut": {
            "type": "boolean",
            "description": "If set to true, this will add mip_opt_out=true as a query parameter of all API requests. See https://developers.deepgram.com/docs/the-deepgram-model-improvement-partnership-program#want-to-opt-out\n\nThis will only be used if you are using your own Deepgram API key.\n\n@default false",
            "example": false,
            "default": false
          },
          "numerals": {
            "type": "boolean",
            "description": "If set to true, this will cause deepgram to convert spoken numbers to literal numerals. For example, \"my phone number is nine-seven-two...\" would become \"my phone number is 972...\"\n\n@default false",
            "example": false
          },
          "confidenceThreshold": {
            "type": "number",
            "description": "Transcripts below this confidence threshold will be discarded.\n\n@default 0.4",
            "minimum": 0,
            "maximum": 1,
            "example": 0.4
          },
          "keywords": {
            "description": "These keywords are passed to the transcription model to help it pick up use-case specific words. Anything that may not be a common word, like your company name, should be added here.",
            "type": "array",
            "items": {
              "type": "string",
              "pattern": "/^\\p{L}[\\p{L}\\d]*(?::[+-]?\\d+)?$/u"
            }
          },
          "keyterm": {
            "description": "Keyterm Prompting allows you improve Keyword Recall Rate (KRR) for important keyterms or phrases up to 90%.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "endpointing": {
            "type": "number",
            "description": "This is the timeout after which Deepgram will send transcription on user silence. You can read in-depth documentation here: https://developers.deepgram.com/docs/endpointing.\n\nHere are the most important bits:\n- Defaults to 10. This is recommended for most use cases to optimize for latency.\n- 10 can cause some missing transcriptions since because of the shorter context. This mostly happens for one-word utterances. For those uses cases, it's recommended to try 300. It will add a bit of latency but the quality and reliability of the experience will be better.\n- If neither 10 nor 300 work, contact support@vapi.ai and we'll find another solution.\n\n@default 10",
            "minimum": 10,
            "maximum": 500
          }
        },
        "required": [
          "provider"
        ]
      },
      "FallbackElevenLabsTranscriber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the transcription provider that will be used.",
            "enum": [
              "11labs"
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used for the transcription.",
            "enum": [
              "scribe_v1"
            ]
          },
          "language": {
            "type": "string",
            "enum": [
              "aa",
              "ab",
              "ae",
              "af",
              "ak",
              "am",
              "an",
              "ar",
              "as",
              "av",
              "ay",
              "az",
              "ba",
              "be",
              "bg",
              "bh",
              "bi",
              "bm",
              "bn",
              "bo",
              "br",
              "bs",
              "ca",
              "ce",
              "ch",
              "co",
              "cr",
              "cs",
              "cu",
              "cv",
              "cy",
              "da",
              "de",
              "dv",
              "dz",
              "ee",
              "el",
              "en",
              "eo",
              "es",
              "et",
              "eu",
              "fa",
              "ff",
              "fi",
              "fj",
              "fo",
              "fr",
              "fy",
              "ga",
              "gd",
              "gl",
              "gn",
              "gu",
              "gv",
              "ha",
              "he",
              "hi",
              "ho",
              "hr",
              "ht",
              "hu",
              "hy",
              "hz",
              "ia",
              "id",
              "ie",
              "ig",
              "ii",
              "ik",
              "io",
              "is",
              "it",
              "iu",
              "ja",
              "jv",
              "ka",
              "kg",
              "ki",
              "kj",
              "kk",
              "kl",
              "km",
              "kn",
              "ko",
              "kr",
              "ks",
              "ku",
              "kv",
              "kw",
              "ky",
              "la",
              "lb",
              "lg",
              "li",
              "ln",
              "lo",
              "lt",
              "lu",
              "lv",
              "mg",
              "mh",
              "mi",
              "mk",
              "ml",
              "mn",
              "mr",
              "ms",
              "mt",
              "my",
              "na",
              "nb",
              "nd",
              "ne",
              "ng",
              "nl",
              "nn",
              "no",
              "nr",
              "nv",
              "ny",
              "oc",
              "oj",
              "om",
              "or",
              "os",
              "pa",
              "pi",
              "pl",
              "ps",
              "pt",
              "qu",
              "rm",
              "rn",
              "ro",
              "ru",
              "rw",
              "sa",
              "sc",
              "sd",
              "se",
              "sg",
              "si",
              "sk",
              "sl",
              "sm",
              "sn",
              "so",
              "sq",
              "sr",
              "ss",
              "st",
              "su",
              "sv",
              "sw",
              "ta",
              "te",
              "tg",
              "th",
              "ti",
              "tk",
              "tl",
              "tn",
              "to",
              "tr",
              "ts",
              "tt",
              "tw",
              "ty",
              "ug",
              "uk",
              "ur",
              "uz",
              "ve",
              "vi",
              "vo",
              "wa",
              "wo",
              "xh",
              "yi",
              "yue",
              "yo",
              "za",
              "zh",
              "zu"
            ]
          }
        },
        "required": [
          "provider"
        ]
      },
      "FallbackGladiaTranscriber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the transcription provider that will be used.",
            "enum": [
              "gladia"
            ]
          },
          "model": {
            "description": "This is the Gladia model that will be used. Default is 'fast'",
            "oneOf": [
              {
                "enum": [
                  "fast",
                  "accurate"
                ]
              }
            ]
          },
          "languageBehaviour": {
            "description": "Defines how the transcription model detects the audio language. Default value is 'automatic single language'.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "manual",
                  "automatic single language",
                  "automatic multiple languages"
                ]
              }
            ]
          },
          "language": {
            "type": "string",
            "description": "Defines the language to use for the transcription. Required when languageBehaviour is 'manual'.",
            "enum": [
              "af",
              "sq",
              "am",
              "ar",
              "hy",
              "as",
              "az",
              "ba",
              "eu",
              "be",
              "bn",
              "bs",
              "br",
              "bg",
              "ca",
              "zh",
              "hr",
              "cs",
              "da",
              "nl",
              "en",
              "et",
              "fo",
              "fi",
              "fr",
              "gl",
              "ka",
              "de",
              "el",
              "gu",
              "ht",
              "ha",
              "haw",
              "he",
              "hi",
              "hu",
              "is",
              "id",
              "it",
              "ja",
              "jv",
              "kn",
              "kk",
              "km",
              "ko",
              "lo",
              "la",
              "lv",
              "ln",
              "lt",
              "lb",
              "mk",
              "mg",
              "ms",
              "ml",
              "mt",
              "mi",
              "mr",
              "mn",
              "my",
              "ne",
              "no",
              "nn",
              "oc",
              "ps",
              "fa",
              "pl",
              "pt",
              "pa",
              "ro",
              "ru",
              "sa",
              "sr",
              "sn",
              "sd",
              "si",
              "sk",
              "sl",
              "so",
              "es",
              "su",
              "sw",
              "sv",
              "tl",
              "tg",
              "ta",
              "tt",
              "te",
              "th",
              "bo",
              "tr",
              "tk",
              "uk",
              "ur",
              "uz",
              "vi",
              "cy",
              "yi",
              "yo"
            ]
          },
          "transcriptionHint": {
            "type": "string",
            "description": "Provides a custom vocabulary to the model to improve accuracy of transcribing context specific words, technical terms, names, etc. If empty, this argument is ignored.\n Warning : Please be aware that the transcription_hint field has a character limit of 600. If you provide a transcription_hint longer than 600 characters, it will be automatically truncated to meet this limit.",
            "maxLength": 600,
            "example": "custom vocabulary"
          },
          "prosody": {
            "type": "boolean",
            "description": "If prosody is true, you will get a transcription that can contain prosodies i.e. (laugh) (giggles) (malefic laugh) (toss) (music) Default value is false.",
            "example": false
          },
          "audioEnhancer": {
            "type": "boolean",
            "description": "If true, audio will be pre-processed to improve accuracy but latency will increase. Default value is false.",
            "example": false
          },
          "confidenceThreshold": {
            "type": "number",
            "description": "Transcripts below this confidence threshold will be discarded.\n\n@default 0.4",
            "minimum": 0,
            "maximum": 1,
            "example": 0.4
          }
        },
        "required": [
          "provider"
        ]
      },
      "FallbackSpeechmaticsTranscriber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the transcription provider that will be used.",
            "enum": [
              "speechmatics"
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used for the transcription.",
            "enum": [
              "default"
            ]
          },
          "language": {
            "type": "string",
            "enum": [
              "auto",
              "ar",
              "ba",
              "eu",
              "be",
              "bn",
              "bg",
              "yue",
              "ca",
              "hr",
              "cs",
              "da",
              "nl",
              "en",
              "eo",
              "et",
              "fi",
              "fr",
              "gl",
              "de",
              "el",
              "he",
              "hi",
              "hu",
              "id",
              "ia",
              "ga",
              "it",
              "ja",
              "ko",
              "lv",
              "lt",
              "ms",
              "mt",
              "cmn",
              "mr",
              "mn",
              "no",
              "fa",
              "pl",
              "pt",
              "ro",
              "ru",
              "sk",
              "sl",
              "es",
              "sw",
              "sv",
              "ta",
              "th",
              "tr",
              "uk",
              "ur",
              "ug",
              "vi",
              "cy"
            ]
          }
        },
        "required": [
          "provider"
        ]
      },
      "FallbackTalkscriberTranscriber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the transcription provider that will be used.",
            "enum": [
              "talkscriber"
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used for the transcription.",
            "enum": [
              "whisper"
            ]
          },
          "language": {
            "type": "string",
            "description": "This is the language that will be set for the transcription. The list of languages Whisper supports can be found here: https://github.com/openai/whisper/blob/main/whisper/tokenizer.py",
            "enum": [
              "en",
              "zh",
              "de",
              "es",
              "ru",
              "ko",
              "fr",
              "ja",
              "pt",
              "tr",
              "pl",
              "ca",
              "nl",
              "ar",
              "sv",
              "it",
              "id",
              "hi",
              "fi",
              "vi",
              "he",
              "uk",
              "el",
              "ms",
              "cs",
              "ro",
              "da",
              "hu",
              "ta",
              "no",
              "th",
              "ur",
              "hr",
              "bg",
              "lt",
              "la",
              "mi",
              "ml",
              "cy",
              "sk",
              "te",
              "fa",
              "lv",
              "bn",
              "sr",
              "az",
              "sl",
              "kn",
              "et",
              "mk",
              "br",
              "eu",
              "is",
              "hy",
              "ne",
              "mn",
              "bs",
              "kk",
              "sq",
              "sw",
              "gl",
              "mr",
              "pa",
              "si",
              "km",
              "sn",
              "yo",
              "so",
              "af",
              "oc",
              "ka",
              "be",
              "tg",
              "sd",
              "gu",
              "am",
              "yi",
              "lo",
              "uz",
              "fo",
              "ht",
              "ps",
              "tk",
              "nn",
              "mt",
              "sa",
              "lb",
              "my",
              "bo",
              "tl",
              "mg",
              "as",
              "tt",
              "haw",
              "ln",
              "ha",
              "ba",
              "jw",
              "su",
              "yue"
            ]
          }
        },
        "required": [
          "provider"
        ]
      },
      "FallbackGoogleTranscriber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the transcription provider that will be used.",
            "enum": [
              "google"
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used for the transcription.",
            "enum": [
              "gemini-2.5-pro-preview-05-06",
              "gemini-2.5-flash-preview-05-20",
              "gemini-2.5-flash-preview-04-17",
              "gemini-2.0-flash-thinking-exp",
              "gemini-2.0-pro-exp-02-05",
              "gemini-2.0-flash",
              "gemini-2.0-flash-lite",
              "gemini-2.0-flash-lite-preview-02-05",
              "gemini-2.0-flash-exp",
              "gemini-2.0-flash-realtime-exp",
              "gemini-1.5-flash",
              "gemini-1.5-flash-002",
              "gemini-1.5-pro",
              "gemini-1.5-pro-002",
              "gemini-1.0-pro"
            ]
          },
          "language": {
            "type": "string",
            "description": "This is the language that will be set for the transcription.",
            "enum": [
              "Multilingual",
              "Arabic",
              "Bengali",
              "Bulgarian",
              "Chinese",
              "Croatian",
              "Czech",
              "Danish",
              "Dutch",
              "English",
              "Estonian",
              "Finnish",
              "French",
              "German",
              "Greek",
              "Hebrew",
              "Hindi",
              "Hungarian",
              "Indonesian",
              "Italian",
              "Japanese",
              "Korean",
              "Latvian",
              "Lithuanian",
              "Norwegian",
              "Polish",
              "Portuguese",
              "Romanian",
              "Russian",
              "Serbian",
              "Slovak",
              "Slovenian",
              "Spanish",
              "Swahili",
              "Swedish",
              "Thai",
              "Turkish",
              "Ukrainian",
              "Vietnamese"
            ]
          }
        },
        "required": [
          "provider"
        ]
      },
      "FallbackOpenAITranscriber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the transcription provider that will be used.",
            "enum": [
              "openai"
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used for the transcription.",
            "enum": [
              "gpt-4o-transcribe",
              "gpt-4o-mini-transcribe"
            ]
          },
          "language": {
            "type": "string",
            "description": "This is the language that will be set for the transcription.",
            "enum": [
              "af",
              "ar",
              "hy",
              "az",
              "be",
              "bs",
              "bg",
              "ca",
              "zh",
              "hr",
              "cs",
              "da",
              "nl",
              "en",
              "et",
              "fi",
              "fr",
              "gl",
              "de",
              "el",
              "he",
              "hi",
              "hu",
              "is",
              "id",
              "it",
              "ja",
              "kn",
              "kk",
              "ko",
              "lv",
              "lt",
              "mk",
              "ms",
              "mr",
              "mi",
              "ne",
              "no",
              "fa",
              "pl",
              "pt",
              "ro",
              "ru",
              "sr",
              "sk",
              "sl",
              "es",
              "sw",
              "sv",
              "tl",
              "ta",
              "th",
              "tr",
              "uk",
              "ur",
              "vi",
              "cy"
            ]
          }
        },
        "required": [
          "provider",
          "model"
        ]
      },
      "LangfuseObservabilityPlan": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "langfuse"
            ]
          },
          "tags": {
            "description": "This is an array of tags to be added to the Langfuse trace. Tags allow you to categorize and filter traces. https://langfuse.com/docs/tracing-features/tags",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "metadata": {
            "type": "object",
            "description": "This is a JSON object that will be added to the Langfuse trace. Traces can be enriched with metadata to better understand your users, application, and experiments. https://langfuse.com/docs/tracing-features/metadata\nBy default it includes the call metadata, assistant metadata, and assistant overrides."
          }
        },
        "required": [
          "provider",
          "tags"
        ]
      },
      "TextContent": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "text"
            ]
          },
          "text": {
            "type": "string"
          },
          "language": {
            "type": "string",
            "enum": [
              "aa",
              "ab",
              "ae",
              "af",
              "ak",
              "am",
              "an",
              "ar",
              "as",
              "av",
              "ay",
              "az",
              "ba",
              "be",
              "bg",
              "bh",
              "bi",
              "bm",
              "bn",
              "bo",
              "br",
              "bs",
              "ca",
              "ce",
              "ch",
              "co",
              "cr",
              "cs",
              "cu",
              "cv",
              "cy",
              "da",
              "de",
              "dv",
              "dz",
              "ee",
              "el",
              "en",
              "eo",
              "es",
              "et",
              "eu",
              "fa",
              "ff",
              "fi",
              "fj",
              "fo",
              "fr",
              "fy",
              "ga",
              "gd",
              "gl",
              "gn",
              "gu",
              "gv",
              "ha",
              "he",
              "hi",
              "ho",
              "hr",
              "ht",
              "hu",
              "hy",
              "hz",
              "ia",
              "id",
              "ie",
              "ig",
              "ii",
              "ik",
              "io",
              "is",
              "it",
              "iu",
              "ja",
              "jv",
              "ka",
              "kg",
              "ki",
              "kj",
              "kk",
              "kl",
              "km",
              "kn",
              "ko",
              "kr",
              "ks",
              "ku",
              "kv",
              "kw",
              "ky",
              "la",
              "lb",
              "lg",
              "li",
              "ln",
              "lo",
              "lt",
              "lu",
              "lv",
              "mg",
              "mh",
              "mi",
              "mk",
              "ml",
              "mn",
              "mr",
              "ms",
              "mt",
              "my",
              "na",
              "nb",
              "nd",
              "ne",
              "ng",
              "nl",
              "nn",
              "no",
              "nr",
              "nv",
              "ny",
              "oc",
              "oj",
              "om",
              "or",
              "os",
              "pa",
              "pi",
              "pl",
              "ps",
              "pt",
              "qu",
              "rm",
              "rn",
              "ro",
              "ru",
              "rw",
              "sa",
              "sc",
              "sd",
              "se",
              "sg",
              "si",
              "sk",
              "sl",
              "sm",
              "sn",
              "so",
              "sq",
              "sr",
              "ss",
              "st",
              "su",
              "sv",
              "sw",
              "ta",
              "te",
              "tg",
              "th",
              "ti",
              "tk",
              "tl",
              "tn",
              "to",
              "tr",
              "ts",
              "tt",
              "tw",
              "ty",
              "ug",
              "uk",
              "ur",
              "uz",
              "ve",
              "vi",
              "vo",
              "wa",
              "wo",
              "xh",
              "yi",
              "yue",
              "yo",
              "za",
              "zh",
              "zu"
            ]
          }
        },
        "required": [
          "type",
          "text",
          "language"
        ]
      },
      "Condition": {
        "type": "object",
        "properties": {
          "operator": {
            "type": "string",
            "description": "This is the operator you want to use to compare the parameter and value.",
            "enum": [
              "eq",
              "neq",
              "gt",
              "gte",
              "lt",
              "lte"
            ]
          },
          "param": {
            "type": "string",
            "description": "This is the name of the parameter that you want to check.",
            "maxLength": 1000
          },
          "value": {
            "type": "string",
            "description": "This is the value you want to compare against the parameter.",
            "maxLength": 1000
          }
        },
        "required": [
          "operator",
          "param",
          "value"
        ]
      },
      "ToolMessageStart": {
        "type": "object",
        "properties": {
          "contents": {
            "type": "array",
            "description": "This is an alternative to the `content` property. It allows to specify variants of the same content, one per language.\n\nUsage:\n- If your assistants are multilingual, you can provide content for each language.\n- If you don't provide content for a language, the first item in the array will be automatically translated to the active language at that moment.\n\nThis will override the `content` property.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TextContent",
                  "title": "Text"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "request-start"
            ],
            "description": "This message is triggered when the tool call starts.\n\nThis message is never triggered for async tools.\n\nIf this message is not provided, one of the default filler messages \"Hold on a sec\", \"One moment\", \"Just a sec\", \"Give me a moment\" or \"This'll just take a sec\" will be used."
          },
          "blocking": {
            "type": "boolean",
            "description": "This is an optional boolean that if true, the tool call will only trigger after the message is spoken. Default is false.\n\n@default false",
            "example": false,
            "default": false
          },
          "content": {
            "type": "string",
            "description": "This is the content that the assistant says when this message is triggered.",
            "maxLength": 1000
          },
          "conditions": {
            "description": "This is an optional array of conditions that the tool call arguments must meet in order for this message to be triggered.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Condition"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "ToolMessageComplete": {
        "type": "object",
        "properties": {
          "contents": {
            "type": "array",
            "description": "This is an alternative to the `content` property. It allows to specify variants of the same content, one per language.\n\nUsage:\n- If your assistants are multilingual, you can provide content for each language.\n- If you don't provide content for a language, the first item in the array will be automatically translated to the active language at that moment.\n\nThis will override the `content` property.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TextContent",
                  "title": "Text"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "description": "This message is triggered when the tool call is complete.\n\nThis message is triggered immediately without waiting for your server to respond for async tool calls.\n\nIf this message is not provided, the model will be requested to respond.\n\nIf this message is provided, only this message will be spoken and the model will not be requested to come up with a response. It's an exclusive OR.",
            "enum": [
              "request-complete"
            ]
          },
          "role": {
            "type": "string",
            "description": "This is optional and defaults to \"assistant\".\n\nWhen role=assistant, `content` is said out loud.\n\nWhen role=system, `content` is passed to the model in a system message. Example:\n    system: default one\n    assistant:\n    user:\n    assistant:\n    user:\n    assistant:\n    user:\n    assistant: tool called\n    tool: your server response\n    <--- system prompt as hint\n    ---> model generates response which is spoken\nThis is useful when you want to provide a hint to the model about what to say next.",
            "enum": [
              "assistant",
              "system"
            ]
          },
          "endCallAfterSpokenEnabled": {
            "type": "boolean",
            "description": "This is an optional boolean that if true, the call will end after the message is spoken. Default is false.\n\nThis is ignored if `role` is set to `system`.\n\n@default false",
            "example": false
          },
          "content": {
            "type": "string",
            "description": "This is the content that the assistant says when this message is triggered.",
            "maxLength": 1000
          },
          "conditions": {
            "description": "This is an optional array of conditions that the tool call arguments must meet in order for this message to be triggered.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Condition"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "ToolMessageFailed": {
        "type": "object",
        "properties": {
          "contents": {
            "type": "array",
            "description": "This is an alternative to the `content` property. It allows to specify variants of the same content, one per language.\n\nUsage:\n- If your assistants are multilingual, you can provide content for each language.\n- If you don't provide content for a language, the first item in the array will be automatically translated to the active language at that moment.\n\nThis will override the `content` property.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TextContent",
                  "title": "Text"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "description": "This message is triggered when the tool call fails.\n\nThis message is never triggered for async tool calls.\n\nIf this message is not provided, the model will be requested to respond.\n\nIf this message is provided, only this message will be spoken and the model will not be requested to come up with a response. It's an exclusive OR.",
            "enum": [
              "request-failed"
            ]
          },
          "endCallAfterSpokenEnabled": {
            "type": "boolean",
            "description": "This is an optional boolean that if true, the call will end after the message is spoken. Default is false.\n\n@default false",
            "example": false
          },
          "content": {
            "type": "string",
            "description": "This is the content that the assistant says when this message is triggered.",
            "maxLength": 1000
          },
          "conditions": {
            "description": "This is an optional array of conditions that the tool call arguments must meet in order for this message to be triggered.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Condition"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "ToolMessageDelayed": {
        "type": "object",
        "properties": {
          "contents": {
            "type": "array",
            "description": "This is an alternative to the `content` property. It allows to specify variants of the same content, one per language.\n\nUsage:\n- If your assistants are multilingual, you can provide content for each language.\n- If you don't provide content for a language, the first item in the array will be automatically translated to the active language at that moment.\n\nThis will override the `content` property.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TextContent",
                  "title": "Text"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "description": "This message is triggered when the tool call is delayed.\n\nThere are the two things that can trigger this message:\n1. The user talks with the assistant while your server is processing the request. Default is \"Sorry, a few more seconds.\"\n2. The server doesn't respond within `timingMilliseconds`.\n\nThis message is never triggered for async tool calls.",
            "enum": [
              "request-response-delayed"
            ]
          },
          "timingMilliseconds": {
            "type": "number",
            "minimum": 100,
            "maximum": 120000,
            "example": 1000,
            "description": "The number of milliseconds to wait for the server response before saying this message."
          },
          "content": {
            "type": "string",
            "description": "This is the content that the assistant says when this message is triggered.",
            "maxLength": 1000
          },
          "conditions": {
            "description": "This is an optional array of conditions that the tool call arguments must meet in order for this message to be triggered.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Condition"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "JsonSchema": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of output you'd like.\n\n`string`, `number`, `integer`, `boolean` are the primitive types and should be obvious.\n\n`array` and `object` are more interesting and quite powerful. They allow you to define nested structures.\n\nFor `array`, you can define the schema of the items in the array using the `items` property.\n\nFor `object`, you can define the properties of the object using the `properties` property.",
            "enum": [
              "string",
              "number",
              "integer",
              "boolean",
              "array",
              "object"
            ]
          },
          "items": {
            "type": "object",
            "description": "This is required if the type is \"array\". This is the schema of the items in the array.\n\nThis is of type JsonSchema. However, Swagger doesn't support circular references."
          },
          "properties": {
            "type": "object",
            "description": "This is required if the type is \"object\". This specifies the properties of the object.\n\nThis is a map of string to JsonSchema. However, Swagger doesn't support circular references."
          },
          "description": {
            "type": "string",
            "description": "This is the description to help the model understand what it needs to output."
          },
          "required": {
            "description": "This is a list of properties that are required.\n\nThis only makes sense if the type is \"object\".",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "value": {
            "type": "string",
            "description": "This the value that will be used in filling the property."
          },
          "target": {
            "type": "string",
            "description": "This the target variable that will be filled with the value of this property."
          },
          "enum": {
            "description": "This array specifies the allowed values that can be used to restrict the output of the model.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "OpenAIFunctionParameters": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This must be set to 'object'. It instructs the model to return a JSON object containing the function call properties.",
            "enum": [
              "object"
            ]
          },
          "properties": {
            "type": "object",
            "description": "This provides a description of the properties required by the function.\nJSON Schema can be used to specify expectations for each property.\nRefer to [this doc](https://ajv.js.org/json-schema.html#json-data-type) for a comprehensive guide on JSON Schema.",
            "additionalProperties": {
              "$ref": "#/components/schemas/JsonSchema"
            }
          },
          "required": {
            "description": "This specifies the properties that are required by the function.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type",
          "properties"
        ]
      },
      "OpenAIFunction": {
        "type": "object",
        "properties": {
          "strict": {
            "type": "boolean",
            "description": "This is a boolean that controls whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the parameters field. Only a subset of JSON Schema is supported when strict is true. Learn more about Structured Outputs in the [OpenAI guide](https://openai.com/index/introducing-structured-outputs-in-the-api/).\n\n@default false",
            "default": false
          },
          "name": {
            "type": "string",
            "description": "This is the the name of the function to be called.\n\nMust be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.",
            "maxLength": 64,
            "pattern": "/^[a-zA-Z0-9_-]{1,64}$/"
          },
          "description": {
            "type": "string",
            "description": "This is the description of what the function does, used by the AI to choose when and how to call the function.",
            "maxLength": 1000
          },
          "parameters": {
            "description": "These are the parameters the functions accepts, described as a JSON Schema object.\n\nSee the [OpenAI guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema) for documentation about the format.\n\nOmitting parameters defines a function with an empty parameter list.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunctionParameters"
              }
            ]
          }
        },
        "required": [
          "name"
        ]
      },
      "CreateDtmfToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "dtmf"
            ],
            "description": "The type of tool. \"dtmf\" for DTMF tool."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "CreateEndCallToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "endCall"
            ],
            "description": "The type of tool. \"endCall\" for End Call tool."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "CreateVoicemailToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "deprecated": true,
            "enum": [
              "voicemail"
            ],
            "description": "The type of tool. \"voicemail\". This uses the model itself to determine if a voicemil was reached. Can be used alternatively/alongside with TwilioVoicemailDetection"
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "CreateFunctionToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "function"
            ],
            "description": "The type of tool. \"function\" for Function tool."
          },
          "async": {
            "type": "boolean",
            "example": false,
            "description": "This determines if the tool is async.\n\n  If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.\n\n  If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.\n\n  Defaults to synchronous (`false`)."
          },
          "server": {
            "description": "\n  This is the server where a `tool-calls` webhook will be sent.\n\n  Notes:\n  - Webhook is sent to this server when a tool call is made.\n  - Webhook contains the call, assistant, and phone number objects.\n  - Webhook contains the variables set on the assistant.\n  - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.\n  - Webhook expects a response with tool call result.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "GhlToolMetadata": {
        "type": "object",
        "properties": {
          "workflowId": {
            "type": "string"
          },
          "locationId": {
            "type": "string"
          }
        }
      },
      "CreateGhlToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "ghl"
            ],
            "description": "The type of tool. \"ghl\" for GHL tool."
          },
          "metadata": {
            "$ref": "#/components/schemas/GhlToolMetadata"
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "metadata"
        ]
      },
      "MakeToolMetadata": {
        "type": "object",
        "properties": {
          "scenarioId": {
            "type": "number"
          },
          "triggerHookId": {
            "type": "number"
          }
        }
      },
      "CreateMakeToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "make"
            ],
            "description": "The type of tool. \"make\" for Make tool."
          },
          "metadata": {
            "$ref": "#/components/schemas/MakeToolMetadata"
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "metadata"
        ]
      },
      "CustomMessage": {
        "type": "object",
        "properties": {
          "contents": {
            "type": "array",
            "description": "This is an alternative to the `content` property. It allows to specify variants of the same content, one per language.\n\nUsage:\n- If your assistants are multilingual, you can provide content for each language.\n- If you don't provide content for a language, the first item in the array will be automatically translated to the active language at that moment.\n\nThis will override the `content` property.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TextContent",
                  "title": "Text"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "description": "This is a custom message.",
            "enum": [
              "custom-message"
            ]
          },
          "content": {
            "type": "string",
            "description": "This is the content that the assistant will say when this message is triggered.",
            "maxLength": 1000
          }
        },
        "required": [
          "type"
        ]
      },
      "TransferDestinationAssistant": {
        "type": "object",
        "properties": {
          "message": {
            "description": "This is spoken to the customer before connecting them to the destination.\n\nUsage:\n- If this is not provided and transfer tool messages is not provided, default is \"Transferring the call now\".\n- If set to \"\", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.\n\nThis accepts a string or a ToolMessageStart class. Latter is useful if you want to specify multiple messages for different languages through the `contents` field.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "$ref": "#/components/schemas/CustomMessage"
              }
            ]
          },
          "type": {
            "type": "string",
            "enum": [
              "assistant"
            ]
          },
          "transferMode": {
            "type": "string",
            "description": "This is the mode to use for the transfer. Defaults to `rolling-history`.\n\n- `rolling-history`: This is the default mode. It keeps the entire conversation history and appends the new assistant's system message on transfer.\n\n  Example:\n\n  Pre-transfer:\n    system: assistant1 system message\n    assistant: assistant1 first message\n    user: hey, good morning\n    assistant: how can i help?\n    user: i need help with my account\n    assistant: (destination.message)\n\n  Post-transfer:\n    system: assistant1 system message\n    assistant: assistant1 first message\n    user: hey, good morning\n    assistant: how can i help?\n    user: i need help with my account\n    assistant: (destination.message)\n    system: assistant2 system message\n    assistant: assistant2 first message (or model generated if firstMessageMode is set to `assistant-speaks-first-with-model-generated-message`)\n\n- `swap-system-message-in-history`: This replaces the original system message with the new assistant's system message on transfer.\n\n  Example:\n\n  Pre-transfer:\n    system: assistant1 system message\n    assistant: assistant1 first message\n    user: hey, good morning\n    assistant: how can i help?\n    user: i need help with my account\n    assistant: (destination.message)\n\n  Post-transfer:\n    system: assistant2 system message\n    assistant: assistant1 first message\n    user: hey, good morning\n    assistant: how can i help?\n    user: i need help with my account\n    assistant: (destination.message)\n    assistant: assistant2 first message (or model generated if firstMessageMode is set to `assistant-speaks-first-with-model-generated-message`)\n\n- `delete-history`: This deletes the entire conversation history on transfer.\n\n  Example:\n\n  Pre-transfer:\n    system: assistant1 system message\n    assistant: assistant1 first message\n    user: hey, good morning\n    assistant: how can i help?\n    user: i need help with my account\n    assistant: (destination.message)\n\n  Post-transfer:\n    system: assistant2 system message\n    assistant: assistant2 first message\n    user: Yes, please\n    assistant: how can i help?\n    user: i need help with my account\n\n- `swap-system-message-in-history-and-remove-transfer-tool-messages`: This replaces the original system message with the new assistant's system message on transfer and removes transfer tool messages from conversation history sent to the LLM.\n\n  Example:\n\n  Pre-transfer:\n    system: assistant1 system message\n    assistant: assistant1 first message\n    user: hey, good morning\n    assistant: how can i help?\n    user: i need help with my account\n    transfer-tool\n    transfer-tool-result\n    assistant: (destination.message)\n\n  Post-transfer:\n    system: assistant2 system message\n    assistant: assistant1 first message\n    user: hey, good morning\n    assistant: how can i help?\n    user: i need help with my account\n    assistant: (destination.message)\n    assistant: assistant2 first message (or model generated if firstMessageMode is set to `assistant-speaks-first-with-model-generated-message`)\n\n@default 'rolling-history'",
            "enum": [
              "rolling-history",
              "swap-system-message-in-history",
              "swap-system-message-in-history-and-remove-transfer-tool-messages",
              "delete-history"
            ]
          },
          "assistantName": {
            "type": "string",
            "description": "This is the assistant to transfer the call to."
          },
          "description": {
            "type": "string",
            "description": "This is the description of the destination, used by the AI to choose when and how to transfer the call."
          }
        },
        "required": [
          "type",
          "assistantName"
        ]
      },
      "TransferFallbackPlan": {
        "type": "object",
        "properties": {
          "message": {
            "description": "This is the message the assistant will deliver to the customer if the transfer fails.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "$ref": "#/components/schemas/CustomMessage"
              }
            ]
          },
          "endCallEnabled": {
            "type": "boolean",
            "description": "This controls what happens after delivering the failure message to the customer.\n- true: End the call after delivering the failure message (default)\n- false: Keep the assistant on the call to continue handling the customer's request\n\n@default true",
            "default": true
          }
        },
        "required": [
          "message"
        ]
      },
      "SummaryPlan": {
        "type": "object",
        "properties": {
          "messages": {
            "description": "These are the messages used to generate the summary.\n\n@default: ```\n[\n  {\n    \"role\": \"system\",\n    \"content\": \"You are an expert note-taker. You will be given a transcript of a call. Summarize the call in 2-3 sentences. DO NOT return anything except the summary.\"\n  },\n  {\n    \"role\": \"user\",\n    \"content\": \"Here is the transcript:\\n\\n{{transcript}}\\n\\n. Here is the ended reason of the call:\\n\\n{{endedReason}}\\n\\n\"\n  }\n]```\n\nYou can customize by providing any messages you want.\n\nHere are the template variables available:\n- {{transcript}}: The transcript of the call from `call.artifact.transcript`- {{systemPrompt}}: The system prompt of the call from `assistant.model.messages[type=system].content`- {{endedReason}}: The ended reason of the call from `call.endedReason`",
            "type": "array",
            "items": {
              "type": "object"
            }
          },
          "enabled": {
            "type": "boolean",
            "description": "This determines whether a summary is generated and stored in `call.analysis.summary`. Defaults to true.\n\nUsage:\n- If you want to disable the summary, set this to false.\n\n@default true"
          },
          "timeoutSeconds": {
            "type": "number",
            "description": "This is how long the request is tried before giving up. When request times out, `call.analysis.summary` will be empty.\n\nUsage:\n- To guarantee the summary is generated, set this value high. Note, this will delay the end of call report in cases where model is slow to respond.\n\n@default 5 seconds",
            "minimum": 1,
            "maximum": 60
          }
        }
      },
      "TransferPlan": {
        "type": "object",
        "properties": {
          "mode": {
            "type": "string",
            "description": "This configures how transfer is executed and the experience of the destination party receiving the call.\n\nUsage:\n- `blind-transfer`: The assistant forwards the call to the destination without any message or summary.\n- `blind-transfer-add-summary-to-sip-header`: The assistant forwards the call to the destination and adds a SIP header X-Transfer-Summary to the call to include the summary.\n- `warm-transfer-say-message`: The assistant dials the destination, delivers the `message` to the destination party, connects the customer, and leaves the call.\n- `warm-transfer-say-summary`: The assistant dials the destination, provides a summary of the call to the destination party, connects the customer, and leaves the call.\n- `warm-transfer-wait-for-operator-to-speak-first-and-then-say-message`: The assistant dials the destination, waits for the operator to speak, delivers the `message` to the destination party, and then connects the customer.\n- `warm-transfer-wait-for-operator-to-speak-first-and-then-say-summary`: The assistant dials the destination, waits for the operator to speak, provides a summary of the call to the destination party, and then connects the customer.\n- `warm-transfer-twiml`: The assistant dials the destination, executes the twiml instructions on the destination call leg, connects the customer, and leaves the call.\n- `warm-transfer-experimental`: The assistant puts the customer on hold, dials the destination, and if the destination answers (and is human), delivers a message or summary before connecting the customer. If the destination is unreachable or not human (e.g., with voicemail detection), the assistant delivers the `fallbackMessage` to the customer and optionally ends the call.\n\n@default 'blind-transfer'",
            "enum": [
              "blind-transfer",
              "blind-transfer-add-summary-to-sip-header",
              "warm-transfer-say-message",
              "warm-transfer-say-summary",
              "warm-transfer-twiml",
              "warm-transfer-wait-for-operator-to-speak-first-and-then-say-message",
              "warm-transfer-wait-for-operator-to-speak-first-and-then-say-summary",
              "warm-transfer-experimental"
            ]
          },
          "message": {
            "description": "This is the message the assistant will deliver to the destination party before connecting the customer.\n\nUsage:\n- Used only when `mode` is `blind-transfer-add-summary-to-sip-header`, `warm-transfer-say-message`, `warm-transfer-wait-for-operator-to-speak-first-and-then-say-message`, or `warm-transfer-experimental`.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "$ref": "#/components/schemas/CustomMessage"
              }
            ]
          },
          "sipVerb": {
            "type": "object",
            "description": "This specifies the SIP verb to use while transferring the call.\n- 'refer': Uses SIP REFER to transfer the call (default)\n- 'bye': Ends current call with SIP BYE\n- 'dial': Uses SIP DIAL to transfer the call",
            "default": "refer",
            "enum": [
              "refer",
              "bye",
              "dial"
            ]
          },
          "holdAudioUrl": {
            "type": "string",
            "description": "This is the URL to an audio file played while the customer is on hold during transfer.\n\nUsage:\n- Used only when `mode` is `warm-transfer-experimental`.\n- Used when transferring calls to play hold audio for the customer.\n- Must be a publicly accessible URL to an audio file.\n- Supported formats: MP3 and WAV.\n- If not provided, the default hold audio will be used."
          },
          "transferCompleteAudioUrl": {
            "type": "string",
            "description": "This is the URL to an audio file played after the warm transfer message or summary is delivered to the destination party.\nIt can be used to play a custom sound like 'beep' to notify that the transfer is complete.\n\nUsage:\n- Used only when `mode` is `warm-transfer-experimental`.\n- Used when transferring calls to play hold audio for the destination party.\n- Must be a publicly accessible URL to an audio file.\n- Supported formats: MP3 and WAV."
          },
          "twiml": {
            "type": "string",
            "description": "This is the TwiML instructions to execute on the destination call leg before connecting the customer.\n\nUsage:\n- Used only when `mode` is `warm-transfer-twiml`.\n- Supports only `Play`, `Say`, `Gather`, `Hangup` and `Pause` verbs.\n- Maximum length is 4096 characters.\n\nExample:\n```\n<Say voice=\"alice\" language=\"en-US\">Hello, transferring a customer to you.</Say>\n<Pause length=\"2\"/>\n<Say>They called about billing questions.</Say>\n```",
            "maxLength": 4096
          },
          "summaryPlan": {
            "description": "This is the plan for generating a summary of the call to present to the destination party.\n\nUsage:\n- Used only when `mode` is `blind-transfer-add-summary-to-sip-header` or `warm-transfer-say-summary` or `warm-transfer-wait-for-operator-to-speak-first-and-then-say-summary` or `warm-transfer-experimental`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SummaryPlan"
              }
            ]
          },
          "sipHeadersInReferToEnabled": {
            "type": "boolean",
            "description": "This flag includes the sipHeaders from above in the refer to sip uri as url encoded query params.\n\n@default false"
          },
          "fallbackPlan": {
            "description": "This configures the fallback plan when the transfer fails (destination unreachable, busy, or not human).\n\nUsage:\n- Used only when `mode` is `warm-transfer-experimental`.\n- If not provided when using `warm-transfer-experimental`, a default message will be used.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferFallbackPlan"
              }
            ]
          }
        },
        "required": [
          "mode"
        ]
      },
      "TransferDestinationNumber": {
        "type": "object",
        "properties": {
          "message": {
            "description": "This is spoken to the customer before connecting them to the destination.\n\nUsage:\n- If this is not provided and transfer tool messages is not provided, default is \"Transferring the call now\".\n- If set to \"\", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.\n\nThis accepts a string or a ToolMessageStart class. Latter is useful if you want to specify multiple messages for different languages through the `contents` field.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "$ref": "#/components/schemas/CustomMessage"
              }
            ]
          },
          "type": {
            "type": "string",
            "enum": [
              "number"
            ]
          },
          "numberE164CheckEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle the E164 check for the `number` field. This is an advanced property which should be used if you know your use case requires it.\n\nUse cases:\n- `false`: To allow non-E164 numbers like `+001234567890`, `1234`, or `abc`. This is useful for dialing out to non-E164 numbers on your SIP trunks.\n- `true` (default): To allow only E164 numbers like `+14155551234`. This is standard for PSTN calls.\n\nIf `false`, the `number` is still required to only contain alphanumeric characters (regex: `/^\\+?[a-zA-Z0-9]+$/`).\n\n@default true (E164 check is enabled)",
            "default": true
          },
          "number": {
            "type": "string",
            "description": "This is the phone number to transfer the call to.",
            "minLength": 3,
            "maxLength": 40
          },
          "extension": {
            "type": "string",
            "description": "This is the extension to dial after transferring the call to the `number`.",
            "minLength": 1,
            "maxLength": 10
          },
          "callerId": {
            "type": "string",
            "description": "This is the caller ID to use when transferring the call to the `number`.\n\nUsage:\n- If not provided, the caller ID will be the number the call is coming from. Example, +14151111111 calls in to and the assistant transfers out to +16470000000. +16470000000 will see +14151111111 as the caller.\n- To change this behavior, provide a `callerId`.\n- Set to '{{customer.number}}' to always use the customer's number as the caller ID.\n- Set to '{{phoneNumber.number}}' to always use the phone number of the assistant as the caller ID.\n- Set to any E164 number to always use that number as the caller ID. This needs to be a number that is owned or verified by your Transport provider like Twilio.\n\nFor Twilio, you can read up more here: https://www.twilio.com/docs/voice/twiml/dial#callerid",
            "maxLength": 40
          },
          "transferPlan": {
            "description": "This configures how transfer is executed and the experience of the destination party receiving the call. Defaults to `blind-transfer`.\n\n@default `transferPlan.mode='blind-transfer'`",
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferPlan"
              }
            ]
          },
          "description": {
            "type": "string",
            "description": "This is the description of the destination, used by the AI to choose when and how to transfer the call."
          }
        },
        "required": [
          "type",
          "number"
        ]
      },
      "TransferDestinationSip": {
        "type": "object",
        "properties": {
          "message": {
            "description": "This is spoken to the customer before connecting them to the destination.\n\nUsage:\n- If this is not provided and transfer tool messages is not provided, default is \"Transferring the call now\".\n- If set to \"\", nothing is spoken. This is useful when you want to silently transfer. This is especially useful when transferring between assistants in a squad. In this scenario, you likely also want to set `assistant.firstMessageMode=assistant-speaks-first-with-model-generated-message` for the destination assistant.\n\nThis accepts a string or a ToolMessageStart class. Latter is useful if you want to specify multiple messages for different languages through the `contents` field.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "$ref": "#/components/schemas/CustomMessage"
              }
            ]
          },
          "type": {
            "type": "string",
            "enum": [
              "sip"
            ]
          },
          "sipUri": {
            "type": "string",
            "description": "This is the SIP URI to transfer the call to."
          },
          "transferPlan": {
            "description": "This configures how transfer is executed and the experience of the destination party receiving the call. Defaults to `blind-transfer`.\n\n@default `transferPlan.mode='blind-transfer'`",
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferPlan"
              }
            ]
          },
          "sipHeaders": {
            "type": "object",
            "description": "These are custom headers to be added to SIP refer during transfer call."
          },
          "description": {
            "type": "string",
            "description": "This is the description of the destination, used by the AI to choose when and how to transfer the call."
          }
        },
        "required": [
          "type",
          "sipUri"
        ]
      },
      "CreateTransferCallToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "transferCall"
            ]
          },
          "destinations": {
            "type": "array",
            "description": "These are the destinations that the call can be transferred to. If no destinations are provided, server.url will be used to get the transfer destination once the tool is called.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TransferDestinationAssistant",
                  "title": "Assistant"
                },
                {
                  "$ref": "#/components/schemas/TransferDestinationNumber",
                  "title": "Number"
                },
                {
                  "$ref": "#/components/schemas/TransferDestinationSip",
                  "title": "Sip"
                }
              ]
            }
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "CreateCustomKnowledgeBaseDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This knowledge base is bring your own knowledge base implementation.",
            "enum": [
              "custom-knowledge-base"
            ]
          },
          "server": {
            "description": "This is where the knowledge base request will be sent.\n\nRequest Example:\n\nPOST https://{server.url}\nContent-Type: application/json\n\n{\n  \"messsage\": {\n    \"type\": \"knowledge-base-request\",\n    \"messages\": [\n      {\n        \"role\": \"user\",\n        \"content\": \"Why is ocean blue?\"\n      }\n    ],\n    ...other metadata about the call...\n  }\n}\n\nResponse Expected:\n```\n{\n  \"message\": {\n     \"role\": \"assistant\",\n     \"content\": \"The ocean is blue because water absorbs everything but blue.\",\n  }, // YOU CAN RETURN THE EXACT RESPONSE TO SPEAK\n  \"documents\": [\n    {\n      \"content\": \"The ocean is blue primarily because water absorbs colors in the red part of the light spectrum and scatters the blue light, making it more visible to our eyes.\",\n      \"similarity\": 1\n    },\n    {\n      \"content\": \"Blue light is scattered more by the water molecules than other colors, enhancing the blue appearance of the ocean.\",\n      \"similarity\": .5\n    }\n  ] // OR, YOU CAN RETURN AN ARRAY OF DOCUMENTS THAT WILL BE SENT TO THE MODEL\n}\n```",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          }
        },
        "required": [
          "provider",
          "server"
        ]
      },
      "KnowledgeBase": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the knowledge base",
            "example": "My Knowledge Base"
          },
          "provider": {
            "type": "string",
            "description": "The provider of the knowledge base",
            "enum": [
              "google"
            ],
            "example": "google"
          },
          "model": {
            "type": "string",
            "description": "The model to use for the knowledge base",
            "enum": [
              "gemini-2.5-pro-preview-05-06",
              "gemini-2.5-flash-preview-05-20",
              "gemini-2.5-flash-preview-04-17",
              "gemini-2.0-flash-thinking-exp",
              "gemini-2.0-pro-exp-02-05",
              "gemini-2.0-flash",
              "gemini-2.0-flash-lite",
              "gemini-2.0-flash-lite-preview-02-05",
              "gemini-2.0-flash-exp",
              "gemini-2.0-flash-realtime-exp",
              "gemini-1.5-flash",
              "gemini-1.5-flash-002",
              "gemini-1.5-pro",
              "gemini-1.5-pro-002",
              "gemini-1.0-pro"
            ]
          },
          "description": {
            "type": "string",
            "description": "A description of the knowledge base"
          },
          "fileIds": {
            "description": "The file IDs associated with this knowledge base",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "name",
          "provider",
          "description",
          "fileIds"
        ]
      },
      "CreateQueryToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "query"
            ],
            "description": "The type of tool. \"query\" for Query tool."
          },
          "knowledgeBases": {
            "description": "The knowledge bases to query",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/KnowledgeBase"
            }
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "CreateGoogleCalendarCreateEventToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "google.calendar.event.create"
            ],
            "description": "The type of tool. \"google.calendar.event.create\" for Google Calendar tool."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "CreateGoogleSheetsRowAppendToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "google.sheets.row.append"
            ],
            "description": "The type of tool. \"google.sheets.row.append\" for Google Sheets tool."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "CreateGoogleCalendarCheckAvailabilityToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "google.calendar.availability.check"
            ],
            "description": "The type of tool. \"google.calendar.availability.check\" for Google Calendar availability check tool."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "CreateSlackSendMessageToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "slack.message.send"
            ],
            "description": "The type of tool. \"slack.message.send\" for Slack send message tool."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "CreateMcpToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "mcp"
            ],
            "description": "The type of tool. \"mcp\" for MCP tool."
          },
          "server": {
            "description": "\n  This is the server where a `tool-calls` webhook will be sent.\n\n  Notes:\n  - Webhook is sent to this server when a tool call is made.\n  - Webhook contains the call, assistant, and phone number objects.\n  - Webhook contains the variables set on the assistant.\n  - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.\n  - Webhook expects a response with tool call result.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "CreateGoHighLevelCalendarAvailabilityToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "gohighlevel.calendar.availability.check"
            ],
            "description": "The type of tool. \"gohighlevel.calendar.availability.check\" for GoHighLevel Calendar availability check tool."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "CreateGoHighLevelCalendarEventCreateToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "gohighlevel.calendar.event.create"
            ],
            "description": "The type of tool. \"gohighlevel.calendar.event.create\" for GoHighLevel Calendar event create tool."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "CreateGoHighLevelContactCreateToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "gohighlevel.contact.create"
            ],
            "description": "The type of tool. \"gohighlevel.contact.create\" for GoHighLevel contact create tool."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "CreateGoHighLevelContactGetToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "gohighlevel.contact.get"
            ],
            "description": "The type of tool. \"gohighlevel.contact.get\" for GoHighLevel contact get tool."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "AnyscaleModel": {
        "type": "object",
        "properties": {
          "messages": {
            "description": "This is the starting state for the conversation.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            }
          },
          "tools": {
            "type": "array",
            "description": "These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.\n\nBoth `tools` and `toolIds` can be used together.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CreateApiRequestToolDTO",
                  "title": "ApiRequestTool"
                },
                {
                  "$ref": "#/components/schemas/CreateBashToolDTO",
                  "title": "BashTool"
                },
                {
                  "$ref": "#/components/schemas/CreateComputerToolDTO",
                  "title": "ComputerTool"
                },
                {
                  "$ref": "#/components/schemas/CreateDtmfToolDTO",
                  "title": "DtmfTool"
                },
                {
                  "$ref": "#/components/schemas/CreateEndCallToolDTO",
                  "title": "EndCallTool"
                },
                {
                  "$ref": "#/components/schemas/CreateFunctionToolDTO",
                  "title": "FunctionTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                  "title": "GoHighLevelCalendarAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                  "title": "GoHighLevelCalendarEventCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                  "title": "GoHighLevelContactCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactGetToolDTO",
                  "title": "GoHighLevelContactGetTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                  "title": "GoogleCalendarCheckAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                  "title": "GoogleCalendarCreateEventTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                  "title": "GoogleSheetsRowAppendTool"
                },
                {
                  "$ref": "#/components/schemas/CreateMcpToolDTO",
                  "title": "McpTool"
                },
                {
                  "$ref": "#/components/schemas/CreateQueryToolDTO",
                  "title": "QueryTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSlackSendMessageToolDTO",
                  "title": "SlackSendMessageTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSmsToolDTO",
                  "title": "SmsTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTextEditorToolDTO",
                  "title": "TextEditorTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTransferCallToolDTO",
                  "title": "TransferCallTool"
                }
              ]
            }
          },
          "toolIds": {
            "description": "These are the tools that the assistant can use during the call. To use transient tools, use `tools`.\n\nBoth `tools` and `toolIds` can be used together.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "knowledgeBase": {
            "description": "These are the options for the knowledge base.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateCustomKnowledgeBaseDTO",
                "title": "Custom"
              }
            ]
          },
          "knowledgeBaseId": {
            "type": "string",
            "description": "This is the ID of the knowledge base the model will use."
          },
          "provider": {
            "type": "string",
            "enum": [
              "anyscale"
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b"
          },
          "temperature": {
            "type": "number",
            "description": "This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.",
            "minimum": 0,
            "maximum": 2
          },
          "maxTokens": {
            "type": "number",
            "description": "This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.",
            "minimum": 50,
            "maximum": 10000
          },
          "emotionRecognitionEnabled": {
            "type": "boolean",
            "description": "This determines whether we detect user's emotion while they speak and send it as an additional info to model.\n\nDefault `false` because the model is usually are good at understanding the user's emotion from text.\n\n@default false"
          },
          "numFastTurns": {
            "type": "number",
            "description": "This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.\n\nDefault is 0.\n\n@default 0",
            "minimum": 0
          }
        },
        "required": [
          "provider",
          "model"
        ]
      },
      "AnthropicThinkingConfig": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "enabled"
            ]
          },
          "budgetTokens": {
            "type": "number",
            "description": "The maximum number of tokens to allocate for thinking.\nMust be between 1024 and 100000 tokens.",
            "minimum": 1024,
            "maximum": 100000
          }
        },
        "required": [
          "type",
          "budgetTokens"
        ]
      },
      "AnthropicModel": {
        "type": "object",
        "properties": {
          "messages": {
            "description": "This is the starting state for the conversation.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            }
          },
          "tools": {
            "type": "array",
            "description": "These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.\n\nBoth `tools` and `toolIds` can be used together.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CreateApiRequestToolDTO",
                  "title": "ApiRequestTool"
                },
                {
                  "$ref": "#/components/schemas/CreateBashToolDTO",
                  "title": "BashTool"
                },
                {
                  "$ref": "#/components/schemas/CreateComputerToolDTO",
                  "title": "ComputerTool"
                },
                {
                  "$ref": "#/components/schemas/CreateDtmfToolDTO",
                  "title": "DtmfTool"
                },
                {
                  "$ref": "#/components/schemas/CreateEndCallToolDTO",
                  "title": "EndCallTool"
                },
                {
                  "$ref": "#/components/schemas/CreateFunctionToolDTO",
                  "title": "FunctionTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                  "title": "GoHighLevelCalendarAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                  "title": "GoHighLevelCalendarEventCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                  "title": "GoHighLevelContactCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactGetToolDTO",
                  "title": "GoHighLevelContactGetTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                  "title": "GoogleCalendarCheckAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                  "title": "GoogleCalendarCreateEventTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                  "title": "GoogleSheetsRowAppendTool"
                },
                {
                  "$ref": "#/components/schemas/CreateMcpToolDTO",
                  "title": "McpTool"
                },
                {
                  "$ref": "#/components/schemas/CreateQueryToolDTO",
                  "title": "QueryTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSlackSendMessageToolDTO",
                  "title": "SlackSendMessageTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSmsToolDTO",
                  "title": "SmsTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTextEditorToolDTO",
                  "title": "TextEditorTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTransferCallToolDTO",
                  "title": "TransferCallTool"
                }
              ]
            }
          },
          "toolIds": {
            "description": "These are the tools that the assistant can use during the call. To use transient tools, use `tools`.\n\nBoth `tools` and `toolIds` can be used together.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "knowledgeBase": {
            "description": "These are the options for the knowledge base.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateCustomKnowledgeBaseDTO",
                "title": "Custom"
              }
            ]
          },
          "knowledgeBaseId": {
            "type": "string",
            "description": "This is the ID of the knowledge base the model will use."
          },
          "model": {
            "type": "string",
            "description": "The specific Anthropic/Claude model that will be used.",
            "enum": [
              "claude-3-opus-20240229",
              "claude-3-sonnet-20240229",
              "claude-3-haiku-20240307",
              "claude-3-5-sonnet-20240620",
              "claude-3-5-sonnet-20241022",
              "claude-3-5-haiku-20241022",
              "claude-3-7-sonnet-20250219",
              "claude-opus-4-20250514",
              "claude-sonnet-4-20250514"
            ]
          },
          "provider": {
            "type": "string",
            "description": "The provider identifier for Anthropic.",
            "enum": [
              "anthropic"
            ]
          },
          "thinking": {
            "description": "Optional configuration for Anthropic's thinking feature.\nOnly applicable for claude-3-7-sonnet-20250219 model.\nIf provided, maxTokens must be greater than thinking.budgetTokens.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnthropicThinkingConfig"
              }
            ]
          },
          "temperature": {
            "type": "number",
            "description": "This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.",
            "minimum": 0,
            "maximum": 2
          },
          "maxTokens": {
            "type": "number",
            "description": "This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.",
            "minimum": 50,
            "maximum": 10000
          },
          "emotionRecognitionEnabled": {
            "type": "boolean",
            "description": "This determines whether we detect user's emotion while they speak and send it as an additional info to model.\n\nDefault `false` because the model is usually are good at understanding the user's emotion from text.\n\n@default false"
          },
          "numFastTurns": {
            "type": "number",
            "description": "This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.\n\nDefault is 0.\n\n@default 0",
            "minimum": 0
          }
        },
        "required": [
          "model",
          "provider"
        ]
      },
      "CerebrasModel": {
        "type": "object",
        "properties": {
          "messages": {
            "description": "This is the starting state for the conversation.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            }
          },
          "tools": {
            "type": "array",
            "description": "These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.\n\nBoth `tools` and `toolIds` can be used together.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CreateApiRequestToolDTO",
                  "title": "ApiRequestTool"
                },
                {
                  "$ref": "#/components/schemas/CreateBashToolDTO",
                  "title": "BashTool"
                },
                {
                  "$ref": "#/components/schemas/CreateComputerToolDTO",
                  "title": "ComputerTool"
                },
                {
                  "$ref": "#/components/schemas/CreateDtmfToolDTO",
                  "title": "DtmfTool"
                },
                {
                  "$ref": "#/components/schemas/CreateEndCallToolDTO",
                  "title": "EndCallTool"
                },
                {
                  "$ref": "#/components/schemas/CreateFunctionToolDTO",
                  "title": "FunctionTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                  "title": "GoHighLevelCalendarAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                  "title": "GoHighLevelCalendarEventCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                  "title": "GoHighLevelContactCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactGetToolDTO",
                  "title": "GoHighLevelContactGetTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                  "title": "GoogleCalendarCheckAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                  "title": "GoogleCalendarCreateEventTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                  "title": "GoogleSheetsRowAppendTool"
                },
                {
                  "$ref": "#/components/schemas/CreateMcpToolDTO",
                  "title": "McpTool"
                },
                {
                  "$ref": "#/components/schemas/CreateQueryToolDTO",
                  "title": "QueryTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSlackSendMessageToolDTO",
                  "title": "SlackSendMessageTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSmsToolDTO",
                  "title": "SmsTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTextEditorToolDTO",
                  "title": "TextEditorTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTransferCallToolDTO",
                  "title": "TransferCallTool"
                }
              ]
            }
          },
          "toolIds": {
            "description": "These are the tools that the assistant can use during the call. To use transient tools, use `tools`.\n\nBoth `tools` and `toolIds` can be used together.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "knowledgeBase": {
            "description": "These are the options for the knowledge base.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateCustomKnowledgeBaseDTO",
                "title": "Custom"
              }
            ]
          },
          "knowledgeBaseId": {
            "type": "string",
            "description": "This is the ID of the knowledge base the model will use."
          },
          "model": {
            "type": "string",
            "description": "This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b",
            "enum": [
              "llama3.1-8b",
              "llama-3.3-70b"
            ]
          },
          "provider": {
            "type": "string",
            "enum": [
              "cerebras"
            ]
          },
          "temperature": {
            "type": "number",
            "description": "This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.",
            "minimum": 0,
            "maximum": 2
          },
          "maxTokens": {
            "type": "number",
            "description": "This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.",
            "minimum": 50,
            "maximum": 10000
          },
          "emotionRecognitionEnabled": {
            "type": "boolean",
            "description": "This determines whether we detect user's emotion while they speak and send it as an additional info to model.\n\nDefault `false` because the model is usually are good at understanding the user's emotion from text.\n\n@default false"
          },
          "numFastTurns": {
            "type": "number",
            "description": "This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.\n\nDefault is 0.\n\n@default 0",
            "minimum": 0
          }
        },
        "required": [
          "model",
          "provider"
        ]
      },
      "CustomLLMModel": {
        "type": "object",
        "properties": {
          "messages": {
            "description": "This is the starting state for the conversation.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            }
          },
          "tools": {
            "type": "array",
            "description": "These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.\n\nBoth `tools` and `toolIds` can be used together.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CreateApiRequestToolDTO",
                  "title": "ApiRequestTool"
                },
                {
                  "$ref": "#/components/schemas/CreateBashToolDTO",
                  "title": "BashTool"
                },
                {
                  "$ref": "#/components/schemas/CreateComputerToolDTO",
                  "title": "ComputerTool"
                },
                {
                  "$ref": "#/components/schemas/CreateDtmfToolDTO",
                  "title": "DtmfTool"
                },
                {
                  "$ref": "#/components/schemas/CreateEndCallToolDTO",
                  "title": "EndCallTool"
                },
                {
                  "$ref": "#/components/schemas/CreateFunctionToolDTO",
                  "title": "FunctionTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                  "title": "GoHighLevelCalendarAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                  "title": "GoHighLevelCalendarEventCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                  "title": "GoHighLevelContactCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactGetToolDTO",
                  "title": "GoHighLevelContactGetTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                  "title": "GoogleCalendarCheckAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                  "title": "GoogleCalendarCreateEventTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                  "title": "GoogleSheetsRowAppendTool"
                },
                {
                  "$ref": "#/components/schemas/CreateMcpToolDTO",
                  "title": "McpTool"
                },
                {
                  "$ref": "#/components/schemas/CreateQueryToolDTO",
                  "title": "QueryTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSlackSendMessageToolDTO",
                  "title": "SlackSendMessageTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSmsToolDTO",
                  "title": "SmsTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTextEditorToolDTO",
                  "title": "TextEditorTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTransferCallToolDTO",
                  "title": "TransferCallTool"
                }
              ]
            }
          },
          "toolIds": {
            "description": "These are the tools that the assistant can use during the call. To use transient tools, use `tools`.\n\nBoth `tools` and `toolIds` can be used together.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "knowledgeBase": {
            "description": "These are the options for the knowledge base.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateCustomKnowledgeBaseDTO",
                "title": "Custom"
              }
            ]
          },
          "knowledgeBaseId": {
            "type": "string",
            "description": "This is the ID of the knowledge base the model will use."
          },
          "provider": {
            "type": "string",
            "description": "This is the provider that will be used for the model. Any service, including your own server, that is compatible with the OpenAI API can be used.",
            "enum": [
              "custom-llm"
            ]
          },
          "metadataSendMode": {
            "type": "string",
            "description": "This determines whether metadata is sent in requests to the custom provider.\n\n- `off` will not send any metadata. payload will look like `{ messages }`\n- `variable` will send `assistant.metadata` as a variable on the payload. payload will look like `{ messages, metadata }`\n- `destructured` will send `assistant.metadata` fields directly on the payload. payload will look like `{ messages, ...metadata }`\n\nFurther, `variable` and `destructured` will send `call`, `phoneNumber`, and `customer` objects in the payload.\n\nDefault is `variable`.",
            "enum": [
              "off",
              "variable",
              "destructured"
            ]
          },
          "url": {
            "type": "string",
            "description": "These is the URL we'll use for the OpenAI client's `baseURL`. Ex. https://openrouter.ai/api/v1"
          },
          "timeoutSeconds": {
            "type": "number",
            "description": "This sets the timeout for the connection to the custom provider without needing to stream any tokens back. Default is 20 seconds.",
            "minimum": 20,
            "maximum": 600
          },
          "model": {
            "type": "string",
            "description": "This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b"
          },
          "temperature": {
            "type": "number",
            "description": "This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.",
            "minimum": 0,
            "maximum": 2
          },
          "maxTokens": {
            "type": "number",
            "description": "This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.",
            "minimum": 50,
            "maximum": 10000
          },
          "emotionRecognitionEnabled": {
            "type": "boolean",
            "description": "This determines whether we detect user's emotion while they speak and send it as an additional info to model.\n\nDefault `false` because the model is usually are good at understanding the user's emotion from text.\n\n@default false"
          },
          "numFastTurns": {
            "type": "number",
            "description": "This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.\n\nDefault is 0.\n\n@default 0",
            "minimum": 0
          }
        },
        "required": [
          "provider",
          "url",
          "model"
        ]
      },
      "DeepInfraModel": {
        "type": "object",
        "properties": {
          "messages": {
            "description": "This is the starting state for the conversation.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            }
          },
          "tools": {
            "type": "array",
            "description": "These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.\n\nBoth `tools` and `toolIds` can be used together.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CreateApiRequestToolDTO",
                  "title": "ApiRequestTool"
                },
                {
                  "$ref": "#/components/schemas/CreateBashToolDTO",
                  "title": "BashTool"
                },
                {
                  "$ref": "#/components/schemas/CreateComputerToolDTO",
                  "title": "ComputerTool"
                },
                {
                  "$ref": "#/components/schemas/CreateDtmfToolDTO",
                  "title": "DtmfTool"
                },
                {
                  "$ref": "#/components/schemas/CreateEndCallToolDTO",
                  "title": "EndCallTool"
                },
                {
                  "$ref": "#/components/schemas/CreateFunctionToolDTO",
                  "title": "FunctionTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                  "title": "GoHighLevelCalendarAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                  "title": "GoHighLevelCalendarEventCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                  "title": "GoHighLevelContactCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactGetToolDTO",
                  "title": "GoHighLevelContactGetTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                  "title": "GoogleCalendarCheckAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                  "title": "GoogleCalendarCreateEventTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                  "title": "GoogleSheetsRowAppendTool"
                },
                {
                  "$ref": "#/components/schemas/CreateMcpToolDTO",
                  "title": "McpTool"
                },
                {
                  "$ref": "#/components/schemas/CreateQueryToolDTO",
                  "title": "QueryTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSlackSendMessageToolDTO",
                  "title": "SlackSendMessageTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSmsToolDTO",
                  "title": "SmsTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTextEditorToolDTO",
                  "title": "TextEditorTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTransferCallToolDTO",
                  "title": "TransferCallTool"
                }
              ]
            }
          },
          "toolIds": {
            "description": "These are the tools that the assistant can use during the call. To use transient tools, use `tools`.\n\nBoth `tools` and `toolIds` can be used together.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "knowledgeBase": {
            "description": "These are the options for the knowledge base.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateCustomKnowledgeBaseDTO",
                "title": "Custom"
              }
            ]
          },
          "knowledgeBaseId": {
            "type": "string",
            "description": "This is the ID of the knowledge base the model will use."
          },
          "provider": {
            "type": "string",
            "enum": [
              "deepinfra"
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b"
          },
          "temperature": {
            "type": "number",
            "description": "This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.",
            "minimum": 0,
            "maximum": 2
          },
          "maxTokens": {
            "type": "number",
            "description": "This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.",
            "minimum": 50,
            "maximum": 10000
          },
          "emotionRecognitionEnabled": {
            "type": "boolean",
            "description": "This determines whether we detect user's emotion while they speak and send it as an additional info to model.\n\nDefault `false` because the model is usually are good at understanding the user's emotion from text.\n\n@default false"
          },
          "numFastTurns": {
            "type": "number",
            "description": "This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.\n\nDefault is 0.\n\n@default 0",
            "minimum": 0
          }
        },
        "required": [
          "provider",
          "model"
        ]
      },
      "DeepSeekModel": {
        "type": "object",
        "properties": {
          "messages": {
            "description": "This is the starting state for the conversation.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            }
          },
          "tools": {
            "type": "array",
            "description": "These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.\n\nBoth `tools` and `toolIds` can be used together.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CreateApiRequestToolDTO",
                  "title": "ApiRequestTool"
                },
                {
                  "$ref": "#/components/schemas/CreateBashToolDTO",
                  "title": "BashTool"
                },
                {
                  "$ref": "#/components/schemas/CreateComputerToolDTO",
                  "title": "ComputerTool"
                },
                {
                  "$ref": "#/components/schemas/CreateDtmfToolDTO",
                  "title": "DtmfTool"
                },
                {
                  "$ref": "#/components/schemas/CreateEndCallToolDTO",
                  "title": "EndCallTool"
                },
                {
                  "$ref": "#/components/schemas/CreateFunctionToolDTO",
                  "title": "FunctionTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                  "title": "GoHighLevelCalendarAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                  "title": "GoHighLevelCalendarEventCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                  "title": "GoHighLevelContactCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactGetToolDTO",
                  "title": "GoHighLevelContactGetTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                  "title": "GoogleCalendarCheckAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                  "title": "GoogleCalendarCreateEventTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                  "title": "GoogleSheetsRowAppendTool"
                },
                {
                  "$ref": "#/components/schemas/CreateMcpToolDTO",
                  "title": "McpTool"
                },
                {
                  "$ref": "#/components/schemas/CreateQueryToolDTO",
                  "title": "QueryTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSlackSendMessageToolDTO",
                  "title": "SlackSendMessageTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSmsToolDTO",
                  "title": "SmsTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTextEditorToolDTO",
                  "title": "TextEditorTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTransferCallToolDTO",
                  "title": "TransferCallTool"
                }
              ]
            }
          },
          "toolIds": {
            "description": "These are the tools that the assistant can use during the call. To use transient tools, use `tools`.\n\nBoth `tools` and `toolIds` can be used together.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "knowledgeBase": {
            "description": "These are the options for the knowledge base.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateCustomKnowledgeBaseDTO",
                "title": "Custom"
              }
            ]
          },
          "knowledgeBaseId": {
            "type": "string",
            "description": "This is the ID of the knowledge base the model will use."
          },
          "model": {
            "type": "string",
            "description": "This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b",
            "enum": [
              "deepseek-chat",
              "deepseek-reasoner"
            ]
          },
          "provider": {
            "type": "string",
            "enum": [
              "deep-seek"
            ]
          },
          "temperature": {
            "type": "number",
            "description": "This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.",
            "minimum": 0,
            "maximum": 2
          },
          "maxTokens": {
            "type": "number",
            "description": "This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.",
            "minimum": 50,
            "maximum": 10000
          },
          "emotionRecognitionEnabled": {
            "type": "boolean",
            "description": "This determines whether we detect user's emotion while they speak and send it as an additional info to model.\n\nDefault `false` because the model is usually are good at understanding the user's emotion from text.\n\n@default false"
          },
          "numFastTurns": {
            "type": "number",
            "description": "This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.\n\nDefault is 0.\n\n@default 0",
            "minimum": 0
          }
        },
        "required": [
          "model",
          "provider"
        ]
      },
      "GeminiMultimodalLivePrebuiltVoiceConfig": {
        "type": "object",
        "properties": {
          "voiceName": {
            "type": "string",
            "enum": [
              "Puck",
              "Charon",
              "Kore",
              "Fenrir",
              "Aoede"
            ]
          }
        },
        "required": [
          "voiceName"
        ]
      },
      "GeminiMultimodalLiveVoiceConfig": {
        "type": "object",
        "properties": {
          "prebuiltVoiceConfig": {
            "$ref": "#/components/schemas/GeminiMultimodalLivePrebuiltVoiceConfig"
          }
        },
        "required": [
          "prebuiltVoiceConfig"
        ]
      },
      "GeminiMultimodalLiveSpeechConfig": {
        "type": "object",
        "properties": {
          "voiceConfig": {
            "$ref": "#/components/schemas/GeminiMultimodalLiveVoiceConfig"
          }
        },
        "required": [
          "voiceConfig"
        ]
      },
      "GoogleRealtimeConfig": {
        "type": "object",
        "properties": {
          "topP": {
            "type": "number",
            "description": "This is the nucleus sampling parameter that controls the cumulative probability of tokens considered during text generation.\nOnly applicable with the Gemini Flash 2.0 Multimodal Live API."
          },
          "topK": {
            "type": "number",
            "description": "This is the top-k sampling parameter that limits the number of highest probability tokens considered during text generation.\nOnly applicable with the Gemini Flash 2.0 Multimodal Live API."
          },
          "presencePenalty": {
            "type": "number",
            "description": "This is the presence penalty parameter that influences the model's likelihood to repeat information by penalizing tokens based on their presence in the text.\nOnly applicable with the Gemini Flash 2.0 Multimodal Live API."
          },
          "frequencyPenalty": {
            "type": "number",
            "description": "This is the frequency penalty parameter that influences the model's likelihood to repeat tokens by penalizing them based on their frequency in the text.\nOnly applicable with the Gemini Flash 2.0 Multimodal Live API."
          },
          "speechConfig": {
            "description": "This is the speech configuration object that defines the voice settings to be used for the model's speech output.\nOnly applicable with the Gemini Flash 2.0 Multimodal Live API.",
            "allOf": [
              {
                "$ref": "#/components/schemas/GeminiMultimodalLiveSpeechConfig"
              }
            ]
          }
        }
      },
      "GoogleModel": {
        "type": "object",
        "properties": {
          "messages": {
            "description": "This is the starting state for the conversation.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            }
          },
          "tools": {
            "type": "array",
            "description": "These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.\n\nBoth `tools` and `toolIds` can be used together.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CreateApiRequestToolDTO",
                  "title": "ApiRequestTool"
                },
                {
                  "$ref": "#/components/schemas/CreateBashToolDTO",
                  "title": "BashTool"
                },
                {
                  "$ref": "#/components/schemas/CreateComputerToolDTO",
                  "title": "ComputerTool"
                },
                {
                  "$ref": "#/components/schemas/CreateDtmfToolDTO",
                  "title": "DtmfTool"
                },
                {
                  "$ref": "#/components/schemas/CreateEndCallToolDTO",
                  "title": "EndCallTool"
                },
                {
                  "$ref": "#/components/schemas/CreateFunctionToolDTO",
                  "title": "FunctionTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                  "title": "GoHighLevelCalendarAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                  "title": "GoHighLevelCalendarEventCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                  "title": "GoHighLevelContactCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactGetToolDTO",
                  "title": "GoHighLevelContactGetTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                  "title": "GoogleCalendarCheckAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                  "title": "GoogleCalendarCreateEventTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                  "title": "GoogleSheetsRowAppendTool"
                },
                {
                  "$ref": "#/components/schemas/CreateMcpToolDTO",
                  "title": "McpTool"
                },
                {
                  "$ref": "#/components/schemas/CreateQueryToolDTO",
                  "title": "QueryTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSlackSendMessageToolDTO",
                  "title": "SlackSendMessageTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSmsToolDTO",
                  "title": "SmsTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTextEditorToolDTO",
                  "title": "TextEditorTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTransferCallToolDTO",
                  "title": "TransferCallTool"
                }
              ]
            }
          },
          "toolIds": {
            "description": "These are the tools that the assistant can use during the call. To use transient tools, use `tools`.\n\nBoth `tools` and `toolIds` can be used together.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "knowledgeBase": {
            "description": "These are the options for the knowledge base.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateCustomKnowledgeBaseDTO",
                "title": "Custom"
              }
            ]
          },
          "knowledgeBaseId": {
            "type": "string",
            "description": "This is the ID of the knowledge base the model will use."
          },
          "model": {
            "type": "string",
            "description": "This is the Google model that will be used.",
            "enum": [
              "gemini-2.5-pro-preview-05-06",
              "gemini-2.5-flash-preview-05-20",
              "gemini-2.5-flash-preview-04-17",
              "gemini-2.0-flash-thinking-exp",
              "gemini-2.0-pro-exp-02-05",
              "gemini-2.0-flash",
              "gemini-2.0-flash-lite",
              "gemini-2.0-flash-lite-preview-02-05",
              "gemini-2.0-flash-exp",
              "gemini-2.0-flash-realtime-exp",
              "gemini-1.5-flash",
              "gemini-1.5-flash-002",
              "gemini-1.5-pro",
              "gemini-1.5-pro-002",
              "gemini-1.0-pro"
            ]
          },
          "provider": {
            "type": "string",
            "enum": [
              "google"
            ]
          },
          "realtimeConfig": {
            "description": "This is the session configuration for the Gemini Flash 2.0 Multimodal Live API.\nOnly applicable if the model `gemini-2.0-flash-realtime-exp` is selected.",
            "allOf": [
              {
                "$ref": "#/components/schemas/GoogleRealtimeConfig"
              }
            ]
          },
          "temperature": {
            "type": "number",
            "description": "This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.",
            "minimum": 0,
            "maximum": 2
          },
          "maxTokens": {
            "type": "number",
            "description": "This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.",
            "minimum": 50,
            "maximum": 10000
          },
          "emotionRecognitionEnabled": {
            "type": "boolean",
            "description": "This determines whether we detect user's emotion while they speak and send it as an additional info to model.\n\nDefault `false` because the model is usually are good at understanding the user's emotion from text.\n\n@default false"
          },
          "numFastTurns": {
            "type": "number",
            "description": "This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.\n\nDefault is 0.\n\n@default 0",
            "minimum": 0
          }
        },
        "required": [
          "model",
          "provider"
        ]
      },
      "GroqModel": {
        "type": "object",
        "properties": {
          "messages": {
            "description": "This is the starting state for the conversation.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            }
          },
          "tools": {
            "type": "array",
            "description": "These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.\n\nBoth `tools` and `toolIds` can be used together.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CreateApiRequestToolDTO",
                  "title": "ApiRequestTool"
                },
                {
                  "$ref": "#/components/schemas/CreateBashToolDTO",
                  "title": "BashTool"
                },
                {
                  "$ref": "#/components/schemas/CreateComputerToolDTO",
                  "title": "ComputerTool"
                },
                {
                  "$ref": "#/components/schemas/CreateDtmfToolDTO",
                  "title": "DtmfTool"
                },
                {
                  "$ref": "#/components/schemas/CreateEndCallToolDTO",
                  "title": "EndCallTool"
                },
                {
                  "$ref": "#/components/schemas/CreateFunctionToolDTO",
                  "title": "FunctionTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                  "title": "GoHighLevelCalendarAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                  "title": "GoHighLevelCalendarEventCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                  "title": "GoHighLevelContactCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactGetToolDTO",
                  "title": "GoHighLevelContactGetTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                  "title": "GoogleCalendarCheckAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                  "title": "GoogleCalendarCreateEventTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                  "title": "GoogleSheetsRowAppendTool"
                },
                {
                  "$ref": "#/components/schemas/CreateMcpToolDTO",
                  "title": "McpTool"
                },
                {
                  "$ref": "#/components/schemas/CreateQueryToolDTO",
                  "title": "QueryTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSlackSendMessageToolDTO",
                  "title": "SlackSendMessageTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSmsToolDTO",
                  "title": "SmsTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTextEditorToolDTO",
                  "title": "TextEditorTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTransferCallToolDTO",
                  "title": "TransferCallTool"
                }
              ]
            }
          },
          "toolIds": {
            "description": "These are the tools that the assistant can use during the call. To use transient tools, use `tools`.\n\nBoth `tools` and `toolIds` can be used together.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "knowledgeBase": {
            "description": "These are the options for the knowledge base.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateCustomKnowledgeBaseDTO",
                "title": "Custom"
              }
            ]
          },
          "knowledgeBaseId": {
            "type": "string",
            "description": "This is the ID of the knowledge base the model will use."
          },
          "model": {
            "type": "string",
            "description": "This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b",
            "enum": [
              "deepseek-r1-distill-llama-70b",
              "llama-3.3-70b-versatile",
              "llama-3.1-405b-reasoning",
              "llama-3.1-8b-instant",
              "llama3-8b-8192",
              "llama3-70b-8192",
              "gemma2-9b-it",
              "meta-llama/llama-4-maverick-17b-128e-instruct",
              "meta-llama/llama-4-scout-17b-16e-instruct",
              "mistral-saba-24b",
              "compound-beta",
              "compound-beta-mini"
            ]
          },
          "provider": {
            "type": "string",
            "enum": [
              "groq"
            ]
          },
          "temperature": {
            "type": "number",
            "description": "This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.",
            "minimum": 0,
            "maximum": 2
          },
          "maxTokens": {
            "type": "number",
            "description": "This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.",
            "minimum": 50,
            "maximum": 10000
          },
          "emotionRecognitionEnabled": {
            "type": "boolean",
            "description": "This determines whether we detect user's emotion while they speak and send it as an additional info to model.\n\nDefault `false` because the model is usually are good at understanding the user's emotion from text.\n\n@default false"
          },
          "numFastTurns": {
            "type": "number",
            "description": "This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.\n\nDefault is 0.\n\n@default 0",
            "minimum": 0
          }
        },
        "required": [
          "model",
          "provider"
        ]
      },
      "InflectionAIModel": {
        "type": "object",
        "properties": {
          "messages": {
            "description": "This is the starting state for the conversation.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            }
          },
          "tools": {
            "type": "array",
            "description": "These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.\n\nBoth `tools` and `toolIds` can be used together.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CreateApiRequestToolDTO",
                  "title": "ApiRequestTool"
                },
                {
                  "$ref": "#/components/schemas/CreateBashToolDTO",
                  "title": "BashTool"
                },
                {
                  "$ref": "#/components/schemas/CreateComputerToolDTO",
                  "title": "ComputerTool"
                },
                {
                  "$ref": "#/components/schemas/CreateDtmfToolDTO",
                  "title": "DtmfTool"
                },
                {
                  "$ref": "#/components/schemas/CreateEndCallToolDTO",
                  "title": "EndCallTool"
                },
                {
                  "$ref": "#/components/schemas/CreateFunctionToolDTO",
                  "title": "FunctionTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                  "title": "GoHighLevelCalendarAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                  "title": "GoHighLevelCalendarEventCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                  "title": "GoHighLevelContactCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactGetToolDTO",
                  "title": "GoHighLevelContactGetTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                  "title": "GoogleCalendarCheckAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                  "title": "GoogleCalendarCreateEventTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                  "title": "GoogleSheetsRowAppendTool"
                },
                {
                  "$ref": "#/components/schemas/CreateMcpToolDTO",
                  "title": "McpTool"
                },
                {
                  "$ref": "#/components/schemas/CreateQueryToolDTO",
                  "title": "QueryTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSlackSendMessageToolDTO",
                  "title": "SlackSendMessageTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSmsToolDTO",
                  "title": "SmsTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTextEditorToolDTO",
                  "title": "TextEditorTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTransferCallToolDTO",
                  "title": "TransferCallTool"
                }
              ]
            }
          },
          "toolIds": {
            "description": "These are the tools that the assistant can use during the call. To use transient tools, use `tools`.\n\nBoth `tools` and `toolIds` can be used together.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "knowledgeBase": {
            "description": "These are the options for the knowledge base.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateCustomKnowledgeBaseDTO",
                "title": "Custom"
              }
            ]
          },
          "knowledgeBaseId": {
            "type": "string",
            "description": "This is the ID of the knowledge base the model will use."
          },
          "model": {
            "type": "string",
            "description": "This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b",
            "enum": [
              "inflection_3_pi"
            ]
          },
          "provider": {
            "type": "string",
            "enum": [
              "inflection-ai"
            ]
          },
          "temperature": {
            "type": "number",
            "description": "This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.",
            "minimum": 0,
            "maximum": 2
          },
          "maxTokens": {
            "type": "number",
            "description": "This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.",
            "minimum": 50,
            "maximum": 10000
          },
          "emotionRecognitionEnabled": {
            "type": "boolean",
            "description": "This determines whether we detect user's emotion while they speak and send it as an additional info to model.\n\nDefault `false` because the model is usually are good at understanding the user's emotion from text.\n\n@default false"
          },
          "numFastTurns": {
            "type": "number",
            "description": "This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.\n\nDefault is 0.\n\n@default 0",
            "minimum": 0
          }
        },
        "required": [
          "model",
          "provider"
        ]
      },
      "OpenAIModel": {
        "type": "object",
        "properties": {
          "messages": {
            "description": "This is the starting state for the conversation.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            }
          },
          "tools": {
            "type": "array",
            "description": "These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.\n\nBoth `tools` and `toolIds` can be used together.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CreateApiRequestToolDTO",
                  "title": "ApiRequestTool"
                },
                {
                  "$ref": "#/components/schemas/CreateBashToolDTO",
                  "title": "BashTool"
                },
                {
                  "$ref": "#/components/schemas/CreateComputerToolDTO",
                  "title": "ComputerTool"
                },
                {
                  "$ref": "#/components/schemas/CreateDtmfToolDTO",
                  "title": "DtmfTool"
                },
                {
                  "$ref": "#/components/schemas/CreateEndCallToolDTO",
                  "title": "EndCallTool"
                },
                {
                  "$ref": "#/components/schemas/CreateFunctionToolDTO",
                  "title": "FunctionTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                  "title": "GoHighLevelCalendarAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                  "title": "GoHighLevelCalendarEventCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                  "title": "GoHighLevelContactCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactGetToolDTO",
                  "title": "GoHighLevelContactGetTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                  "title": "GoogleCalendarCheckAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                  "title": "GoogleCalendarCreateEventTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                  "title": "GoogleSheetsRowAppendTool"
                },
                {
                  "$ref": "#/components/schemas/CreateMcpToolDTO",
                  "title": "McpTool"
                },
                {
                  "$ref": "#/components/schemas/CreateQueryToolDTO",
                  "title": "QueryTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSlackSendMessageToolDTO",
                  "title": "SlackSendMessageTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSmsToolDTO",
                  "title": "SmsTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTextEditorToolDTO",
                  "title": "TextEditorTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTransferCallToolDTO",
                  "title": "TransferCallTool"
                }
              ]
            }
          },
          "toolIds": {
            "description": "These are the tools that the assistant can use during the call. To use transient tools, use `tools`.\n\nBoth `tools` and `toolIds` can be used together.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "knowledgeBase": {
            "description": "These are the options for the knowledge base.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateCustomKnowledgeBaseDTO",
                "title": "Custom"
              }
            ]
          },
          "knowledgeBaseId": {
            "type": "string",
            "description": "This is the ID of the knowledge base the model will use."
          },
          "provider": {
            "type": "string",
            "description": "This is the provider that will be used for the model.",
            "enum": [
              "openai"
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the OpenAI model that will be used.\n\nWhen using Vapi OpenAI or your own Azure Credentials, you have the option to specify the region for the selected model. This shouldn't be specified unless you have a specific reason to do so. Vapi will automatically find the fastest region that make sense.\nThis is helpful when you are required to comply with Data Residency rules. Learn more about Azure regions here https://azure.microsoft.com/en-us/explore/global-infrastructure/data-residency/.\n\n@default undefined",
            "enum": [
              "gpt-4.1-2025-04-14",
              "gpt-4.1-mini-2025-04-14",
              "gpt-4.1-nano-2025-04-14",
              "gpt-4.1",
              "gpt-4.1-mini",
              "gpt-4.1-nano",
              "gpt-4.5-preview",
              "chatgpt-4o-latest",
              "o3",
              "o3-mini",
              "o4-mini",
              "o1-preview",
              "o1-preview-2024-09-12",
              "o1-mini",
              "o1-mini-2024-09-12",
              "gpt-4o-realtime-preview-2024-10-01",
              "gpt-4o-realtime-preview-2024-12-17",
              "gpt-4o-mini-realtime-preview-2024-12-17",
              "gpt-4o-mini-2024-07-18",
              "gpt-4o-mini",
              "gpt-4o",
              "gpt-4o-2024-05-13",
              "gpt-4o-2024-08-06",
              "gpt-4o-2024-11-20",
              "gpt-4-turbo",
              "gpt-4-turbo-2024-04-09",
              "gpt-4-turbo-preview",
              "gpt-4-0125-preview",
              "gpt-4-1106-preview",
              "gpt-4",
              "gpt-4-0613",
              "gpt-3.5-turbo",
              "gpt-3.5-turbo-0125",
              "gpt-3.5-turbo-1106",
              "gpt-3.5-turbo-16k",
              "gpt-3.5-turbo-0613",
              "gpt-4.1-2025-04-14:westus",
              "gpt-4.1-2025-04-14:eastus2",
              "gpt-4.1-2025-04-14:eastus",
              "gpt-4.1-2025-04-14:westus3",
              "gpt-4.1-2025-04-14:northcentralus",
              "gpt-4.1-2025-04-14:southcentralus",
              "gpt-4.1-mini-2025-04-14:westus",
              "gpt-4.1-mini-2025-04-14:eastus2",
              "gpt-4.1-mini-2025-04-14:eastus",
              "gpt-4.1-mini-2025-04-14:westus3",
              "gpt-4.1-mini-2025-04-14:northcentralus",
              "gpt-4.1-mini-2025-04-14:southcentralus",
              "gpt-4.1-nano-2025-04-14:westus",
              "gpt-4.1-nano-2025-04-14:eastus2",
              "gpt-4.1-nano-2025-04-14:westus3",
              "gpt-4.1-nano-2025-04-14:northcentralus",
              "gpt-4.1-nano-2025-04-14:southcentralus",
              "gpt-4o-2024-11-20:swedencentral",
              "gpt-4o-2024-11-20:westus",
              "gpt-4o-2024-11-20:eastus2",
              "gpt-4o-2024-11-20:eastus",
              "gpt-4o-2024-11-20:westus3",
              "gpt-4o-2024-11-20:southcentralus",
              "gpt-4o-2024-08-06:westus",
              "gpt-4o-2024-08-06:westus3",
              "gpt-4o-2024-08-06:eastus",
              "gpt-4o-2024-08-06:eastus2",
              "gpt-4o-2024-08-06:northcentralus",
              "gpt-4o-2024-08-06:southcentralus",
              "gpt-4o-mini-2024-07-18:westus",
              "gpt-4o-mini-2024-07-18:westus3",
              "gpt-4o-mini-2024-07-18:eastus",
              "gpt-4o-mini-2024-07-18:eastus2",
              "gpt-4o-mini-2024-07-18:northcentralus",
              "gpt-4o-mini-2024-07-18:southcentralus",
              "gpt-4o-2024-05-13:eastus2",
              "gpt-4o-2024-05-13:eastus",
              "gpt-4o-2024-05-13:northcentralus",
              "gpt-4o-2024-05-13:southcentralus",
              "gpt-4o-2024-05-13:westus3",
              "gpt-4o-2024-05-13:westus",
              "gpt-4-turbo-2024-04-09:eastus2",
              "gpt-4-0125-preview:eastus",
              "gpt-4-0125-preview:northcentralus",
              "gpt-4-0125-preview:southcentralus",
              "gpt-4-1106-preview:australia",
              "gpt-4-1106-preview:canadaeast",
              "gpt-4-1106-preview:france",
              "gpt-4-1106-preview:india",
              "gpt-4-1106-preview:norway",
              "gpt-4-1106-preview:swedencentral",
              "gpt-4-1106-preview:uk",
              "gpt-4-1106-preview:westus",
              "gpt-4-1106-preview:westus3",
              "gpt-4-0613:canadaeast",
              "gpt-3.5-turbo-0125:canadaeast",
              "gpt-3.5-turbo-0125:northcentralus",
              "gpt-3.5-turbo-0125:southcentralus",
              "gpt-3.5-turbo-1106:canadaeast",
              "gpt-3.5-turbo-1106:westus"
            ]
          },
          "fallbackModels": {
            "type": "array",
            "description": "These are the fallback models that will be used if the primary model fails. This shouldn't be specified unless you have a specific reason to do so. Vapi will automatically find the fastest fallbacks that make sense.",
            "enum": [
              "gpt-4.1-2025-04-14",
              "gpt-4.1-mini-2025-04-14",
              "gpt-4.1-nano-2025-04-14",
              "gpt-4.1",
              "gpt-4.1-mini",
              "gpt-4.1-nano",
              "gpt-4.5-preview",
              "chatgpt-4o-latest",
              "o3",
              "o3-mini",
              "o4-mini",
              "o1-preview",
              "o1-preview-2024-09-12",
              "o1-mini",
              "o1-mini-2024-09-12",
              "gpt-4o-realtime-preview-2024-10-01",
              "gpt-4o-realtime-preview-2024-12-17",
              "gpt-4o-mini-realtime-preview-2024-12-17",
              "gpt-4o-mini-2024-07-18",
              "gpt-4o-mini",
              "gpt-4o",
              "gpt-4o-2024-05-13",
              "gpt-4o-2024-08-06",
              "gpt-4o-2024-11-20",
              "gpt-4-turbo",
              "gpt-4-turbo-2024-04-09",
              "gpt-4-turbo-preview",
              "gpt-4-0125-preview",
              "gpt-4-1106-preview",
              "gpt-4",
              "gpt-4-0613",
              "gpt-3.5-turbo",
              "gpt-3.5-turbo-0125",
              "gpt-3.5-turbo-1106",
              "gpt-3.5-turbo-16k",
              "gpt-3.5-turbo-0613",
              "gpt-4.1-2025-04-14:westus",
              "gpt-4.1-2025-04-14:eastus2",
              "gpt-4.1-2025-04-14:eastus",
              "gpt-4.1-2025-04-14:westus3",
              "gpt-4.1-2025-04-14:northcentralus",
              "gpt-4.1-2025-04-14:southcentralus",
              "gpt-4.1-mini-2025-04-14:westus",
              "gpt-4.1-mini-2025-04-14:eastus2",
              "gpt-4.1-mini-2025-04-14:eastus",
              "gpt-4.1-mini-2025-04-14:westus3",
              "gpt-4.1-mini-2025-04-14:northcentralus",
              "gpt-4.1-mini-2025-04-14:southcentralus",
              "gpt-4.1-nano-2025-04-14:westus",
              "gpt-4.1-nano-2025-04-14:eastus2",
              "gpt-4.1-nano-2025-04-14:westus3",
              "gpt-4.1-nano-2025-04-14:northcentralus",
              "gpt-4.1-nano-2025-04-14:southcentralus",
              "gpt-4o-2024-11-20:swedencentral",
              "gpt-4o-2024-11-20:westus",
              "gpt-4o-2024-11-20:eastus2",
              "gpt-4o-2024-11-20:eastus",
              "gpt-4o-2024-11-20:westus3",
              "gpt-4o-2024-11-20:southcentralus",
              "gpt-4o-2024-08-06:westus",
              "gpt-4o-2024-08-06:westus3",
              "gpt-4o-2024-08-06:eastus",
              "gpt-4o-2024-08-06:eastus2",
              "gpt-4o-2024-08-06:northcentralus",
              "gpt-4o-2024-08-06:southcentralus",
              "gpt-4o-mini-2024-07-18:westus",
              "gpt-4o-mini-2024-07-18:westus3",
              "gpt-4o-mini-2024-07-18:eastus",
              "gpt-4o-mini-2024-07-18:eastus2",
              "gpt-4o-mini-2024-07-18:northcentralus",
              "gpt-4o-mini-2024-07-18:southcentralus",
              "gpt-4o-2024-05-13:eastus2",
              "gpt-4o-2024-05-13:eastus",
              "gpt-4o-2024-05-13:northcentralus",
              "gpt-4o-2024-05-13:southcentralus",
              "gpt-4o-2024-05-13:westus3",
              "gpt-4o-2024-05-13:westus",
              "gpt-4-turbo-2024-04-09:eastus2",
              "gpt-4-0125-preview:eastus",
              "gpt-4-0125-preview:northcentralus",
              "gpt-4-0125-preview:southcentralus",
              "gpt-4-1106-preview:australia",
              "gpt-4-1106-preview:canadaeast",
              "gpt-4-1106-preview:france",
              "gpt-4-1106-preview:india",
              "gpt-4-1106-preview:norway",
              "gpt-4-1106-preview:swedencentral",
              "gpt-4-1106-preview:uk",
              "gpt-4-1106-preview:westus",
              "gpt-4-1106-preview:westus3",
              "gpt-4-0613:canadaeast",
              "gpt-3.5-turbo-0125:canadaeast",
              "gpt-3.5-turbo-0125:northcentralus",
              "gpt-3.5-turbo-0125:southcentralus",
              "gpt-3.5-turbo-1106:canadaeast",
              "gpt-3.5-turbo-1106:westus"
            ],
            "example": [
              "gpt-4-0125-preview",
              "gpt-4-0613"
            ],
            "items": {
              "type": "string",
              "enum": [
                "gpt-4.1-2025-04-14",
                "gpt-4.1-mini-2025-04-14",
                "gpt-4.1-nano-2025-04-14",
                "gpt-4.1",
                "gpt-4.1-mini",
                "gpt-4.1-nano",
                "gpt-4.5-preview",
                "chatgpt-4o-latest",
                "o3",
                "o3-mini",
                "o4-mini",
                "o1-preview",
                "o1-preview-2024-09-12",
                "o1-mini",
                "o1-mini-2024-09-12",
                "gpt-4o-realtime-preview-2024-10-01",
                "gpt-4o-realtime-preview-2024-12-17",
                "gpt-4o-mini-realtime-preview-2024-12-17",
                "gpt-4o-mini-2024-07-18",
                "gpt-4o-mini",
                "gpt-4o",
                "gpt-4o-2024-05-13",
                "gpt-4o-2024-08-06",
                "gpt-4o-2024-11-20",
                "gpt-4-turbo",
                "gpt-4-turbo-2024-04-09",
                "gpt-4-turbo-preview",
                "gpt-4-0125-preview",
                "gpt-4-1106-preview",
                "gpt-4",
                "gpt-4-0613",
                "gpt-3.5-turbo",
                "gpt-3.5-turbo-0125",
                "gpt-3.5-turbo-1106",
                "gpt-3.5-turbo-16k",
                "gpt-3.5-turbo-0613",
                "gpt-4.1-2025-04-14:westus",
                "gpt-4.1-2025-04-14:eastus2",
                "gpt-4.1-2025-04-14:eastus",
                "gpt-4.1-2025-04-14:westus3",
                "gpt-4.1-2025-04-14:northcentralus",
                "gpt-4.1-2025-04-14:southcentralus",
                "gpt-4.1-mini-2025-04-14:westus",
                "gpt-4.1-mini-2025-04-14:eastus2",
                "gpt-4.1-mini-2025-04-14:eastus",
                "gpt-4.1-mini-2025-04-14:westus3",
                "gpt-4.1-mini-2025-04-14:northcentralus",
                "gpt-4.1-mini-2025-04-14:southcentralus",
                "gpt-4.1-nano-2025-04-14:westus",
                "gpt-4.1-nano-2025-04-14:eastus2",
                "gpt-4.1-nano-2025-04-14:westus3",
                "gpt-4.1-nano-2025-04-14:northcentralus",
                "gpt-4.1-nano-2025-04-14:southcentralus",
                "gpt-4o-2024-11-20:swedencentral",
                "gpt-4o-2024-11-20:westus",
                "gpt-4o-2024-11-20:eastus2",
                "gpt-4o-2024-11-20:eastus",
                "gpt-4o-2024-11-20:westus3",
                "gpt-4o-2024-11-20:southcentralus",
                "gpt-4o-2024-08-06:westus",
                "gpt-4o-2024-08-06:westus3",
                "gpt-4o-2024-08-06:eastus",
                "gpt-4o-2024-08-06:eastus2",
                "gpt-4o-2024-08-06:northcentralus",
                "gpt-4o-2024-08-06:southcentralus",
                "gpt-4o-mini-2024-07-18:westus",
                "gpt-4o-mini-2024-07-18:westus3",
                "gpt-4o-mini-2024-07-18:eastus",
                "gpt-4o-mini-2024-07-18:eastus2",
                "gpt-4o-mini-2024-07-18:northcentralus",
                "gpt-4o-mini-2024-07-18:southcentralus",
                "gpt-4o-2024-05-13:eastus2",
                "gpt-4o-2024-05-13:eastus",
                "gpt-4o-2024-05-13:northcentralus",
                "gpt-4o-2024-05-13:southcentralus",
                "gpt-4o-2024-05-13:westus3",
                "gpt-4o-2024-05-13:westus",
                "gpt-4-turbo-2024-04-09:eastus2",
                "gpt-4-0125-preview:eastus",
                "gpt-4-0125-preview:northcentralus",
                "gpt-4-0125-preview:southcentralus",
                "gpt-4-1106-preview:australia",
                "gpt-4-1106-preview:canadaeast",
                "gpt-4-1106-preview:france",
                "gpt-4-1106-preview:india",
                "gpt-4-1106-preview:norway",
                "gpt-4-1106-preview:swedencentral",
                "gpt-4-1106-preview:uk",
                "gpt-4-1106-preview:westus",
                "gpt-4-1106-preview:westus3",
                "gpt-4-0613:canadaeast",
                "gpt-3.5-turbo-0125:canadaeast",
                "gpt-3.5-turbo-0125:northcentralus",
                "gpt-3.5-turbo-0125:southcentralus",
                "gpt-3.5-turbo-1106:canadaeast",
                "gpt-3.5-turbo-1106:westus"
              ]
            }
          },
          "toolStrictCompatibilityMode": {
            "type": "string",
            "description": "Azure OpenAI doesn't support `maxLength` right now https://learn.microsoft.com/en-us/azure/ai-services/openai/how-to/structured-outputs?tabs=python-secure%2Cdotnet-entra-id&pivots=programming-language-csharp#unsupported-type-specific-keywords. Need to strip.\n\n- `strip-parameters-with-unsupported-validation` will strip parameters with unsupported validation.\n- `strip-unsupported-validation` will keep the parameters but strip unsupported validation.\n\n@default `strip-unsupported-validation`",
            "enum": [
              "strip-parameters-with-unsupported-validation",
              "strip-unsupported-validation"
            ]
          },
          "temperature": {
            "type": "number",
            "description": "This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.",
            "minimum": 0,
            "maximum": 2
          },
          "maxTokens": {
            "type": "number",
            "description": "This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.",
            "minimum": 50,
            "maximum": 10000
          },
          "emotionRecognitionEnabled": {
            "type": "boolean",
            "description": "This determines whether we detect user's emotion while they speak and send it as an additional info to model.\n\nDefault `false` because the model is usually are good at understanding the user's emotion from text.\n\n@default false"
          },
          "numFastTurns": {
            "type": "number",
            "description": "This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.\n\nDefault is 0.\n\n@default 0",
            "minimum": 0
          }
        },
        "required": [
          "provider",
          "model"
        ]
      },
      "OpenRouterModel": {
        "type": "object",
        "properties": {
          "messages": {
            "description": "This is the starting state for the conversation.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            }
          },
          "tools": {
            "type": "array",
            "description": "These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.\n\nBoth `tools` and `toolIds` can be used together.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CreateApiRequestToolDTO",
                  "title": "ApiRequestTool"
                },
                {
                  "$ref": "#/components/schemas/CreateBashToolDTO",
                  "title": "BashTool"
                },
                {
                  "$ref": "#/components/schemas/CreateComputerToolDTO",
                  "title": "ComputerTool"
                },
                {
                  "$ref": "#/components/schemas/CreateDtmfToolDTO",
                  "title": "DtmfTool"
                },
                {
                  "$ref": "#/components/schemas/CreateEndCallToolDTO",
                  "title": "EndCallTool"
                },
                {
                  "$ref": "#/components/schemas/CreateFunctionToolDTO",
                  "title": "FunctionTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                  "title": "GoHighLevelCalendarAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                  "title": "GoHighLevelCalendarEventCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                  "title": "GoHighLevelContactCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactGetToolDTO",
                  "title": "GoHighLevelContactGetTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                  "title": "GoogleCalendarCheckAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                  "title": "GoogleCalendarCreateEventTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                  "title": "GoogleSheetsRowAppendTool"
                },
                {
                  "$ref": "#/components/schemas/CreateMcpToolDTO",
                  "title": "McpTool"
                },
                {
                  "$ref": "#/components/schemas/CreateQueryToolDTO",
                  "title": "QueryTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSlackSendMessageToolDTO",
                  "title": "SlackSendMessageTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSmsToolDTO",
                  "title": "SmsTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTextEditorToolDTO",
                  "title": "TextEditorTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTransferCallToolDTO",
                  "title": "TransferCallTool"
                }
              ]
            }
          },
          "toolIds": {
            "description": "These are the tools that the assistant can use during the call. To use transient tools, use `tools`.\n\nBoth `tools` and `toolIds` can be used together.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "knowledgeBase": {
            "description": "These are the options for the knowledge base.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateCustomKnowledgeBaseDTO",
                "title": "Custom"
              }
            ]
          },
          "knowledgeBaseId": {
            "type": "string",
            "description": "This is the ID of the knowledge base the model will use."
          },
          "provider": {
            "type": "string",
            "enum": [
              "openrouter"
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b"
          },
          "temperature": {
            "type": "number",
            "description": "This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.",
            "minimum": 0,
            "maximum": 2
          },
          "maxTokens": {
            "type": "number",
            "description": "This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.",
            "minimum": 50,
            "maximum": 10000
          },
          "emotionRecognitionEnabled": {
            "type": "boolean",
            "description": "This determines whether we detect user's emotion while they speak and send it as an additional info to model.\n\nDefault `false` because the model is usually are good at understanding the user's emotion from text.\n\n@default false"
          },
          "numFastTurns": {
            "type": "number",
            "description": "This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.\n\nDefault is 0.\n\n@default 0",
            "minimum": 0
          }
        },
        "required": [
          "provider",
          "model"
        ]
      },
      "PerplexityAIModel": {
        "type": "object",
        "properties": {
          "messages": {
            "description": "This is the starting state for the conversation.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            }
          },
          "tools": {
            "type": "array",
            "description": "These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.\n\nBoth `tools` and `toolIds` can be used together.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CreateApiRequestToolDTO",
                  "title": "ApiRequestTool"
                },
                {
                  "$ref": "#/components/schemas/CreateBashToolDTO",
                  "title": "BashTool"
                },
                {
                  "$ref": "#/components/schemas/CreateComputerToolDTO",
                  "title": "ComputerTool"
                },
                {
                  "$ref": "#/components/schemas/CreateDtmfToolDTO",
                  "title": "DtmfTool"
                },
                {
                  "$ref": "#/components/schemas/CreateEndCallToolDTO",
                  "title": "EndCallTool"
                },
                {
                  "$ref": "#/components/schemas/CreateFunctionToolDTO",
                  "title": "FunctionTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                  "title": "GoHighLevelCalendarAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                  "title": "GoHighLevelCalendarEventCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                  "title": "GoHighLevelContactCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactGetToolDTO",
                  "title": "GoHighLevelContactGetTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                  "title": "GoogleCalendarCheckAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                  "title": "GoogleCalendarCreateEventTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                  "title": "GoogleSheetsRowAppendTool"
                },
                {
                  "$ref": "#/components/schemas/CreateMcpToolDTO",
                  "title": "McpTool"
                },
                {
                  "$ref": "#/components/schemas/CreateQueryToolDTO",
                  "title": "QueryTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSlackSendMessageToolDTO",
                  "title": "SlackSendMessageTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSmsToolDTO",
                  "title": "SmsTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTextEditorToolDTO",
                  "title": "TextEditorTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTransferCallToolDTO",
                  "title": "TransferCallTool"
                }
              ]
            }
          },
          "toolIds": {
            "description": "These are the tools that the assistant can use during the call. To use transient tools, use `tools`.\n\nBoth `tools` and `toolIds` can be used together.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "knowledgeBase": {
            "description": "These are the options for the knowledge base.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateCustomKnowledgeBaseDTO",
                "title": "Custom"
              }
            ]
          },
          "knowledgeBaseId": {
            "type": "string",
            "description": "This is the ID of the knowledge base the model will use."
          },
          "provider": {
            "type": "string",
            "enum": [
              "perplexity-ai"
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b"
          },
          "temperature": {
            "type": "number",
            "description": "This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.",
            "minimum": 0,
            "maximum": 2
          },
          "maxTokens": {
            "type": "number",
            "description": "This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.",
            "minimum": 50,
            "maximum": 10000
          },
          "emotionRecognitionEnabled": {
            "type": "boolean",
            "description": "This determines whether we detect user's emotion while they speak and send it as an additional info to model.\n\nDefault `false` because the model is usually are good at understanding the user's emotion from text.\n\n@default false"
          },
          "numFastTurns": {
            "type": "number",
            "description": "This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.\n\nDefault is 0.\n\n@default 0",
            "minimum": 0
          }
        },
        "required": [
          "provider",
          "model"
        ]
      },
      "TogetherAIModel": {
        "type": "object",
        "properties": {
          "messages": {
            "description": "This is the starting state for the conversation.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            }
          },
          "tools": {
            "type": "array",
            "description": "These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.\n\nBoth `tools` and `toolIds` can be used together.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CreateApiRequestToolDTO",
                  "title": "ApiRequestTool"
                },
                {
                  "$ref": "#/components/schemas/CreateBashToolDTO",
                  "title": "BashTool"
                },
                {
                  "$ref": "#/components/schemas/CreateComputerToolDTO",
                  "title": "ComputerTool"
                },
                {
                  "$ref": "#/components/schemas/CreateDtmfToolDTO",
                  "title": "DtmfTool"
                },
                {
                  "$ref": "#/components/schemas/CreateEndCallToolDTO",
                  "title": "EndCallTool"
                },
                {
                  "$ref": "#/components/schemas/CreateFunctionToolDTO",
                  "title": "FunctionTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                  "title": "GoHighLevelCalendarAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                  "title": "GoHighLevelCalendarEventCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                  "title": "GoHighLevelContactCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactGetToolDTO",
                  "title": "GoHighLevelContactGetTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                  "title": "GoogleCalendarCheckAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                  "title": "GoogleCalendarCreateEventTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                  "title": "GoogleSheetsRowAppendTool"
                },
                {
                  "$ref": "#/components/schemas/CreateMcpToolDTO",
                  "title": "McpTool"
                },
                {
                  "$ref": "#/components/schemas/CreateQueryToolDTO",
                  "title": "QueryTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSlackSendMessageToolDTO",
                  "title": "SlackSendMessageTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSmsToolDTO",
                  "title": "SmsTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTextEditorToolDTO",
                  "title": "TextEditorTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTransferCallToolDTO",
                  "title": "TransferCallTool"
                }
              ]
            }
          },
          "toolIds": {
            "description": "These are the tools that the assistant can use during the call. To use transient tools, use `tools`.\n\nBoth `tools` and `toolIds` can be used together.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "knowledgeBase": {
            "description": "These are the options for the knowledge base.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateCustomKnowledgeBaseDTO",
                "title": "Custom"
              }
            ]
          },
          "knowledgeBaseId": {
            "type": "string",
            "description": "This is the ID of the knowledge base the model will use."
          },
          "provider": {
            "type": "string",
            "enum": [
              "together-ai"
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b"
          },
          "temperature": {
            "type": "number",
            "description": "This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.",
            "minimum": 0,
            "maximum": 2
          },
          "maxTokens": {
            "type": "number",
            "description": "This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.",
            "minimum": 50,
            "maximum": 10000
          },
          "emotionRecognitionEnabled": {
            "type": "boolean",
            "description": "This determines whether we detect user's emotion while they speak and send it as an additional info to model.\n\nDefault `false` because the model is usually are good at understanding the user's emotion from text.\n\n@default false"
          },
          "numFastTurns": {
            "type": "number",
            "description": "This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.\n\nDefault is 0.\n\n@default 0",
            "minimum": 0
          }
        },
        "required": [
          "provider",
          "model"
        ]
      },
      "HangupNode": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "hangup"
            ]
          },
          "name": {
            "type": "string",
            "maxLength": 80
          },
          "isStart": {
            "type": "boolean",
            "description": "This is whether or not the node is the start of the workflow."
          },
          "metadata": {
            "type": "object",
            "description": "This is for metadata you want to store on the task."
          }
        },
        "required": [
          "type",
          "name"
        ]
      },
      "WorkflowOpenAIModel": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the provider of the model (`openai`).",
            "enum": [
              "openai"
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the OpenAI model that will be used.\n\nWhen using Vapi OpenAI or your own Azure Credentials, you have the option to specify the region for the selected model. This shouldn't be specified unless you have a specific reason to do so. Vapi will automatically find the fastest region that make sense.\nThis is helpful when you are required to comply with Data Residency rules. Learn more about Azure regions here https://azure.microsoft.com/en-us/explore/global-infrastructure/data-residency/.",
            "maxLength": 100,
            "enum": [
              "gpt-4.1-2025-04-14",
              "gpt-4.1-mini-2025-04-14",
              "gpt-4.1-nano-2025-04-14",
              "gpt-4.1",
              "gpt-4.1-mini",
              "gpt-4.1-nano",
              "gpt-4.5-preview",
              "chatgpt-4o-latest",
              "o3",
              "o3-mini",
              "o4-mini",
              "o1-preview",
              "o1-preview-2024-09-12",
              "o1-mini",
              "o1-mini-2024-09-12",
              "gpt-4o-realtime-preview-2024-10-01",
              "gpt-4o-realtime-preview-2024-12-17",
              "gpt-4o-mini-realtime-preview-2024-12-17",
              "gpt-4o-mini-2024-07-18",
              "gpt-4o-mini",
              "gpt-4o",
              "gpt-4o-2024-05-13",
              "gpt-4o-2024-08-06",
              "gpt-4o-2024-11-20",
              "gpt-4-turbo",
              "gpt-4-turbo-2024-04-09",
              "gpt-4-turbo-preview",
              "gpt-4-0125-preview",
              "gpt-4-1106-preview",
              "gpt-4",
              "gpt-4-0613",
              "gpt-3.5-turbo",
              "gpt-3.5-turbo-0125",
              "gpt-3.5-turbo-1106",
              "gpt-3.5-turbo-16k",
              "gpt-3.5-turbo-0613",
              "gpt-4.1-2025-04-14:westus",
              "gpt-4.1-2025-04-14:eastus2",
              "gpt-4.1-2025-04-14:eastus",
              "gpt-4.1-2025-04-14:westus3",
              "gpt-4.1-2025-04-14:northcentralus",
              "gpt-4.1-2025-04-14:southcentralus",
              "gpt-4.1-mini-2025-04-14:westus",
              "gpt-4.1-mini-2025-04-14:eastus2",
              "gpt-4.1-mini-2025-04-14:eastus",
              "gpt-4.1-mini-2025-04-14:westus3",
              "gpt-4.1-mini-2025-04-14:northcentralus",
              "gpt-4.1-mini-2025-04-14:southcentralus",
              "gpt-4.1-nano-2025-04-14:westus",
              "gpt-4.1-nano-2025-04-14:eastus2",
              "gpt-4.1-nano-2025-04-14:westus3",
              "gpt-4.1-nano-2025-04-14:northcentralus",
              "gpt-4.1-nano-2025-04-14:southcentralus",
              "gpt-4o-2024-11-20:swedencentral",
              "gpt-4o-2024-11-20:westus",
              "gpt-4o-2024-11-20:eastus2",
              "gpt-4o-2024-11-20:eastus",
              "gpt-4o-2024-11-20:westus3",
              "gpt-4o-2024-11-20:southcentralus",
              "gpt-4o-2024-08-06:westus",
              "gpt-4o-2024-08-06:westus3",
              "gpt-4o-2024-08-06:eastus",
              "gpt-4o-2024-08-06:eastus2",
              "gpt-4o-2024-08-06:northcentralus",
              "gpt-4o-2024-08-06:southcentralus",
              "gpt-4o-mini-2024-07-18:westus",
              "gpt-4o-mini-2024-07-18:westus3",
              "gpt-4o-mini-2024-07-18:eastus",
              "gpt-4o-mini-2024-07-18:eastus2",
              "gpt-4o-mini-2024-07-18:northcentralus",
              "gpt-4o-mini-2024-07-18:southcentralus",
              "gpt-4o-2024-05-13:eastus2",
              "gpt-4o-2024-05-13:eastus",
              "gpt-4o-2024-05-13:northcentralus",
              "gpt-4o-2024-05-13:southcentralus",
              "gpt-4o-2024-05-13:westus3",
              "gpt-4o-2024-05-13:westus",
              "gpt-4-turbo-2024-04-09:eastus2",
              "gpt-4-0125-preview:eastus",
              "gpt-4-0125-preview:northcentralus",
              "gpt-4-0125-preview:southcentralus",
              "gpt-4-1106-preview:australia",
              "gpt-4-1106-preview:canadaeast",
              "gpt-4-1106-preview:france",
              "gpt-4-1106-preview:india",
              "gpt-4-1106-preview:norway",
              "gpt-4-1106-preview:swedencentral",
              "gpt-4-1106-preview:uk",
              "gpt-4-1106-preview:westus",
              "gpt-4-1106-preview:westus3",
              "gpt-4-0613:canadaeast",
              "gpt-3.5-turbo-0125:canadaeast",
              "gpt-3.5-turbo-0125:northcentralus",
              "gpt-3.5-turbo-0125:southcentralus",
              "gpt-3.5-turbo-1106:canadaeast",
              "gpt-3.5-turbo-1106:westus"
            ]
          },
          "temperature": {
            "type": "number",
            "description": "This is the temperature of the model.",
            "minimum": 0,
            "maximum": 2
          },
          "maxTokens": {
            "type": "number",
            "description": "This is the max tokens of the model.",
            "minimum": 50,
            "maximum": 10000
          }
        },
        "required": [
          "provider",
          "model"
        ]
      },
      "WorkflowAnthropicModel": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the provider of the model (`anthropic`).",
            "enum": [
              "anthropic"
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the specific model that will be used.",
            "maxLength": 100,
            "enum": [
              "claude-3-opus-20240229",
              "claude-3-sonnet-20240229",
              "claude-3-haiku-20240307",
              "claude-3-5-sonnet-20240620",
              "claude-3-5-sonnet-20241022",
              "claude-3-5-haiku-20241022",
              "claude-3-7-sonnet-20250219",
              "claude-opus-4-20250514",
              "claude-sonnet-4-20250514"
            ]
          },
          "thinking": {
            "description": "This is the optional configuration for Anthropic's thinking feature.\n\n- Only applicable for `claude-3-7-sonnet-20250219` model.\n- If provided, `maxTokens` must be greater than `thinking.budgetTokens`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnthropicThinkingConfig"
              }
            ]
          },
          "temperature": {
            "type": "number",
            "description": "This is the temperature of the model.",
            "minimum": 0,
            "maximum": 2
          },
          "maxTokens": {
            "type": "number",
            "description": "This is the max tokens of the model.",
            "minimum": 50,
            "maximum": 10000
          }
        },
        "required": [
          "provider",
          "model"
        ]
      },
      "GlobalNodePlan": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "This is the flag to determine if this node is a global node\n\n@default false",
            "default": false
          },
          "enterCondition": {
            "type": "string",
            "description": "This is the condition that will be checked to determine if the global node should be executed.\n\n@default ''",
            "maxLength": 1000,
            "default": ""
          }
        }
      },
      "VariableExtractionPlan": {
        "type": "object",
        "properties": {}
      },
      "ConversationNode": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the Conversation node. This can be used to start a conversation with the customer.\n\nThe flow is:\n- Workflow starts the conversation node\n- Model is active with the `prompt` and global context.\n- Model will call a tool to exit this node.\n- Workflow will extract variables from the conversation.\n- Workflow continues.",
            "enum": [
              "conversation"
            ]
          },
          "model": {
            "description": "This is the model for the Conversation Task.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/WorkflowOpenAIModel",
                "title": "OpenAI"
              },
              {
                "$ref": "#/components/schemas/WorkflowAnthropicModel",
                "title": "Anthropic"
              }
            ]
          },
          "transcriber": {
            "description": "These are the options for the assistant's transcriber.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/AssemblyAITranscriber",
                "title": "AssemblyAITranscriber"
              },
              {
                "$ref": "#/components/schemas/AzureSpeechTranscriber",
                "title": "AzureSpeechTranscriber"
              },
              {
                "$ref": "#/components/schemas/CustomTranscriber",
                "title": "CustomTranscriber"
              },
              {
                "$ref": "#/components/schemas/DeepgramTranscriber",
                "title": "DeepgramTranscriber"
              },
              {
                "$ref": "#/components/schemas/ElevenLabsTranscriber",
                "title": "ElevenLabsTranscriber"
              },
              {
                "$ref": "#/components/schemas/GladiaTranscriber",
                "title": "GladiaTranscriber"
              },
              {
                "$ref": "#/components/schemas/GoogleTranscriber",
                "title": "GoogleTranscriber"
              },
              {
                "$ref": "#/components/schemas/SpeechmaticsTranscriber",
                "title": "SpeechmaticsTranscriber"
              },
              {
                "$ref": "#/components/schemas/TalkscriberTranscriber",
                "title": "TalkscriberTranscriber"
              },
              {
                "$ref": "#/components/schemas/OpenAITranscriber",
                "title": "OpenAITranscriber"
              }
            ]
          },
          "voice": {
            "description": "These are the options for the assistant's voice.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/AzureVoice",
                "title": "AzureVoice"
              },
              {
                "$ref": "#/components/schemas/CartesiaVoice",
                "title": "CartesiaVoice"
              },
              {
                "$ref": "#/components/schemas/CustomVoice",
                "title": "CustomVoice"
              },
              {
                "$ref": "#/components/schemas/DeepgramVoice",
                "title": "DeepgramVoice"
              },
              {
                "$ref": "#/components/schemas/ElevenLabsVoice",
                "title": "ElevenLabsVoice"
              },
              {
                "$ref": "#/components/schemas/HumeVoice",
                "title": "HumeVoice"
              },
              {
                "$ref": "#/components/schemas/LMNTVoice",
                "title": "LMNTVoice"
              },
              {
                "$ref": "#/components/schemas/NeuphonicVoice",
                "title": "NeuphonicVoice"
              },
              {
                "$ref": "#/components/schemas/OpenAIVoice",
                "title": "OpenAIVoice"
              },
              {
                "$ref": "#/components/schemas/PlayHTVoice",
                "title": "PlayHTVoice"
              },
              {
                "$ref": "#/components/schemas/RimeAIVoice",
                "title": "RimeAIVoice"
              },
              {
                "$ref": "#/components/schemas/SmallestAIVoice",
                "title": "SmallestAIVoice"
              },
              {
                "$ref": "#/components/schemas/TavusVoice",
                "title": "TavusVoice"
              },
              {
                "$ref": "#/components/schemas/VapiVoice",
                "title": "VapiVoice"
              },
              {
                "$ref": "#/components/schemas/SesameVoice",
                "title": "SesameVoice"
              }
            ]
          },
          "prompt": {
            "type": "string",
            "maxLength": 5000
          },
          "globalNodePlan": {
            "description": "This is the plan for the global node.",
            "allOf": [
              {
                "$ref": "#/components/schemas/GlobalNodePlan"
              }
            ]
          },
          "variableExtractionPlan": {
            "description": "This is the plan that controls the variable extraction from the user's response.",
            "allOf": [
              {
                "$ref": "#/components/schemas/VariableExtractionPlan"
              }
            ]
          },
          "name": {
            "type": "string",
            "maxLength": 80
          },
          "isStart": {
            "type": "boolean",
            "description": "This is whether or not the node is the start of the workflow."
          },
          "metadata": {
            "type": "object",
            "description": "This is for metadata you want to store on the task."
          }
        },
        "required": [
          "type",
          "name"
        ]
      },
      "ToolNode": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the Tool node. This can be used to call a tool in your workflow.\n\nThe flow is:\n- Workflow starts the tool node\n- Model is called to extract parameters needed by the tool from the conversation history\n- Tool is called with the parameters\n- Server returns a response\n- Workflow continues with the response",
            "enum": [
              "tool"
            ]
          },
          "tool": {
            "description": "This is the tool to call. To use an existing tool, send `toolId` instead.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateApiRequestToolDTO",
                "title": "ApiRequestTool"
              },
              {
                "$ref": "#/components/schemas/CreateBashToolDTO",
                "title": "BashTool"
              },
              {
                "$ref": "#/components/schemas/CreateComputerToolDTO",
                "title": "ComputerTool"
              },
              {
                "$ref": "#/components/schemas/CreateDtmfToolDTO",
                "title": "DtmfTool"
              },
              {
                "$ref": "#/components/schemas/CreateEndCallToolDTO",
                "title": "EndCallTool"
              },
              {
                "$ref": "#/components/schemas/CreateFunctionToolDTO",
                "title": "FunctionTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                "title": "GoHighLevelCalendarAvailabilityTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                "title": "GoHighLevelCalendarEventCreateTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                "title": "GoHighLevelContactCreateTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoHighLevelContactGetToolDTO",
                "title": "GoHighLevelContactGetTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                "title": "GoogleCalendarCheckAvailabilityTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                "title": "GoogleCalendarCreateEventTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                "title": "GoogleSheetsRowAppendTool"
              },
              {
                "$ref": "#/components/schemas/CreateMcpToolDTO",
                "title": "McpTool"
              },
              {
                "$ref": "#/components/schemas/CreateQueryToolDTO",
                "title": "QueryTool"
              },
              {
                "$ref": "#/components/schemas/CreateSlackSendMessageToolDTO",
                "title": "SlackSendMessageTool"
              },
              {
                "$ref": "#/components/schemas/CreateSmsToolDTO",
                "title": "SmsTool"
              },
              {
                "$ref": "#/components/schemas/CreateTextEditorToolDTO",
                "title": "TextEditorTool"
              },
              {
                "$ref": "#/components/schemas/CreateTransferCallToolDTO",
                "title": "TransferCallTool"
              }
            ]
          },
          "toolId": {
            "type": "string",
            "description": "This is the tool to call. To use a transient tool, send `tool` instead."
          },
          "name": {
            "type": "string",
            "maxLength": 80
          },
          "isStart": {
            "type": "boolean",
            "description": "This is whether or not the node is the start of the workflow."
          },
          "metadata": {
            "type": "object",
            "description": "This is for metadata you want to store on the task."
          }
        },
        "required": [
          "type",
          "name"
        ]
      },
      "AIEdgeCondition": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "ai"
            ]
          },
          "prompt": {
            "type": "string",
            "description": "This is the prompt for the AI edge condition. It should evaluate to a boolean.",
            "maxLength": 1000
          }
        },
        "required": [
          "type",
          "prompt"
        ]
      },
      "LogicEdgeCondition": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "logic"
            ]
          },
          "liquid": {
            "type": "string",
            "maxLength": 1000
          }
        },
        "required": [
          "type",
          "liquid"
        ]
      },
      "FailedEdgeCondition": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "failed"
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "Edge": {
        "type": "object",
        "properties": {
          "condition": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/AIEdgeCondition",
                "title": "AIEdgeCondition"
              },
              {
                "$ref": "#/components/schemas/LogicEdgeCondition",
                "title": "LogicEdgeCondition"
              },
              {
                "$ref": "#/components/schemas/FailedEdgeCondition",
                "title": "FailedEdgeCondition"
              }
            ]
          },
          "from": {
            "type": "string",
            "maxLength": 80
          },
          "to": {
            "type": "string",
            "maxLength": 80
          },
          "metadata": {
            "type": "object",
            "description": "This is for metadata you want to store on the edge."
          }
        },
        "required": [
          "from",
          "to"
        ]
      },
      "WorkflowUserEditable": {
        "type": "object",
        "properties": {
          "nodes": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ConversationNode",
                  "title": "ConversationNode"
                },
                {
                  "$ref": "#/components/schemas/ToolNode",
                  "title": "ToolNode"
                }
              ]
            }
          },
          "model": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/WorkflowOpenAIModel",
                "title": "WorkflowOpenAIModel"
              },
              {
                "$ref": "#/components/schemas/WorkflowAnthropicModel",
                "title": "WorkflowAnthropicModel"
              }
            ]
          },
          "name": {
            "type": "string",
            "maxLength": 80
          },
          "edges": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Edge"
            }
          },
          "globalPrompt": {
            "type": "string",
            "maxLength": 5000
          }
        },
        "required": [
          "nodes",
          "name",
          "edges"
        ]
      },
      "VapiModel": {
        "type": "object",
        "properties": {
          "messages": {
            "description": "This is the starting state for the conversation.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            }
          },
          "tools": {
            "type": "array",
            "description": "These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.\n\nBoth `tools` and `toolIds` can be used together.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CreateApiRequestToolDTO",
                  "title": "ApiRequestTool"
                },
                {
                  "$ref": "#/components/schemas/CreateBashToolDTO",
                  "title": "BashTool"
                },
                {
                  "$ref": "#/components/schemas/CreateComputerToolDTO",
                  "title": "ComputerTool"
                },
                {
                  "$ref": "#/components/schemas/CreateDtmfToolDTO",
                  "title": "DtmfTool"
                },
                {
                  "$ref": "#/components/schemas/CreateEndCallToolDTO",
                  "title": "EndCallTool"
                },
                {
                  "$ref": "#/components/schemas/CreateFunctionToolDTO",
                  "title": "FunctionTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                  "title": "GoHighLevelCalendarAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                  "title": "GoHighLevelCalendarEventCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                  "title": "GoHighLevelContactCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactGetToolDTO",
                  "title": "GoHighLevelContactGetTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                  "title": "GoogleCalendarCheckAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                  "title": "GoogleCalendarCreateEventTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                  "title": "GoogleSheetsRowAppendTool"
                },
                {
                  "$ref": "#/components/schemas/CreateMcpToolDTO",
                  "title": "McpTool"
                },
                {
                  "$ref": "#/components/schemas/CreateQueryToolDTO",
                  "title": "QueryTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSlackSendMessageToolDTO",
                  "title": "SlackSendMessageTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSmsToolDTO",
                  "title": "SmsTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTextEditorToolDTO",
                  "title": "TextEditorTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTransferCallToolDTO",
                  "title": "TransferCallTool"
                }
              ]
            }
          },
          "toolIds": {
            "description": "These are the tools that the assistant can use during the call. To use transient tools, use `tools`.\n\nBoth `tools` and `toolIds` can be used together.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "knowledgeBase": {
            "description": "These are the options for the knowledge base.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateCustomKnowledgeBaseDTO",
                "title": "Custom"
              }
            ]
          },
          "knowledgeBaseId": {
            "type": "string",
            "description": "This is the ID of the knowledge base the model will use."
          },
          "provider": {
            "type": "string",
            "enum": [
              "vapi"
            ]
          },
          "workflowId": {
            "type": "string",
            "description": "This is the workflow that will be used for the call. To use a transient workflow, use `workflow` instead."
          },
          "workflow": {
            "description": "This is the workflow that will be used for the call. To use an existing workflow, use `workflowId` instead.",
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowUserEditable"
              }
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b"
          },
          "temperature": {
            "type": "number",
            "description": "This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.",
            "minimum": 0,
            "maximum": 2
          },
          "maxTokens": {
            "type": "number",
            "description": "This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.",
            "minimum": 50,
            "maximum": 10000
          },
          "emotionRecognitionEnabled": {
            "type": "boolean",
            "description": "This determines whether we detect user's emotion while they speak and send it as an additional info to model.\n\nDefault `false` because the model is usually are good at understanding the user's emotion from text.\n\n@default false"
          },
          "numFastTurns": {
            "type": "number",
            "description": "This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.\n\nDefault is 0.\n\n@default 0",
            "minimum": 0
          }
        },
        "required": [
          "provider",
          "model"
        ]
      },
      "XaiModel": {
        "type": "object",
        "properties": {
          "messages": {
            "description": "This is the starting state for the conversation.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            }
          },
          "tools": {
            "type": "array",
            "description": "These are the tools that the assistant can use during the call. To use existing tools, use `toolIds`.\n\nBoth `tools` and `toolIds` can be used together.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CreateApiRequestToolDTO",
                  "title": "ApiRequestTool"
                },
                {
                  "$ref": "#/components/schemas/CreateBashToolDTO",
                  "title": "BashTool"
                },
                {
                  "$ref": "#/components/schemas/CreateComputerToolDTO",
                  "title": "ComputerTool"
                },
                {
                  "$ref": "#/components/schemas/CreateDtmfToolDTO",
                  "title": "DtmfTool"
                },
                {
                  "$ref": "#/components/schemas/CreateEndCallToolDTO",
                  "title": "EndCallTool"
                },
                {
                  "$ref": "#/components/schemas/CreateFunctionToolDTO",
                  "title": "FunctionTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                  "title": "GoHighLevelCalendarAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                  "title": "GoHighLevelCalendarEventCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                  "title": "GoHighLevelContactCreateTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelContactGetToolDTO",
                  "title": "GoHighLevelContactGetTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                  "title": "GoogleCalendarCheckAvailabilityTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                  "title": "GoogleCalendarCreateEventTool"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                  "title": "GoogleSheetsRowAppendTool"
                },
                {
                  "$ref": "#/components/schemas/CreateMcpToolDTO",
                  "title": "McpTool"
                },
                {
                  "$ref": "#/components/schemas/CreateQueryToolDTO",
                  "title": "QueryTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSlackSendMessageToolDTO",
                  "title": "SlackSendMessageTool"
                },
                {
                  "$ref": "#/components/schemas/CreateSmsToolDTO",
                  "title": "SmsTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTextEditorToolDTO",
                  "title": "TextEditorTool"
                },
                {
                  "$ref": "#/components/schemas/CreateTransferCallToolDTO",
                  "title": "TransferCallTool"
                }
              ]
            }
          },
          "toolIds": {
            "description": "These are the tools that the assistant can use during the call. To use transient tools, use `tools`.\n\nBoth `tools` and `toolIds` can be used together.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "knowledgeBase": {
            "description": "These are the options for the knowledge base.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateCustomKnowledgeBaseDTO",
                "title": "Custom"
              }
            ]
          },
          "knowledgeBaseId": {
            "type": "string",
            "description": "This is the ID of the knowledge base the model will use."
          },
          "model": {
            "type": "string",
            "description": "This is the name of the model. Ex. cognitivecomputations/dolphin-mixtral-8x7b",
            "enum": [
              "grok-beta",
              "grok-2",
              "grok-3"
            ]
          },
          "provider": {
            "type": "string",
            "enum": [
              "xai"
            ]
          },
          "temperature": {
            "type": "number",
            "description": "This is the temperature that will be used for calls. Default is 0 to leverage caching for lower latency.",
            "minimum": 0,
            "maximum": 2
          },
          "maxTokens": {
            "type": "number",
            "description": "This is the max number of tokens that the assistant will be allowed to generate in each turn of the conversation. Default is 250.",
            "minimum": 50,
            "maximum": 10000
          },
          "emotionRecognitionEnabled": {
            "type": "boolean",
            "description": "This determines whether we detect user's emotion while they speak and send it as an additional info to model.\n\nDefault `false` because the model is usually are good at understanding the user's emotion from text.\n\n@default false"
          },
          "numFastTurns": {
            "type": "number",
            "description": "This sets how many turns at the start of the conversation to use a smaller, faster model from the same provider before switching to the primary model. Example, gpt-3.5-turbo if provider is openai.\n\nDefault is 0.\n\n@default 0",
            "minimum": 0
          }
        },
        "required": [
          "model",
          "provider"
        ]
      },
      "ExactReplacement": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the exact replacement type. You can use this to replace a specific word or phrase with a different word or phrase.\n\nUsage:\n- Replace \"hello\" with \"hi\": { type: 'exact', key: 'hello', value: 'hi' }\n- Replace \"good morning\" with \"good day\": { type: 'exact', key: 'good morning', value: 'good day' }\n- Replace a specific name: { type: 'exact', key: 'John Doe', value: 'Jane Smith' }\n- Replace an acronym: { type: 'exact', key: 'AI', value: 'Artificial Intelligence' }\n- Replace a company name with its phonetic pronunciation: { type: 'exact', key: 'Vapi', value: 'Vappy' }",
            "enum": [
              "exact"
            ]
          },
          "replaceAllEnabled": {
            "type": "boolean",
            "description": "This option let's you control whether to replace all instances of the key or only the first one. By default, it only replaces the first instance.\nExamples:\n- For { type: 'exact', key: 'hello', value: 'hi', replaceAllEnabled: false }. Before: \"hello world, hello universe\" | After: \"hi world, hello universe\"\n- For { type: 'exact', key: 'hello', value: 'hi', replaceAllEnabled: true }. Before: \"hello world, hello universe\" | After: \"hi world, hi universe\"\n@default false",
            "default": false
          },
          "key": {
            "type": "string",
            "description": "This is the key to replace."
          },
          "value": {
            "type": "string",
            "description": "This is the value that will replace the match.",
            "maxLength": 1000
          }
        },
        "required": [
          "type",
          "key",
          "value"
        ]
      },
      "RegexOption": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of the regex option. Options are:\n- `ignore-case`: Ignores the case of the text being matched. Add\n- `whole-word`: Matches whole words only.\n- `multi-line`: Matches across multiple lines.",
            "enum": [
              "ignore-case",
              "whole-word",
              "multi-line"
            ]
          },
          "enabled": {
            "type": "boolean",
            "description": "This is whether to enable the option.\n\n@default false"
          }
        },
        "required": [
          "type",
          "enabled"
        ]
      },
      "RegexReplacement": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the regex replacement type. You can use this to replace a word or phrase that matches a pattern.\n\nUsage:\n- Replace all numbers with \"some number\": { type: 'regex', regex: '\\\\d+', value: 'some number' }\n- Replace email addresses with \"[EMAIL]\": { type: 'regex', regex: '\\\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Z|a-z]{2,}\\\\b', value: '[EMAIL]' }\n- Replace phone numbers with a formatted version: { type: 'regex', regex: '(\\\\d{3})(\\\\d{3})(\\\\d{4})', value: '($1) $2-$3' }\n- Replace all instances of \"color\" or \"colour\" with \"hue\": { type: 'regex', regex: 'colou?r', value: 'hue' }\n- Capitalize the first letter of every sentence: { type: 'regex', regex: '(?<=\\\\. |^)[a-z]', value: (match) => match.toUpperCase() }",
            "enum": [
              "regex"
            ]
          },
          "regex": {
            "type": "string",
            "description": "This is the regex pattern to replace.\n\nNote:\n- This works by using the `string.replace` method in Node.JS. Eg. `\"hello there\".replace(/hello/g, \"hi\")` will return `\"hi there\"`.\n\nHot tip:\n- In JavaScript, escape `\\` when sending the regex pattern. Eg. `\"hello\\sthere\"` will be sent over the wire as `\"hellosthere\"`. Send `\"hello\\\\sthere\"` instead."
          },
          "options": {
            "description": "These are the options for the regex replacement. Defaults to all disabled.\n\n@default []",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RegexOption"
            }
          },
          "value": {
            "type": "string",
            "description": "This is the value that will replace the match.",
            "maxLength": 1000
          }
        },
        "required": [
          "type",
          "regex",
          "value"
        ]
      },
      "FormatPlan": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "This determines whether the chunk is formatted before being sent to the voice provider. This helps with enunciation. This includes phone numbers, emails and addresses. Default `true`.\n\nUsage:\n- To rely on the voice provider's formatting logic, set this to `false`.\n\nIf `voice.chunkPlan.enabled` is `false`, this is automatically `false` since there's no chunk to format.\n\n@default true",
            "example": true
          },
          "numberToDigitsCutoff": {
            "type": "number",
            "description": "This is the cutoff after which a number is converted to individual digits instead of being spoken as words.\n\nExample:\n- If cutoff 2025, \"12345\" is converted to \"1 2 3 4 5\" while \"1200\" is converted to \"twelve hundred\".\n\nUsage:\n- If your use case doesn't involve IDs like zip codes, set this to a high value.\n- If your use case involves IDs that are shorter than 5 digits, set this to a lower value.\n\n@default 2025",
            "minimum": 0,
            "example": 2025
          },
          "replacements": {
            "type": "array",
            "description": "These are the custom replacements you can make to the chunk before it is sent to the voice provider.\n\nUsage:\n- To replace a specific word or phrase with a different word or phrase, use the `ExactReplacement` type. Eg. `{ type: 'exact', key: 'hello', value: 'hi' }`\n- To replace a word or phrase that matches a pattern, use the `RegexReplacement` type. Eg. `{ type: 'regex', regex: '\\\\b[a-zA-Z]{5}\\\\b', value: 'hi' }`\n\n@default []",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ExactReplacement",
                  "title": "ExactReplacement"
                },
                {
                  "$ref": "#/components/schemas/RegexReplacement",
                  "title": "RegexReplacement"
                }
              ]
            }
          },
          "formattersEnabled": {
            "type": "array",
            "description": "List of formatters to apply. If not provided, all default formatters will be applied.\nIf provided, only the specified formatters will be applied.\nNote: Some essential formatters like angle bracket removal will always be applied.\n@default undefined",
            "enum": [
              "markdown",
              "asterisk",
              "quote",
              "dash",
              "newline",
              "colon",
              "acronym",
              "dollarAmount",
              "email",
              "date",
              "time",
              "distance",
              "unit",
              "percentage",
              "phoneNumber",
              "number",
              "stripAsterisk"
            ],
            "items": {
              "type": "string",
              "enum": [
                "markdown",
                "asterisk",
                "quote",
                "dash",
                "newline",
                "colon",
                "acronym",
                "dollarAmount",
                "email",
                "date",
                "time",
                "distance",
                "unit",
                "percentage",
                "phoneNumber",
                "number",
                "stripAsterisk"
              ]
            }
          }
        }
      },
      "ChunkPlan": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "This determines whether the model output is chunked before being sent to the voice provider. Default `true`.\n\nUsage:\n- To rely on the voice provider's audio generation logic, set this to `false`.\n- If seeing issues with quality, set this to `true`.\n\nIf disabled, Vapi-provided audio control tokens like <flush /> will not work.\n\n@default true",
            "example": true
          },
          "minCharacters": {
            "type": "number",
            "description": "This is the minimum number of characters in a chunk.\n\nUsage:\n- To increase quality, set this to a higher value.\n- To decrease latency, set this to a lower value.\n\n@default 30",
            "minimum": 1,
            "maximum": 80,
            "example": 30
          },
          "punctuationBoundaries": {
            "type": "array",
            "description": "These are the punctuations that are considered valid boundaries for a chunk to be created.\n\nUsage:\n- To increase quality, constrain to fewer boundaries.\n- To decrease latency, enable all.\n\nDefault is automatically set to balance the trade-off between quality and latency based on the provider.",
            "enum": [
              "",
              "",
              ".",
              "!",
              "?",
              ";",
              ")",
              "",
              "",
              "",
              "",
              "|",
              "||",
              ",",
              ":"
            ],
            "example": [
              "",
              "",
              ".",
              "!",
              "?",
              ";",
              "",
              "",
              "",
              "",
              "|",
              "||",
              ",",
              ":"
            ],
            "items": {
              "type": "string",
              "enum": [
                "",
                "",
                ".",
                "!",
                "?",
                ";",
                ")",
                "",
                "",
                "",
                "",
                "|",
                "||",
                ",",
                ":"
              ]
            }
          },
          "formatPlan": {
            "description": "This is the plan for formatting the chunk before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FormatPlan"
              }
            ]
          }
        }
      },
      "FallbackPlan": {
        "type": "object",
        "properties": {
          "voices": {
            "type": "array",
            "description": "This is the list of voices to fallback to in the event that the primary voice provider fails.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/FallbackAzureVoice",
                  "title": "Azure"
                },
                {
                  "$ref": "#/components/schemas/FallbackCartesiaVoice",
                  "title": "Cartesia"
                },
                {
                  "$ref": "#/components/schemas/FallbackHumeVoice",
                  "title": "Hume"
                },
                {
                  "$ref": "#/components/schemas/FallbackCustomVoice",
                  "title": "CustomVoice"
                },
                {
                  "$ref": "#/components/schemas/FallbackDeepgramVoice",
                  "title": "Deepgram"
                },
                {
                  "$ref": "#/components/schemas/FallbackElevenLabsVoice",
                  "title": "ElevenLabs"
                },
                {
                  "$ref": "#/components/schemas/FallbackVapiVoice",
                  "title": "Vapi"
                },
                {
                  "$ref": "#/components/schemas/FallbackLMNTVoice",
                  "title": "LMNT"
                },
                {
                  "$ref": "#/components/schemas/FallbackOpenAIVoice",
                  "title": "OpenAI"
                },
                {
                  "$ref": "#/components/schemas/FallbackPlayHTVoice",
                  "title": "PlayHT"
                },
                {
                  "$ref": "#/components/schemas/FallbackRimeAIVoice",
                  "title": "RimeAI"
                },
                {
                  "$ref": "#/components/schemas/FallbackSmallestAIVoice",
                  "title": "Smallest AI"
                },
                {
                  "$ref": "#/components/schemas/FallbackTavusVoice",
                  "title": "TavusVoice"
                }
              ]
            }
          }
        },
        "required": [
          "voices"
        ]
      },
      "AzureVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "azure"
            ]
          },
          "voiceId": {
            "description": "This is the provider-specific ID that will be used.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "andrew",
                  "brian",
                  "emma"
                ],
                "title": "Preset Voice Options"
              },
              {
                "type": "string",
                "title": "Azure Voice ID"
              }
            ]
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          },
          "speed": {
            "type": "number",
            "description": "This is the speed multiplier that will be used.",
            "minimum": 0.5,
            "maximum": 2
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "CartesiaExperimentalControls": {
        "type": "object",
        "properties": {
          "speed": {
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "slowest",
                  "slow",
                  "normal",
                  "fast",
                  "fastest"
                ],
                "example": "normal"
              },
              {
                "type": "number",
                "minimum": -1,
                "maximum": 1,
                "example": 0.5
              }
            ]
          },
          "emotion": {
            "type": "string",
            "enum": [
              "anger:lowest",
              "anger:low",
              "anger:high",
              "anger:highest",
              "positivity:lowest",
              "positivity:low",
              "positivity:high",
              "positivity:highest",
              "surprise:lowest",
              "surprise:low",
              "surprise:high",
              "surprise:highest",
              "sadness:lowest",
              "sadness:low",
              "sadness:high",
              "sadness:highest",
              "curiosity:lowest",
              "curiosity:low",
              "curiosity:high",
              "curiosity:highest"
            ],
            "example": [
              "happiness:high"
            ]
          }
        }
      },
      "CartesiaVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "cartesia"
            ]
          },
          "voiceId": {
            "type": "string",
            "description": "The ID of the particular voice you want to use."
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used. This is optional and will default to the correct model for the voiceId.",
            "enum": [
              "sonic-2",
              "sonic-english",
              "sonic-multilingual",
              "sonic-preview",
              "sonic"
            ],
            "example": "sonic-english"
          },
          "language": {
            "type": "string",
            "description": "This is the language that will be used. This is optional and will default to the correct language for the voiceId.",
            "enum": [
              "en",
              "de",
              "es",
              "fr",
              "ja",
              "pt",
              "zh",
              "hi",
              "it",
              "ko",
              "nl",
              "pl",
              "ru",
              "sv",
              "tr"
            ],
            "example": "en"
          },
          "experimentalControls": {
            "description": "Experimental controls for Cartesia voice generation",
            "allOf": [
              {
                "$ref": "#/components/schemas/CartesiaExperimentalControls"
              }
            ]
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "CustomVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used. Use `custom-voice` for providers that are not natively supported.",
            "enum": [
              "custom-voice"
            ]
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          },
          "server": {
            "description": "This is where the voice request will be sent.\n\nRequest Example:\n\nPOST https://{server.url}\nContent-Type: application/json\n\n{\n  \"message\": {\n    \"type\": \"voice-request\",\n    \"text\": \"Hello, world!\",\n    \"sampleRate\": 24000,\n    ...other metadata about the call...\n  }\n}\n\nResponse Expected: 1-channel 16-bit raw PCM audio at the sample rate specified in the request. Here is how the response will be piped to the transport:\n```\nresponse.on('data', (chunk: Buffer) => {\n  outputStream.write(chunk);\n});\n```",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "server"
        ]
      },
      "DeepgramVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "deepgram"
            ]
          },
          "voiceId": {
            "type": "string",
            "description": "This is the provider-specific ID that will be used.",
            "enum": [
              "asteria",
              "luna",
              "stella",
              "athena",
              "hera",
              "orion",
              "arcas",
              "perseus",
              "angus",
              "orpheus",
              "helios",
              "zeus",
              "thalia",
              "andromeda",
              "helena",
              "apollo",
              "arcas",
              "aries",
              "amalthea",
              "asteria",
              "athena",
              "atlas",
              "aurora",
              "callista",
              "cora",
              "cordelia",
              "delia",
              "draco",
              "electra",
              "harmonia",
              "hera",
              "hermes",
              "hyperion",
              "iris",
              "janus",
              "juno",
              "jupiter",
              "luna",
              "mars",
              "minerva",
              "neptune",
              "odysseus",
              "ophelia",
              "orion",
              "orpheus",
              "pandora",
              "phoebe",
              "pluto",
              "saturn",
              "selene",
              "theia",
              "vesta",
              "zeus"
            ],
            "title": "This is the Deepgram Voice ID"
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used. Defaults to 'aura-2' when not specified.",
            "enum": [
              "aura",
              "aura-2"
            ],
            "example": "aura-2"
          },
          "mipOptOut": {
            "type": "boolean",
            "description": "If set to true, this will add mip_opt_out=true as a query parameter of all API requests. See https://developers.deepgram.com/docs/the-deepgram-model-improvement-partnership-program#want-to-opt-out\n\nThis will only be used if you are using your own Deepgram API key.\n\n@default false",
            "example": false,
            "default": false
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "ElevenLabsVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "11labs"
            ]
          },
          "voiceId": {
            "description": "This is the provider-specific ID that will be used. Ensure the Voice is present in your 11Labs Voice Library.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "burt",
                  "marissa",
                  "andrea",
                  "sarah",
                  "phillip",
                  "steve",
                  "joseph",
                  "myra",
                  "paula",
                  "ryan",
                  "drew",
                  "paul",
                  "mrb",
                  "matilda",
                  "mark"
                ],
                "title": "Preset Voice Options"
              },
              {
                "type": "string",
                "title": "11Labs Voice ID"
              }
            ]
          },
          "stability": {
            "type": "number",
            "description": "Defines the stability for voice settings.",
            "minimum": 0,
            "maximum": 1,
            "example": 0.5
          },
          "similarityBoost": {
            "type": "number",
            "description": "Defines the similarity boost for voice settings.",
            "minimum": 0,
            "maximum": 1,
            "example": 0.75
          },
          "style": {
            "type": "number",
            "description": "Defines the style for voice settings.",
            "minimum": 0,
            "maximum": 1,
            "example": 0
          },
          "useSpeakerBoost": {
            "type": "boolean",
            "description": "Defines the use speaker boost for voice settings.",
            "example": false
          },
          "speed": {
            "type": "number",
            "description": "Defines the speed for voice settings.",
            "minimum": 0.7,
            "maximum": 1.2,
            "example": 0.9
          },
          "optimizeStreamingLatency": {
            "type": "number",
            "description": "Defines the optimize streaming latency for voice settings. Defaults to 3.",
            "minimum": 0,
            "maximum": 4,
            "example": 3
          },
          "enableSsmlParsing": {
            "type": "boolean",
            "description": "This enables the use of https://elevenlabs.io/docs/speech-synthesis/prompting#pronunciation. Defaults to false to save latency.\n\n@default false",
            "example": false
          },
          "autoMode": {
            "type": "boolean",
            "description": "Defines the auto mode for voice settings. Defaults to false.",
            "example": false
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used. Defaults to 'eleven_turbo_v2' if not specified.",
            "enum": [
              "eleven_multilingual_v2",
              "eleven_turbo_v2",
              "eleven_turbo_v2_5",
              "eleven_flash_v2",
              "eleven_flash_v2_5",
              "eleven_monolingual_v1"
            ],
            "example": "eleven_turbo_v2_5"
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          },
          "language": {
            "type": "string",
            "description": "This is the language (ISO 639-1) that is enforced for the model. Currently only Turbo v2.5 supports language enforcement. For other models, an error will be returned if language code is provided."
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "HumeVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "hume"
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used.",
            "enum": [
              "octave"
            ],
            "example": "octave"
          },
          "voiceId": {
            "type": "string",
            "description": "The ID of the particular voice you want to use."
          },
          "isCustomHumeVoice": {
            "type": "boolean",
            "description": "Indicates whether the chosen voice is a preset Hume AI voice or a custom voice.",
            "example": false
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          },
          "description": {
            "type": "string",
            "description": "Natural language instructions describing how the synthesized speech should sound, including but not limited to tone, intonation, pacing, and accent (e.g., 'a soft, gentle voice with a strong British accent').\n\nIf a Voice is specified in the request, this description serves as acting instructions.\nIf no Voice is specified, a new voice is generated based on this description."
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "LMNTVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "lmnt"
            ]
          },
          "voiceId": {
            "description": "This is the provider-specific ID that will be used.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "lily",
                  "daniel"
                ],
                "title": "Preset Voice Options"
              },
              {
                "type": "string",
                "title": "LMNT Voice ID"
              }
            ]
          },
          "speed": {
            "type": "number",
            "description": "This is the speed multiplier that will be used.",
            "minimum": 0.25,
            "maximum": 2,
            "example": null
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "NeuphonicVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "neuphonic"
            ]
          },
          "voiceId": {
            "description": "This is the provider-specific ID that will be used.",
            "oneOf": [
              {
                "type": "string",
                "enum": [],
                "title": "Preset Voice Options"
              },
              {
                "type": "string",
                "title": "Neuphonic Voice ID"
              }
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used. Defaults to 'neu_fast' if not specified.",
            "enum": [
              "neu_hq",
              "neu_fast"
            ],
            "example": "neu_fast"
          },
          "language": {
            "type": "object",
            "description": "This is the language (ISO 639-1) that is enforced for the model.",
            "example": "en"
          },
          "speed": {
            "type": "number",
            "description": "This is the speed multiplier that will be used.",
            "minimum": 0.25,
            "maximum": 2,
            "example": null
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId",
          "language"
        ]
      },
      "OpenAIVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "openai"
            ]
          },
          "voiceId": {
            "description": "This is the provider-specific ID that will be used.\nPlease note that ash, ballad, coral, sage, and verse may only be used with realtime models.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "alloy",
                  "echo",
                  "fable",
                  "onyx",
                  "nova",
                  "shimmer"
                ],
                "title": "Preset Voice Options"
              },
              {
                "type": "string",
                "title": "OpenAI Voice ID"
              }
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used for text-to-speech.",
            "enum": [
              "tts-1",
              "tts-1-hd",
              "gpt-4o-mini-tts"
            ]
          },
          "instructions": {
            "type": "string",
            "description": "This is a prompt that allows you to control the voice of your generated audio.\nDoes not work with 'tts-1' or 'tts-1-hd' models.",
            "maxLength": 10000
          },
          "speed": {
            "type": "number",
            "description": "This is the speed multiplier that will be used.",
            "minimum": 0.25,
            "maximum": 4,
            "example": null
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "PlayHTVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "playht"
            ]
          },
          "voiceId": {
            "description": "This is the provider-specific ID that will be used.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "jennifer",
                  "melissa",
                  "will",
                  "chris",
                  "matt",
                  "jack",
                  "ruby",
                  "davis",
                  "donna",
                  "michael"
                ],
                "title": "Preset Voice Options"
              },
              {
                "type": "string",
                "title": "PlayHT Voice ID"
              }
            ]
          },
          "speed": {
            "type": "number",
            "description": "This is the speed multiplier that will be used.",
            "minimum": 0.1,
            "maximum": 5,
            "example": null
          },
          "temperature": {
            "type": "number",
            "description": "A floating point number between 0, exclusive, and 2, inclusive. If equal to null or not provided, the model's default temperature will be used. The temperature parameter controls variance. Lower temperatures result in more predictable results, higher temperatures allow each run to vary more, so the voice may sound less like the baseline voice.",
            "minimum": 0.1,
            "maximum": 2,
            "example": null
          },
          "emotion": {
            "type": "string",
            "description": "An emotion to be applied to the speech.",
            "enum": [
              "female_happy",
              "female_sad",
              "female_angry",
              "female_fearful",
              "female_disgust",
              "female_surprised",
              "male_happy",
              "male_sad",
              "male_angry",
              "male_fearful",
              "male_disgust",
              "male_surprised"
            ],
            "example": null
          },
          "voiceGuidance": {
            "type": "number",
            "description": "A number between 1 and 6. Use lower numbers to reduce how unique your chosen voice will be compared to other voices.",
            "minimum": 1,
            "maximum": 6,
            "example": null
          },
          "styleGuidance": {
            "type": "number",
            "description": "A number between 1 and 30. Use lower numbers to to reduce how strong your chosen emotion will be. Higher numbers will create a very emotional performance.",
            "minimum": 1,
            "maximum": 30,
            "example": null
          },
          "textGuidance": {
            "type": "number",
            "description": "A number between 1 and 2. This number influences how closely the generated speech adheres to the input text. Use lower values to create more fluid speech, but with a higher chance of deviating from the input text. Higher numbers will make the generated speech more accurate to the input text, ensuring that the words spoken align closely with the provided text.",
            "minimum": 1,
            "maximum": 2,
            "example": null
          },
          "model": {
            "type": "string",
            "description": "Playht voice model/engine to use.",
            "enum": [
              "PlayHT2.0",
              "PlayHT2.0-turbo",
              "Play3.0-mini",
              "PlayDialog"
            ]
          },
          "language": {
            "type": "string",
            "description": "The language to use for the speech.",
            "enum": [
              "afrikaans",
              "albanian",
              "amharic",
              "arabic",
              "bengali",
              "bulgarian",
              "catalan",
              "croatian",
              "czech",
              "danish",
              "dutch",
              "english",
              "french",
              "galician",
              "german",
              "greek",
              "hebrew",
              "hindi",
              "hungarian",
              "indonesian",
              "italian",
              "japanese",
              "korean",
              "malay",
              "mandarin",
              "polish",
              "portuguese",
              "russian",
              "serbian",
              "spanish",
              "swedish",
              "tagalog",
              "thai",
              "turkish",
              "ukrainian",
              "urdu",
              "xhosa"
            ]
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "RimeAIVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "rime-ai"
            ]
          },
          "voiceId": {
            "description": "This is the provider-specific ID that will be used.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "abbie",
                  "allison",
                  "ally",
                  "alona",
                  "amber",
                  "ana",
                  "antoine",
                  "armon",
                  "brenda",
                  "brittany",
                  "carol",
                  "colin",
                  "courtney",
                  "elena",
                  "elliot",
                  "eva",
                  "geoff",
                  "gerald",
                  "hank",
                  "helen",
                  "hera",
                  "jen",
                  "joe",
                  "joy",
                  "juan",
                  "kendra",
                  "kendrick",
                  "kenneth",
                  "kevin",
                  "kris",
                  "linda",
                  "madison",
                  "marge",
                  "marina",
                  "marissa",
                  "marta",
                  "maya",
                  "nicholas",
                  "nyles",
                  "phil",
                  "reba",
                  "rex",
                  "rick",
                  "ritu",
                  "rob",
                  "rodney",
                  "rohan",
                  "rosco",
                  "samantha",
                  "sandy",
                  "selena",
                  "seth",
                  "sharon",
                  "stan",
                  "tamra",
                  "tanya",
                  "tibur",
                  "tj",
                  "tyler",
                  "viv",
                  "yadira",
                  "marsh",
                  "bayou",
                  "creek",
                  "brook",
                  "flower",
                  "spore",
                  "glacier",
                  "gulch",
                  "alpine",
                  "cove",
                  "lagoon",
                  "tundra",
                  "steppe",
                  "mesa",
                  "grove",
                  "rainforest",
                  "moraine",
                  "wildflower",
                  "peak",
                  "boulder",
                  "gypsum",
                  "zest"
                ],
                "title": "Preset Voice Options"
              },
              {
                "type": "string",
                "title": "RimeAI Voice ID"
              }
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used. Defaults to 'v1' when not specified.",
            "enum": [
              "v1",
              "mist",
              "mistv2"
            ],
            "example": "mistv2"
          },
          "speed": {
            "type": "number",
            "description": "This is the speed multiplier that will be used.",
            "minimum": 0.1,
            "example": null
          },
          "pauseBetweenBrackets": {
            "type": "boolean",
            "description": "This is a flag that controls whether to add slight pauses using angle brackets. Example: \"Hi. <200> I'd love to have a conversation with you.\" adds a 200ms pause between the first and second sentences.",
            "example": false
          },
          "phonemizeBetweenBrackets": {
            "type": "boolean",
            "description": "This is a flag that controls whether text inside brackets should be phonemized (converted to phonetic pronunciation) - Example: \"{h'El.o} World\" will pronounce \"Hello\" as expected.",
            "example": false
          },
          "reduceLatency": {
            "type": "boolean",
            "description": "This is a flag that controls whether to optimize for reduced latency in streaming. https://docs.rime.ai/api-reference/endpoint/websockets#param-reduce-latency",
            "example": false
          },
          "inlineSpeedAlpha": {
            "type": "string",
            "description": "This is a string that allows inline speed control using alpha notation. https://docs.rime.ai/api-reference/endpoint/websockets#param-inline-speed-alpha",
            "example": null
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "SesameVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "sesame"
            ]
          },
          "voiceId": {
            "type": "string",
            "description": "This is the provider-specific ID that will be used.",
            "title": "Sesame Voice ID. This should be either a name (a built-in voice) or a UUID (a custom voice)."
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used.",
            "enum": [
              "csm-1b"
            ]
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId",
          "model"
        ]
      },
      "SmallestAIVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "smallest-ai"
            ]
          },
          "voiceId": {
            "description": "This is the provider-specific ID that will be used.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "emily",
                  "jasmine",
                  "arman",
                  "james",
                  "mithali",
                  "aravind",
                  "raj",
                  "diya",
                  "raman",
                  "ananya",
                  "isha",
                  "william",
                  "aarav",
                  "monika",
                  "niharika",
                  "deepika",
                  "raghav",
                  "kajal",
                  "radhika",
                  "mansi",
                  "nisha",
                  "saurabh",
                  "pooja",
                  "saina",
                  "sanya"
                ],
                "title": "Preset Voice Options"
              },
              {
                "type": "string",
                "title": "Smallest AI Voice ID"
              }
            ]
          },
          "model": {
            "type": "string",
            "description": "Smallest AI voice model to use. Defaults to 'lightning' when not specified.",
            "enum": [
              "lightning"
            ]
          },
          "speed": {
            "type": "number",
            "description": "This is the speed multiplier that will be used.",
            "example": null
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "TavusConversationProperties": {
        "type": "object",
        "properties": {
          "maxCallDuration": {
            "type": "number",
            "description": "The maximum duration of the call in seconds. The default `maxCallDuration` is 3600 seconds (1 hour).\nOnce the time limit specified by this parameter has been reached, the conversation will automatically shut down."
          },
          "participantLeftTimeout": {
            "type": "number",
            "description": "The duration in seconds after which the call will be automatically shut down once the last participant leaves."
          },
          "participantAbsentTimeout": {
            "type": "number",
            "description": "Starting from conversation creation, the duration in seconds after which the call will be automatically shut down if no participant joins the call.\nDefault is 300 seconds (5 minutes)."
          },
          "enableRecording": {
            "type": "boolean",
            "description": "If true, the user will be able to record the conversation."
          },
          "enableTranscription": {
            "type": "boolean",
            "description": "If true, the user will be able to transcribe the conversation.\nYou can find more instructions on displaying transcriptions if you are using your custom DailyJS components here.\nYou need to have an event listener on Daily that listens for `app-messages`."
          },
          "applyGreenscreen": {
            "type": "boolean",
            "description": "If true, the background will be replaced with a greenscreen (RGB values: `[0, 255, 155]`).\nYou can use WebGL on the frontend to make the greenscreen transparent or change its color."
          },
          "language": {
            "type": "string",
            "description": "The language of the conversation. Please provide the **full language name**, not the two-letter code.\nIf you are using your own TTS voice, please ensure it supports the language you provide.\nIf you are using a stock replica or default persona, please note that only ElevenLabs and Cartesia supported languages are available.\nYou can find a full list of supported languages for Cartesia here, for ElevenLabs here, and for PlayHT here."
          },
          "recordingS3BucketName": {
            "type": "string",
            "description": "The name of the S3 bucket where the recording will be stored."
          },
          "recordingS3BucketRegion": {
            "type": "string",
            "description": "The region of the S3 bucket where the recording will be stored."
          },
          "awsAssumeRoleArn": {
            "type": "string",
            "description": "The ARN of the role that will be assumed to access the S3 bucket."
          }
        }
      },
      "TavusVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "tavus"
            ]
          },
          "voiceId": {
            "description": "This is the provider-specific ID that will be used.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "r52da2535a"
                ],
                "title": "Preset Voice Options"
              },
              {
                "type": "string",
                "title": "Tavus Voice ID"
              }
            ]
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          },
          "personaId": {
            "type": "string",
            "description": "This is the unique identifier for the persona that the replica will use in the conversation."
          },
          "callbackUrl": {
            "type": "string",
            "description": "This is the url that will receive webhooks with updates regarding the conversation state."
          },
          "conversationName": {
            "type": "string",
            "description": "This is the name for the conversation."
          },
          "conversationalContext": {
            "type": "string",
            "description": "This is the context that will be appended to any context provided in the persona, if one is provided."
          },
          "customGreeting": {
            "type": "string",
            "description": "This is the custom greeting that the replica will give once a participant joines the conversation."
          },
          "properties": {
            "description": "These are optional properties used to customize the conversation.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TavusConversationProperties"
              }
            ]
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "VapiVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "vapi"
            ]
          },
          "voiceId": {
            "type": "string",
            "description": "The voices provided by Vapi",
            "enum": [
              "Elliot",
              "Kylie",
              "Rohan",
              "Lily",
              "Savannah",
              "Hana",
              "Neha",
              "Cole",
              "Harry",
              "Paige",
              "Spencer"
            ]
          },
          "speed": {
            "type": "number",
            "description": "This is the speed multiplier that will be used.\n\n@default 1",
            "minimum": 0.25,
            "maximum": 2,
            "default": 1
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          },
          "fallbackPlan": {
            "description": "This is the plan for voice provider fallbacks in the event that the primary voice provider fails.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FallbackPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "FallbackAzureVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "azure"
            ]
          },
          "voiceId": {
            "description": "This is the provider-specific ID that will be used.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "andrew",
                  "brian",
                  "emma"
                ],
                "title": "Preset Voice Options"
              },
              {
                "type": "string",
                "title": "Azure Voice ID"
              }
            ]
          },
          "speed": {
            "type": "number",
            "description": "This is the speed multiplier that will be used.",
            "minimum": 0.5,
            "maximum": 2
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "FallbackCartesiaVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "cartesia"
            ]
          },
          "voiceId": {
            "type": "string",
            "description": "The ID of the particular voice you want to use."
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used. This is optional and will default to the correct model for the voiceId.",
            "enum": [
              "sonic-2",
              "sonic-english",
              "sonic-multilingual",
              "sonic-preview",
              "sonic"
            ],
            "example": "sonic-english"
          },
          "language": {
            "type": "string",
            "description": "This is the language that will be used. This is optional and will default to the correct language for the voiceId.",
            "enum": [
              "en",
              "de",
              "es",
              "fr",
              "ja",
              "pt",
              "zh",
              "hi",
              "it",
              "ko",
              "nl",
              "pl",
              "ru",
              "sv",
              "tr"
            ],
            "example": "en"
          },
          "experimentalControls": {
            "description": "Experimental controls for Cartesia voice generation",
            "allOf": [
              {
                "$ref": "#/components/schemas/CartesiaExperimentalControls"
              }
            ]
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "FallbackCustomVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used. Use `custom-voice` for providers that are not natively supported.",
            "enum": [
              "custom-voice"
            ]
          },
          "server": {
            "description": "This is where the voice request will be sent.\n\nRequest Example:\n\nPOST https://{server.url}\nContent-Type: application/json\n\n{\n  \"message\": {\n    \"type\": \"voice-request\",\n    \"text\": \"Hello, world!\",\n    \"sampleRate\": 24000,\n    ...other metadata about the call...\n  }\n}\n\nResponse Expected: 1-channel 16-bit raw PCM audio at the sample rate specified in the request. Here is how the response will be piped to the transport:\n```\nresponse.on('data', (chunk: Buffer) => {\n  outputStream.write(chunk);\n});\n```",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "server"
        ]
      },
      "FallbackDeepgramVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "deepgram"
            ]
          },
          "voiceId": {
            "type": "string",
            "description": "This is the provider-specific ID that will be used.",
            "enum": [
              "asteria",
              "luna",
              "stella",
              "athena",
              "hera",
              "orion",
              "arcas",
              "perseus",
              "angus",
              "orpheus",
              "helios",
              "zeus",
              "thalia",
              "andromeda",
              "helena",
              "apollo",
              "arcas",
              "aries",
              "amalthea",
              "asteria",
              "athena",
              "atlas",
              "aurora",
              "callista",
              "cora",
              "cordelia",
              "delia",
              "draco",
              "electra",
              "harmonia",
              "hera",
              "hermes",
              "hyperion",
              "iris",
              "janus",
              "juno",
              "jupiter",
              "luna",
              "mars",
              "minerva",
              "neptune",
              "odysseus",
              "ophelia",
              "orion",
              "orpheus",
              "pandora",
              "phoebe",
              "pluto",
              "saturn",
              "selene",
              "theia",
              "vesta",
              "zeus"
            ],
            "title": "This is the Deepgram Voice ID"
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used. Defaults to 'aura-2' when not specified.",
            "enum": [
              "aura",
              "aura-2"
            ],
            "example": "aura-2"
          },
          "mipOptOut": {
            "type": "boolean",
            "description": "If set to true, this will add mip_opt_out=true as a query parameter of all API requests. See https://developers.deepgram.com/docs/the-deepgram-model-improvement-partnership-program#want-to-opt-out\n\nThis will only be used if you are using your own Deepgram API key.\n\n@default false",
            "example": false,
            "default": false
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "FallbackElevenLabsVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "11labs"
            ]
          },
          "voiceId": {
            "description": "This is the provider-specific ID that will be used. Ensure the Voice is present in your 11Labs Voice Library.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "burt",
                  "marissa",
                  "andrea",
                  "sarah",
                  "phillip",
                  "steve",
                  "joseph",
                  "myra",
                  "paula",
                  "ryan",
                  "drew",
                  "paul",
                  "mrb",
                  "matilda",
                  "mark"
                ],
                "title": "Preset Voice Options"
              },
              {
                "type": "string",
                "title": "11Labs Voice ID"
              }
            ]
          },
          "stability": {
            "type": "number",
            "description": "Defines the stability for voice settings.",
            "minimum": 0,
            "maximum": 1,
            "example": 0.5
          },
          "similarityBoost": {
            "type": "number",
            "description": "Defines the similarity boost for voice settings.",
            "minimum": 0,
            "maximum": 1,
            "example": 0.75
          },
          "style": {
            "type": "number",
            "description": "Defines the style for voice settings.",
            "minimum": 0,
            "maximum": 1,
            "example": 0
          },
          "useSpeakerBoost": {
            "type": "boolean",
            "description": "Defines the use speaker boost for voice settings.",
            "example": false
          },
          "speed": {
            "type": "number",
            "description": "Defines the speed for voice settings.",
            "minimum": 0.7,
            "maximum": 1.2,
            "example": 0.9
          },
          "optimizeStreamingLatency": {
            "type": "number",
            "description": "Defines the optimize streaming latency for voice settings. Defaults to 3.",
            "minimum": 0,
            "maximum": 4,
            "example": 3
          },
          "enableSsmlParsing": {
            "type": "boolean",
            "description": "This enables the use of https://elevenlabs.io/docs/speech-synthesis/prompting#pronunciation. Defaults to false to save latency.\n\n@default false",
            "example": false
          },
          "autoMode": {
            "type": "boolean",
            "description": "Defines the auto mode for voice settings. Defaults to false.",
            "example": false
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used. Defaults to 'eleven_turbo_v2' if not specified.",
            "enum": [
              "eleven_multilingual_v2",
              "eleven_turbo_v2",
              "eleven_turbo_v2_5",
              "eleven_flash_v2",
              "eleven_flash_v2_5",
              "eleven_monolingual_v1"
            ],
            "example": "eleven_turbo_v2_5"
          },
          "language": {
            "type": "string",
            "description": "This is the language (ISO 639-1) that is enforced for the model. Currently only Turbo v2.5 supports language enforcement. For other models, an error will be returned if language code is provided."
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "FallbackHumeVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "hume"
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used.",
            "enum": [
              "octave"
            ],
            "example": "octave"
          },
          "voiceId": {
            "type": "string",
            "description": "The ID of the particular voice you want to use."
          },
          "isCustomHumeVoice": {
            "type": "boolean",
            "description": "Indicates whether the chosen voice is a preset Hume AI voice or a custom voice.",
            "example": false
          },
          "description": {
            "type": "string",
            "description": "Natural language instructions describing how the synthesized speech should sound, including but not limited to tone, intonation, pacing, and accent (e.g., 'a soft, gentle voice with a strong British accent').\n\nIf a Voice is specified in the request, this description serves as acting instructions.\nIf no Voice is specified, a new voice is generated based on this description."
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "FallbackLMNTVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "lmnt"
            ]
          },
          "voiceId": {
            "description": "This is the provider-specific ID that will be used.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "lily",
                  "daniel"
                ],
                "title": "Preset Voice Options"
              },
              {
                "type": "string",
                "title": "LMNT Voice ID"
              }
            ]
          },
          "speed": {
            "type": "number",
            "description": "This is the speed multiplier that will be used.",
            "minimum": 0.25,
            "maximum": 2,
            "example": null
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "FallbackNeuphonicVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "neuphonic"
            ]
          },
          "voiceId": {
            "description": "This is the provider-specific ID that will be used.",
            "oneOf": [
              {
                "type": "string",
                "enum": [],
                "title": "Preset Voice Options"
              },
              {
                "type": "string",
                "title": "Neuphonic Voice ID"
              }
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used. Defaults to 'neu_fast' if not specified.",
            "enum": [
              "neu_hq",
              "neu_fast"
            ],
            "example": "neu_fast"
          },
          "language": {
            "type": "object",
            "description": "This is the language (ISO 639-1) that is enforced for the model.",
            "example": "en"
          },
          "speed": {
            "type": "number",
            "description": "This is the speed multiplier that will be used.",
            "minimum": 0.25,
            "maximum": 2,
            "example": null
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId",
          "language"
        ]
      },
      "FallbackOpenAIVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "openai"
            ]
          },
          "voiceId": {
            "description": "This is the provider-specific ID that will be used.\nPlease note that ash, ballad, coral, sage, and verse may only be used with realtime models.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "alloy",
                  "echo",
                  "fable",
                  "onyx",
                  "nova",
                  "shimmer"
                ],
                "title": "Preset Voice Options"
              },
              {
                "type": "string",
                "title": "OpenAI Voice ID"
              }
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used for text-to-speech.",
            "enum": [
              "tts-1",
              "tts-1-hd",
              "gpt-4o-mini-tts"
            ]
          },
          "instructions": {
            "type": "string",
            "description": "This is a prompt that allows you to control the voice of your generated audio.\nDoes not work with 'tts-1' or 'tts-1-hd' models.",
            "maxLength": 10000
          },
          "speed": {
            "type": "number",
            "description": "This is the speed multiplier that will be used.",
            "minimum": 0.25,
            "maximum": 4,
            "example": null
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "FallbackPlayHTVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "playht"
            ]
          },
          "voiceId": {
            "description": "This is the provider-specific ID that will be used.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "jennifer",
                  "melissa",
                  "will",
                  "chris",
                  "matt",
                  "jack",
                  "ruby",
                  "davis",
                  "donna",
                  "michael"
                ],
                "title": "Preset Voice Options"
              },
              {
                "type": "string",
                "title": "PlayHT Voice ID"
              }
            ]
          },
          "speed": {
            "type": "number",
            "description": "This is the speed multiplier that will be used.",
            "minimum": 0.1,
            "maximum": 5,
            "example": null
          },
          "temperature": {
            "type": "number",
            "description": "A floating point number between 0, exclusive, and 2, inclusive. If equal to null or not provided, the model's default temperature will be used. The temperature parameter controls variance. Lower temperatures result in more predictable results, higher temperatures allow each run to vary more, so the voice may sound less like the baseline voice.",
            "minimum": 0.1,
            "maximum": 2,
            "example": null
          },
          "emotion": {
            "type": "string",
            "description": "An emotion to be applied to the speech.",
            "enum": [
              "female_happy",
              "female_sad",
              "female_angry",
              "female_fearful",
              "female_disgust",
              "female_surprised",
              "male_happy",
              "male_sad",
              "male_angry",
              "male_fearful",
              "male_disgust",
              "male_surprised"
            ],
            "example": null
          },
          "voiceGuidance": {
            "type": "number",
            "description": "A number between 1 and 6. Use lower numbers to reduce how unique your chosen voice will be compared to other voices.",
            "minimum": 1,
            "maximum": 6,
            "example": null
          },
          "styleGuidance": {
            "type": "number",
            "description": "A number between 1 and 30. Use lower numbers to to reduce how strong your chosen emotion will be. Higher numbers will create a very emotional performance.",
            "minimum": 1,
            "maximum": 30,
            "example": null
          },
          "textGuidance": {
            "type": "number",
            "description": "A number between 1 and 2. This number influences how closely the generated speech adheres to the input text. Use lower values to create more fluid speech, but with a higher chance of deviating from the input text. Higher numbers will make the generated speech more accurate to the input text, ensuring that the words spoken align closely with the provided text.",
            "minimum": 1,
            "maximum": 2,
            "example": null
          },
          "model": {
            "type": "string",
            "description": "Playht voice model/engine to use.",
            "enum": [
              "PlayHT2.0",
              "PlayHT2.0-turbo",
              "Play3.0-mini",
              "PlayDialog"
            ]
          },
          "language": {
            "type": "string",
            "description": "The language to use for the speech.",
            "enum": [
              "afrikaans",
              "albanian",
              "amharic",
              "arabic",
              "bengali",
              "bulgarian",
              "catalan",
              "croatian",
              "czech",
              "danish",
              "dutch",
              "english",
              "french",
              "galician",
              "german",
              "greek",
              "hebrew",
              "hindi",
              "hungarian",
              "indonesian",
              "italian",
              "japanese",
              "korean",
              "malay",
              "mandarin",
              "polish",
              "portuguese",
              "russian",
              "serbian",
              "spanish",
              "swedish",
              "tagalog",
              "thai",
              "turkish",
              "ukrainian",
              "urdu",
              "xhosa"
            ]
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "FallbackRimeAIVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "rime-ai"
            ]
          },
          "voiceId": {
            "description": "This is the provider-specific ID that will be used.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "abbie",
                  "allison",
                  "ally",
                  "alona",
                  "amber",
                  "ana",
                  "antoine",
                  "armon",
                  "brenda",
                  "brittany",
                  "carol",
                  "colin",
                  "courtney",
                  "elena",
                  "elliot",
                  "eva",
                  "geoff",
                  "gerald",
                  "hank",
                  "helen",
                  "hera",
                  "jen",
                  "joe",
                  "joy",
                  "juan",
                  "kendra",
                  "kendrick",
                  "kenneth",
                  "kevin",
                  "kris",
                  "linda",
                  "madison",
                  "marge",
                  "marina",
                  "marissa",
                  "marta",
                  "maya",
                  "nicholas",
                  "nyles",
                  "phil",
                  "reba",
                  "rex",
                  "rick",
                  "ritu",
                  "rob",
                  "rodney",
                  "rohan",
                  "rosco",
                  "samantha",
                  "sandy",
                  "selena",
                  "seth",
                  "sharon",
                  "stan",
                  "tamra",
                  "tanya",
                  "tibur",
                  "tj",
                  "tyler",
                  "viv",
                  "yadira",
                  "marsh",
                  "bayou",
                  "creek",
                  "brook",
                  "flower",
                  "spore",
                  "glacier",
                  "gulch",
                  "alpine",
                  "cove",
                  "lagoon",
                  "tundra",
                  "steppe",
                  "mesa",
                  "grove",
                  "rainforest",
                  "moraine",
                  "wildflower",
                  "peak",
                  "boulder",
                  "gypsum",
                  "zest"
                ],
                "title": "Preset Voice Options"
              },
              {
                "type": "string",
                "title": "RimeAI Voice ID"
              }
            ]
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used. Defaults to 'v1' when not specified.",
            "enum": [
              "v1",
              "mist",
              "mistv2"
            ],
            "example": "mistv2"
          },
          "speed": {
            "type": "number",
            "description": "This is the speed multiplier that will be used.",
            "minimum": 0.1,
            "example": null
          },
          "pauseBetweenBrackets": {
            "type": "boolean",
            "description": "This is a flag that controls whether to add slight pauses using angle brackets. Example: \"Hi. <200> I'd love to have a conversation with you.\" adds a 200ms pause between the first and second sentences.",
            "example": false
          },
          "phonemizeBetweenBrackets": {
            "type": "boolean",
            "description": "This is a flag that controls whether text inside brackets should be phonemized (converted to phonetic pronunciation) - Example: \"{h'El.o} World\" will pronounce \"Hello\" as expected.",
            "example": false
          },
          "reduceLatency": {
            "type": "boolean",
            "description": "This is a flag that controls whether to optimize for reduced latency in streaming. https://docs.rime.ai/api-reference/endpoint/websockets#param-reduce-latency",
            "example": false
          },
          "inlineSpeedAlpha": {
            "type": "string",
            "description": "This is a string that allows inline speed control using alpha notation. https://docs.rime.ai/api-reference/endpoint/websockets#param-inline-speed-alpha",
            "example": null
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "FallbackSesameVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "sesame"
            ]
          },
          "voiceId": {
            "type": "string",
            "description": "This is the provider-specific ID that will be used.",
            "title": "Sesame Voice ID. This should be either a name (a built-in voice) or a UUID (a custom voice)."
          },
          "model": {
            "type": "string",
            "description": "This is the model that will be used.",
            "enum": [
              "csm-1b"
            ]
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId",
          "model"
        ]
      },
      "FallbackSmallestAIVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "smallest-ai"
            ]
          },
          "voiceId": {
            "description": "This is the provider-specific ID that will be used.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "emily",
                  "jasmine",
                  "arman",
                  "james",
                  "mithali",
                  "aravind",
                  "raj",
                  "diya",
                  "raman",
                  "ananya",
                  "isha",
                  "william",
                  "aarav",
                  "monika",
                  "niharika",
                  "deepika",
                  "raghav",
                  "kajal",
                  "radhika",
                  "mansi",
                  "nisha",
                  "saurabh",
                  "pooja",
                  "saina",
                  "sanya"
                ],
                "title": "Preset Voice Options"
              },
              {
                "type": "string",
                "title": "Smallest AI Voice ID"
              }
            ]
          },
          "model": {
            "type": "string",
            "description": "Smallest AI voice model to use. Defaults to 'lightning' when not specified.",
            "enum": [
              "lightning"
            ]
          },
          "speed": {
            "type": "number",
            "description": "This is the speed multiplier that will be used.",
            "example": null
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "FallbackTavusVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "tavus"
            ]
          },
          "voiceId": {
            "description": "This is the provider-specific ID that will be used.",
            "oneOf": [
              {
                "type": "string",
                "enum": [
                  "r52da2535a"
                ],
                "title": "Preset Voice Options"
              },
              {
                "type": "string",
                "title": "Tavus Voice ID"
              }
            ]
          },
          "personaId": {
            "type": "string",
            "description": "This is the unique identifier for the persona that the replica will use in the conversation."
          },
          "callbackUrl": {
            "type": "string",
            "description": "This is the url that will receive webhooks with updates regarding the conversation state."
          },
          "conversationName": {
            "type": "string",
            "description": "This is the name for the conversation."
          },
          "conversationalContext": {
            "type": "string",
            "description": "This is the context that will be appended to any context provided in the persona, if one is provided."
          },
          "customGreeting": {
            "type": "string",
            "description": "This is the custom greeting that the replica will give once a participant joines the conversation."
          },
          "properties": {
            "description": "These are optional properties used to customize the conversation.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TavusConversationProperties"
              }
            ]
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "FallbackVapiVoice": {
        "type": "object",
        "properties": {
          "cachingEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle voice caching for the assistant.",
            "example": true,
            "default": true
          },
          "provider": {
            "type": "string",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "vapi"
            ]
          },
          "voiceId": {
            "type": "string",
            "description": "The voices provided by Vapi",
            "enum": [
              "Elliot",
              "Kylie",
              "Rohan",
              "Lily",
              "Savannah",
              "Hana",
              "Neha",
              "Cole",
              "Harry",
              "Paige",
              "Spencer"
            ]
          },
          "speed": {
            "type": "number",
            "description": "This is the speed multiplier that will be used.\n\n@default 1",
            "minimum": 0.25,
            "maximum": 2,
            "default": 1
          },
          "chunkPlan": {
            "description": "This is the plan for chunking the model output before it is sent to the voice provider.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChunkPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "voiceId"
        ]
      },
      "TransportConfigurationTwilio": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "twilio"
            ]
          },
          "timeout": {
            "type": "number",
            "description": "The integer number of seconds that we should allow the phone to ring before assuming there is no answer.\nThe default is `60` seconds and the maximum is `600` seconds.\nFor some call flows, we will add a 5-second buffer to the timeout value you provide.\nFor this reason, a timeout value of 10 seconds could result in an actual timeout closer to 15 seconds.\nYou can set this to a short time, such as `15` seconds, to hang up before reaching an answering machine or voicemail.\n\n@default 60",
            "minimum": 1,
            "maximum": 600,
            "example": 60
          },
          "record": {
            "type": "boolean",
            "description": "Whether to record the call.\nCan be `true` to record the phone call, or `false` to not.\nThe default is `false`.\n\n@default false",
            "example": false
          },
          "recordingChannels": {
            "type": "string",
            "description": "The number of channels in the final recording.\nCan be: `mono` or `dual`.\nThe default is `mono`.\n`mono` records both legs of the call in a single channel of the recording file.\n`dual` records each leg to a separate channel of the recording file.\nThe first channel of a dual-channel recording contains the parent call and the second channel contains the child call.\n\n@default 'mono'",
            "enum": [
              "mono",
              "dual"
            ],
            "example": "mono"
          }
        },
        "required": [
          "provider"
        ]
      },
      "CreateAnthropicCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "anthropic"
            ]
          },
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateAnyscaleCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "anyscale"
            ]
          },
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateAssemblyAICredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "assembly-ai"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "AzureBlobStorageBucketPlan": {
        "type": "object",
        "properties": {
          "connectionString": {
            "type": "string",
            "description": "This is the blob storage connection string for the Azure resource."
          },
          "containerName": {
            "type": "string",
            "description": "This is the container name for the Azure blob storage."
          },
          "path": {
            "type": "string",
            "description": "This is the path where call artifacts will be stored.\n\nUsage:\n- To store call artifacts in a specific folder, set this to the full path. Eg. \"/folder-name1/folder-name2\".\n- To store call artifacts in the root of the bucket, leave this blank.\n\n@default \"/\""
          }
        },
        "required": [
          "connectionString",
          "containerName"
        ]
      },
      "CreateAzureCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "azure"
            ]
          },
          "service": {
            "type": "string",
            "description": "This is the service being used in Azure.",
            "enum": [
              "speech",
              "blob_storage"
            ],
            "default": "speech"
          },
          "region": {
            "type": "string",
            "description": "This is the region of the Azure resource.",
            "enum": [
              "australia",
              "canadaeast",
              "canadacentral",
              "eastus2",
              "eastus",
              "france",
              "india",
              "japaneast",
              "japanwest",
              "uaenorth",
              "northcentralus",
              "norway",
              "southcentralus",
              "swedencentral",
              "switzerland",
              "uk",
              "westus",
              "westus3"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API.",
            "maxLength": 10000
          },
          "bucketPlan": {
            "description": "This is the bucket plan that can be provided to store call artifacts in Azure Blob Storage.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AzureBlobStorageBucketPlan"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "service"
        ]
      },
      "CreateAzureOpenAICredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "azure-openai"
            ]
          },
          "region": {
            "type": "string",
            "enum": [
              "australia",
              "canadaeast",
              "canadacentral",
              "eastus2",
              "eastus",
              "france",
              "india",
              "japaneast",
              "japanwest",
              "uaenorth",
              "northcentralus",
              "norway",
              "southcentralus",
              "swedencentral",
              "switzerland",
              "uk",
              "westus",
              "westus3"
            ]
          },
          "models": {
            "type": "array",
            "enum": [
              "gpt-4.1-2025-04-14",
              "gpt-4.1-mini-2025-04-14",
              "gpt-4.1-nano-2025-04-14",
              "gpt-4o-2024-11-20",
              "gpt-4o-2024-08-06",
              "gpt-4o-2024-05-13",
              "gpt-4o-mini-2024-07-18",
              "gpt-4-turbo-2024-04-09",
              "gpt-4-0125-preview",
              "gpt-4-1106-preview",
              "gpt-4-0613",
              "gpt-35-turbo-0125",
              "gpt-35-turbo-1106"
            ],
            "example": [
              "gpt-4-0125-preview",
              "gpt-4-0613"
            ],
            "items": {
              "type": "string",
              "enum": [
                "gpt-4.1-2025-04-14",
                "gpt-4.1-mini-2025-04-14",
                "gpt-4.1-nano-2025-04-14",
                "gpt-4o-2024-11-20",
                "gpt-4o-2024-08-06",
                "gpt-4o-2024-05-13",
                "gpt-4o-mini-2024-07-18",
                "gpt-4-turbo-2024-04-09",
                "gpt-4-0125-preview",
                "gpt-4-1106-preview",
                "gpt-4-0613",
                "gpt-35-turbo-0125",
                "gpt-35-turbo-1106"
              ]
            }
          },
          "openAIKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "ocpApimSubscriptionKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "openAIEndpoint": {
            "type": "string",
            "maxLength": 10000
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "region",
          "models",
          "openAIKey",
          "openAIEndpoint"
        ]
      },
      "SipTrunkGateway": {
        "type": "object",
        "properties": {
          "ip": {
            "type": "string",
            "description": "This is the address of the gateway. It can be an IPv4 address like 1.1.1.1 or a fully qualified domain name like my-sip-trunk.pstn.twilio.com."
          },
          "port": {
            "type": "number",
            "description": "This is the port number of the gateway. Default is 5060.\n\n@default 5060",
            "minimum": 1,
            "maximum": 65535
          },
          "netmask": {
            "type": "number",
            "description": "This is the netmask of the gateway. Defaults to 32.\n\n@default 32",
            "minimum": 24,
            "maximum": 32
          },
          "inboundEnabled": {
            "type": "boolean",
            "description": "This is whether inbound calls are allowed from this gateway. Default is true.\n\n@default true"
          },
          "outboundEnabled": {
            "type": "boolean",
            "description": "This is whether outbound calls should be sent to this gateway. Default is true.\n\nNote, if netmask is less than 32, it doesn't affect the outbound IPs that are tried. 1 attempt is made to `ip:port`.\n\n@default true"
          },
          "outboundProtocol": {
            "type": "string",
            "description": "This is the protocol to use for SIP signaling outbound calls. Default is udp.\n\n@default udp",
            "enum": [
              "tls/srtp",
              "tcp",
              "tls",
              "udp"
            ]
          },
          "optionsPingEnabled": {
            "type": "boolean",
            "description": "This is whether to send options ping to the gateway. This can be used to check if the gateway is reachable. Default is false.\n\nThis is useful for high availability setups where you want to check if the gateway is reachable before routing calls to it. Note, if no gateway for a trunk is reachable, outbound calls will be rejected.\n\n@default false"
          }
        },
        "required": [
          "ip"
        ]
      },
      "SipTrunkOutboundSipRegisterPlan": {
        "type": "object",
        "properties": {
          "domain": {
            "type": "string"
          },
          "username": {
            "type": "string"
          },
          "realm": {
            "type": "string"
          }
        }
      },
      "SipTrunkOutboundAuthenticationPlan": {
        "type": "object",
        "properties": {
          "authPassword": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "authUsername": {
            "type": "string"
          },
          "sipRegisterPlan": {
            "description": "This can be used to configure if SIP register is required by the SIP trunk. If not provided, no SIP registration will be attempted.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SipTrunkOutboundSipRegisterPlan"
              }
            ]
          }
        }
      },
      "SbcConfiguration": {
        "type": "object",
        "properties": {}
      },
      "CreateByoSipTrunkCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This can be used to bring your own SIP trunks or to connect to a Carrier.",
            "enum": [
              "byo-sip-trunk"
            ]
          },
          "gateways": {
            "description": "This is the list of SIP trunk's gateways.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SipTrunkGateway"
            }
          },
          "outboundAuthenticationPlan": {
            "description": "This can be used to configure the outbound authentication if required by the SIP trunk.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SipTrunkOutboundAuthenticationPlan"
              }
            ]
          },
          "outboundLeadingPlusEnabled": {
            "type": "boolean",
            "description": "This ensures the outbound origination attempts have a leading plus. Defaults to false to match conventional telecom behavior.\n\nUsage:\n- Vonage/Twilio requires leading plus for all outbound calls. Set this to true.\n\n@default false"
          },
          "techPrefix": {
            "type": "string",
            "description": "This can be used to configure the tech prefix on outbound calls. This is an advanced property.",
            "maxLength": 10000
          },
          "sipDiversionHeader": {
            "type": "string",
            "description": "This can be used to enable the SIP diversion header for authenticating the calling number if the SIP trunk supports it. This is an advanced property.",
            "maxLength": 10000
          },
          "sbcConfiguration": {
            "description": "This is an advanced configuration for enterprise deployments. This uses the onprem SBC to trunk into the SIP trunk's `gateways`, rather than the managed SBC provided by Vapi.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SbcConfiguration"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "gateways"
        ]
      },
      "CreateCartesiaCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "cartesia"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CloudflareR2BucketPlan": {
        "type": "object",
        "properties": {
          "accessKeyId": {
            "type": "string",
            "description": "Cloudflare R2 Access key ID."
          },
          "secretAccessKey": {
            "type": "string",
            "description": "Cloudflare R2 access key secret. This is not returned in the API."
          },
          "url": {
            "type": "string",
            "description": "Cloudflare R2 base url."
          },
          "name": {
            "type": "string",
            "description": "This is the name of the bucket."
          },
          "path": {
            "type": "string",
            "description": "This is the path where call artifacts will be stored.\n\nUsage:\n- To store call artifacts in a specific folder, set this to the full path. Eg. \"/folder-name1/folder-name2\".\n- To store call artifacts in the root of the bucket, leave this blank.\n\n@default \"/\""
          }
        },
        "required": [
          "name"
        ]
      },
      "CreateCloudflareCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "cloudflare"
            ],
            "description": "Credential provider. Only allowed value is cloudflare"
          },
          "accountId": {
            "type": "string",
            "description": "Cloudflare Account Id."
          },
          "apiKey": {
            "type": "string",
            "description": "Cloudflare API Key / Token."
          },
          "accountEmail": {
            "type": "string",
            "description": "Cloudflare Account Email."
          },
          "bucketPlan": {
            "description": "This is the bucket plan that can be provided to store call artifacts in R2",
            "allOf": [
              {
                "$ref": "#/components/schemas/CloudflareR2BucketPlan"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider"
        ]
      },
      "OAuth2AuthenticationPlan": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "oauth2",
              "aws-sts"
            ]
          },
          "url": {
            "type": "string",
            "description": "This is the OAuth2 URL."
          },
          "clientId": {
            "type": "string",
            "description": "This is the OAuth2 client ID."
          },
          "clientSecret": {
            "type": "string",
            "description": "This is the OAuth2 client secret."
          },
          "scope": {
            "type": "string",
            "description": "This is the scope of the OAuth2 token.",
            "maxLength": 1000
          }
        },
        "required": [
          "type",
          "url",
          "clientId",
          "clientSecret"
        ]
      },
      "CreateCustomLLMCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "custom-llm"
            ]
          },
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "authenticationPlan": {
            "description": "This is the authentication plan. Currently supports OAuth2 RFC 6749. To use Bearer authentication, use apiKey",
            "allOf": [
              {
                "$ref": "#/components/schemas/OAuth2AuthenticationPlan"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateDeepgramCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "deepgram"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "apiUrl": {
            "type": "string",
            "description": "This can be used to point to an onprem Deepgram instance. Defaults to api.deepgram.com."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateDeepInfraCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "deepinfra"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateDeepSeekCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "deep-seek"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateElevenLabsCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "11labs"
            ]
          },
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "GcpKey": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of the key. Most likely, this is \"service_account\"."
          },
          "projectId": {
            "type": "string",
            "description": "This is the ID of the Google Cloud project associated with this key."
          },
          "privateKeyId": {
            "type": "string",
            "description": "This is the unique identifier for the private key."
          },
          "privateKey": {
            "type": "string",
            "description": "This is the private key in PEM format.\n\nNote: This is not returned in the API."
          },
          "clientEmail": {
            "type": "string",
            "description": "This is the email address associated with the service account."
          },
          "clientId": {
            "type": "string",
            "description": "This is the unique identifier for the client."
          },
          "authUri": {
            "type": "string",
            "description": "This is the URI for the auth provider's authorization endpoint."
          },
          "tokenUri": {
            "type": "string",
            "description": "This is the URI for the auth provider's token endpoint."
          },
          "authProviderX509CertUrl": {
            "type": "string",
            "description": "This is the URL of the public x509 certificate for the auth provider."
          },
          "clientX509CertUrl": {
            "type": "string",
            "description": "This is the URL of the public x509 certificate for the client."
          },
          "universeDomain": {
            "type": "string",
            "description": "This is the domain associated with the universe this service account belongs to."
          }
        },
        "required": [
          "type",
          "projectId",
          "privateKeyId",
          "privateKey",
          "clientEmail",
          "clientId",
          "authUri",
          "tokenUri",
          "authProviderX509CertUrl",
          "clientX509CertUrl",
          "universeDomain"
        ]
      },
      "BucketPlan": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "This is the name of the bucket."
          },
          "region": {
            "type": "string",
            "description": "This is the region of the bucket.\n\nUsage:\n- If `credential.type` is `aws`, then this is required.\n- If `credential.type` is `gcp`, then this is optional since GCP allows buckets to be accessed without a region but region is required for data residency requirements. Read here: https://cloud.google.com/storage/docs/request-endpoints"
          },
          "path": {
            "type": "string",
            "description": "This is the path where call artifacts will be stored.\n\nUsage:\n- To store call artifacts in a specific folder, set this to the full path. Eg. \"/folder-name1/folder-name2\".\n- To store call artifacts in the root of the bucket, leave this blank.\n\n@default \"/\""
          },
          "hmacAccessKey": {
            "type": "string",
            "description": "This is the HMAC access key offered by GCP for interoperability with S3 clients. Here is the guide on how to create: https://cloud.google.com/storage/docs/authentication/managing-hmackeys#console\n\nUsage:\n- If `credential.type` is `gcp`, then this is required.\n- If `credential.type` is `aws`, then this is not required since credential.awsAccessKeyId is used instead."
          },
          "hmacSecret": {
            "type": "string",
            "description": "This is the secret for the HMAC access key. Here is the guide on how to create: https://cloud.google.com/storage/docs/authentication/managing-hmackeys#console\n\nUsage:\n- If `credential.type` is `gcp`, then this is required.\n- If `credential.type` is `aws`, then this is not required since credential.awsSecretAccessKey is used instead.\n\nNote: This is not returned in the API."
          }
        },
        "required": [
          "name"
        ]
      },
      "CreateGcpCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "gcp"
            ]
          },
          "gcpKey": {
            "description": "This is the GCP key. This is the JSON that can be generated in the Google Cloud Console at https://console.cloud.google.com/iam-admin/serviceaccounts/details/<service-account-id>/keys.\n\nThe schema is identical to the JSON that GCP outputs.",
            "allOf": [
              {
                "$ref": "#/components/schemas/GcpKey"
              }
            ]
          },
          "bucketPlan": {
            "description": "This is the bucket plan that can be provided to store call artifacts in GCP.",
            "allOf": [
              {
                "$ref": "#/components/schemas/BucketPlan"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "gcpKey"
        ]
      },
      "CreateGladiaCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "gladia"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateGoHighLevelCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "gohighlevel"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateGroqCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "groq"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateLangfuseCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "langfuse"
            ]
          },
          "publicKey": {
            "type": "string",
            "description": "The public key for Langfuse project. Eg: pk-lf-..."
          },
          "apiKey": {
            "type": "string",
            "description": "The secret key for Langfuse project. Eg: sk-lf-... .This is not returned in the API."
          },
          "apiUrl": {
            "type": "string",
            "description": "The host URL for Langfuse project. Eg: https://cloud.langfuse.com"
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "publicKey",
          "apiKey",
          "apiUrl"
        ]
      },
      "CreateLmntCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "lmnt"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateMakeCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "make"
            ]
          },
          "teamId": {
            "type": "string",
            "description": "Team ID"
          },
          "region": {
            "type": "string",
            "description": "Region of your application. For example: eu1, eu2, us1, us2"
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "teamId",
          "region",
          "apiKey"
        ]
      },
      "CreateOpenAICredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "openai"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateOpenRouterCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "openrouter"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreatePerplexityAICredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "perplexity-ai"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreatePlayHTCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "playht"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "userId": {
            "type": "string"
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "userId"
        ]
      },
      "CreateRimeAICredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "rime-ai"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateRunpodCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "runpod"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateS3CredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "s3"
            ],
            "description": "Credential provider. Only allowed value is s3"
          },
          "awsAccessKeyId": {
            "type": "string",
            "description": "AWS access key ID."
          },
          "awsSecretAccessKey": {
            "type": "string",
            "description": "AWS access key secret. This is not returned in the API."
          },
          "region": {
            "type": "string",
            "description": "AWS region in which the S3 bucket is located."
          },
          "s3BucketName": {
            "type": "string",
            "description": "AWS S3 bucket name."
          },
          "s3PathPrefix": {
            "type": "string",
            "description": "The path prefix for the uploaded recording. Ex. \"recordings/\""
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "awsAccessKeyId",
          "awsSecretAccessKey",
          "region",
          "s3BucketName",
          "s3PathPrefix"
        ]
      },
      "SupabaseBucketPlan": {
        "type": "object",
        "properties": {
          "region": {
            "type": "string",
            "description": "This is the S3 Region. It should look like us-east-1\nIt should be one of the supabase regions defined in the SUPABASE_REGION enum\nCheck https://supabase.com/docs/guides/platform/regions for up to date regions",
            "enum": [
              "us-west-1",
              "us-east-1",
              "us-east-2",
              "ca-central-1",
              "eu-west-1",
              "eu-west-2",
              "eu-west-3",
              "eu-central-1",
              "eu-central-2",
              "eu-north-1",
              "ap-south-1",
              "ap-southeast-1",
              "ap-northeast-1",
              "ap-northeast-2",
              "ap-southeast-2",
              "sa-east-1"
            ]
          },
          "url": {
            "type": "string",
            "description": "This is the S3 compatible URL for Supabase S3\nThis should look like https://<project-ID>.supabase.co/storage/v1/s3"
          },
          "accessKeyId": {
            "type": "string",
            "description": "This is the Supabase S3 Access Key ID.\nThe user creates this in the Supabase project Storage settings"
          },
          "secretAccessKey": {
            "type": "string",
            "description": "This is the Supabase S3 Secret Access Key.\nThe user creates this in the Supabase project Storage settings along with the access key id"
          },
          "name": {
            "type": "string",
            "description": "This is the Supabase S3 Bucket Name.\nThe user must create this in Supabase under Storage > Buckets\nA bucket that does not exist will not be checked now, but file uploads will fail"
          },
          "path": {
            "type": "string",
            "description": "This is the Supabase S3 Bucket Folder Path.\nThe user can create this in Supabase under Storage > Buckets\nA path that does not exist will not be checked now, but file uploads will fail\nA Path is like a folder in the bucket\nEg. If the bucket is called \"my-bucket\" and the path is \"my-folder\", the full path is \"my-bucket/my-folder\""
          }
        },
        "required": [
          "region",
          "url",
          "accessKeyId",
          "secretAccessKey",
          "name"
        ]
      },
      "CreateSupabaseCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "supabase"
            ],
            "description": "This is for supabase storage."
          },
          "bucketPlan": {
            "$ref": "#/components/schemas/SupabaseBucketPlan"
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider"
        ]
      },
      "CreateSmallestAICredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "smallest-ai"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateTavusCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "tavus"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateTogetherAICredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "together-ai"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateTwilioCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "twilio"
            ]
          },
          "authToken": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "apiSecret": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "accountSid": {
            "type": "string"
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "accountSid"
        ]
      },
      "CreateVonageCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "vonage"
            ]
          },
          "apiSecret": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "apiKey": {
            "type": "string"
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiSecret",
          "apiKey"
        ]
      },
      "CreateWebhookCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "webhook"
            ]
          },
          "authenticationPlan": {
            "description": "This is the authentication plan. Currently supports OAuth2 RFC 6749.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OAuth2AuthenticationPlan"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "authenticationPlan"
        ]
      },
      "CreateXAiCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the api key for Grok in XAi's console. Get it from here: https://console.x.ai",
            "enum": [
              "xai"
            ]
          },
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateGoogleCalendarOAuth2ClientCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "google.calendar.oauth2-client"
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider"
        ]
      },
      "CreateGoogleCalendarOAuth2AuthorizationCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "google.calendar.oauth2-authorization"
            ]
          },
          "authorizationId": {
            "type": "string",
            "description": "The authorization ID for the OAuth2 authorization"
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "authorizationId"
        ]
      },
      "CreateGoogleSheetsOAuth2AuthorizationCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "google.sheets.oauth2-authorization"
            ]
          },
          "authorizationId": {
            "type": "string",
            "description": "The authorization ID for the OAuth2 authorization"
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "authorizationId"
        ]
      },
      "CreateSlackOAuth2AuthorizationCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "slack.oauth2-authorization"
            ]
          },
          "authorizationId": {
            "type": "string",
            "description": "The authorization ID for the OAuth2 authorization"
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "authorizationId"
        ]
      },
      "TransferAssistantHookAction": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of action - must be \"transfer\"",
            "enum": [
              "transfer"
            ]
          },
          "destination": {
            "description": "This is the destination details for the transfer - can be a phone number or SIP URI",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "FunctionCallAssistantHookAction": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "function"
            ],
            "description": "The type of tool. \"function\" for Function tool."
          },
          "async": {
            "type": "boolean",
            "example": false,
            "description": "This determines if the tool is async.\n\n  If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.\n\n  If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.\n\n  Defaults to synchronous (`false`)."
          },
          "server": {
            "description": "\n  This is the server where a `tool-calls` webhook will be sent.\n\n  Notes:\n  - Webhook is sent to this server when a tool call is made.\n  - Webhook contains the call, assistant, and phone number objects.\n  - Webhook contains the variables set on the assistant.\n  - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.\n  - Webhook expects a response with tool call result.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "SayAssistantHookAction": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of action - must be \"say\"",
            "enum": [
              "say"
            ]
          },
          "exact": {
            "type": "object",
            "description": "This is the message to say"
          }
        },
        "required": [
          "type",
          "exact"
        ]
      },
      "AssistantHookFilter": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of filter - currently only \"oneOf\" is supported",
            "enum": [
              "oneOf"
            ],
            "maxLength": 1000
          },
          "key": {
            "type": "string",
            "description": "This is the key to filter on (e.g. \"call.endedReason\")",
            "maxLength": 1000
          },
          "oneOf": {
            "description": "This is the array of possible values to match against",
            "type": "array",
            "items": {
              "type": "string",
              "maxLength": 1000
            }
          }
        },
        "required": [
          "type",
          "key",
          "oneOf"
        ]
      },
      "AssistantHookCallEnding": {
        "type": "object",
        "properties": {
          "on": {
            "type": "string",
            "description": "This is the event that triggers this hook",
            "enum": [
              "call.ending"
            ],
            "maxLength": 1000
          },
          "do": {
            "type": "array",
            "description": "This is the set of actions to perform when the hook triggers",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TransferAssistantHookAction",
                  "title": "TransferAssistantHookAction"
                },
                {
                  "$ref": "#/components/schemas/FunctionCallAssistantHookAction",
                  "title": "FunctionCallAssistantHookAction"
                }
              ]
            }
          },
          "filters": {
            "description": "This is the set of filters that must match for the hook to trigger",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssistantHookFilter"
            }
          }
        },
        "required": [
          "on",
          "do"
        ]
      },
      "AssistantHookAssistantSpeechInterrupted": {
        "type": "object",
        "properties": {
          "on": {
            "type": "string",
            "description": "This is the event that triggers this hook",
            "enum": [
              "assistant.speech.interrupted"
            ],
            "maxLength": 1000
          },
          "do": {
            "type": "array",
            "description": "This is the set of actions to perform when the hook triggers",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TransferAssistantHookAction",
                  "title": "TransferAssistantHookAction"
                },
                {
                  "$ref": "#/components/schemas/FunctionCallAssistantHookAction",
                  "title": "FunctionCallAssistantHookAction"
                },
                {
                  "$ref": "#/components/schemas/SayAssistantHookAction",
                  "title": "SayAssistantHookAction"
                }
              ]
            }
          }
        },
        "required": [
          "on",
          "do"
        ]
      },
      "AssistantHookCustomerSpeechInterrupted": {
        "type": "object",
        "properties": {
          "on": {
            "type": "string",
            "description": "This is the event that triggers this hook",
            "enum": [
              "customer.speech.interrupted"
            ],
            "maxLength": 1000
          },
          "do": {
            "type": "array",
            "description": "This is the set of actions to perform when the hook triggers",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TransferAssistantHookAction",
                  "title": "TransferAssistantHookAction"
                },
                {
                  "$ref": "#/components/schemas/FunctionCallAssistantHookAction",
                  "title": "FunctionCallAssistantHookAction"
                },
                {
                  "$ref": "#/components/schemas/SayAssistantHookAction",
                  "title": "SayAssistantHookAction"
                }
              ]
            }
          }
        },
        "required": [
          "on",
          "do"
        ]
      },
      "VoicemailDetectionBackoffPlan": {
        "type": "object",
        "properties": {
          "startAtSeconds": {
            "type": "number",
            "description": "This is the number of seconds to wait before starting the first retry attempt.",
            "minimum": 0,
            "default": 5
          },
          "frequencySeconds": {
            "type": "number",
            "description": "This is the interval in seconds between retry attempts.",
            "minimum": 2.5,
            "default": 5
          },
          "maxRetries": {
            "type": "number",
            "description": "This is the maximum number of retry attempts before giving up.",
            "minimum": 1,
            "maximum": 10,
            "default": 6
          }
        }
      },
      "GoogleVoicemailDetectionPlan": {
        "type": "object",
        "properties": {
          "beepMaxAwaitSeconds": {
            "type": "number",
            "description": "This is the maximum duration from the start of the call that we will wait for a voicemail beep, before speaking our message\n\n- If we detect a voicemail beep before this, we will speak the message at that point.\n\n- Setting too low a value means that the bot will start speaking its voicemail message too early. If it does so before the actual beep, it will get cut off. You should definitely tune this to your use case.\n\n@default 30\n@min 0\n@max 60",
            "minimum": 0,
            "maximum": 30,
            "default": 30
          },
          "provider": {
            "type": "string",
            "description": "This is the provider to use for voicemail detection.",
            "enum": [
              "google"
            ]
          },
          "backoffPlan": {
            "description": "This is the backoff plan for the voicemail detection.",
            "allOf": [
              {
                "$ref": "#/components/schemas/VoicemailDetectionBackoffPlan"
              }
            ]
          }
        },
        "required": [
          "provider"
        ]
      },
      "OpenAIVoicemailDetectionPlan": {
        "type": "object",
        "properties": {
          "beepMaxAwaitSeconds": {
            "type": "number",
            "description": "This is the maximum duration from the start of the call that we will wait for a voicemail beep, before speaking our message\n\n- If we detect a voicemail beep before this, we will speak the message at that point.\n\n- Setting too low a value means that the bot will start speaking its voicemail message too early. If it does so before the actual beep, it will get cut off. You should definitely tune this to your use case.\n\n@default 30\n@min 0\n@max 60",
            "minimum": 0,
            "maximum": 30,
            "default": 30
          },
          "provider": {
            "type": "string",
            "description": "This is the provider to use for voicemail detection.",
            "enum": [
              "openai"
            ]
          },
          "backoffPlan": {
            "description": "This is the backoff plan for the voicemail detection.",
            "allOf": [
              {
                "$ref": "#/components/schemas/VoicemailDetectionBackoffPlan"
              }
            ]
          }
        },
        "required": [
          "provider"
        ]
      },
      "TwilioVoicemailDetectionPlan": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the provider to use for voicemail detection.",
            "enum": [
              "twilio"
            ]
          },
          "voicemailDetectionTypes": {
            "type": "array",
            "description": "These are the AMD messages from Twilio that are considered as voicemail. Default is ['machine_end_beep', 'machine_end_silence'].\n\n@default {Array} ['machine_end_beep', 'machine_end_silence']",
            "enum": [
              "machine_start",
              "human",
              "fax",
              "unknown",
              "machine_end_beep",
              "machine_end_silence",
              "machine_end_other"
            ],
            "example": [
              "machine_end_beep",
              "machine_end_silence"
            ],
            "items": {
              "type": "string",
              "enum": [
                "machine_start",
                "human",
                "fax",
                "unknown",
                "machine_end_beep",
                "machine_end_silence",
                "machine_end_other"
              ]
            }
          },
          "enabled": {
            "type": "boolean",
            "description": "This sets whether the assistant should detect voicemail. Defaults to true.\n\n@default true"
          },
          "machineDetectionTimeout": {
            "type": "number",
            "description": "The number of seconds that Twilio should attempt to perform answering machine detection before timing out and returning AnsweredBy as unknown. Default is 30 seconds.\n\nIncreasing this value will provide the engine more time to make a determination. This can be useful when DetectMessageEnd is provided in the MachineDetection parameter and there is an expectation of long answering machine greetings that can exceed 30 seconds.\n\nDecreasing this value will reduce the amount of time the engine has to make a determination. This can be particularly useful when the Enable option is provided in the MachineDetection parameter and you want to limit the time for initial detection.\n\nCheck the [Twilio docs](https://www.twilio.com/docs/voice/answering-machine-detection#optional-api-tuning-parameters) for more info.\n\n@default 30",
            "minimum": 3,
            "maximum": 59
          },
          "machineDetectionSpeechThreshold": {
            "type": "number",
            "description": "The number of milliseconds that is used as the measuring stick for the length of the speech activity. Durations lower than this value will be interpreted as a human, longer as a machine. Default is 2400 milliseconds.\n\nIncreasing this value will reduce the chance of a False Machine (detected machine, actually human) for a long human greeting (e.g., a business greeting) but increase the time it takes to detect a machine.\n\nDecreasing this value will reduce the chances of a False Human (detected human, actually machine) for short voicemail greetings. The value of this parameter may need to be reduced by more than 1000ms to detect very short voicemail greetings. A reduction of that significance can result in increased False Machine detections. Adjusting the MachineDetectionSpeechEndThreshold is likely the better approach for short voicemails. Decreasing MachineDetectionSpeechThreshold will also reduce the time it takes to detect a machine.\n\nCheck the [Twilio docs](https://www.twilio.com/docs/voice/answering-machine-detection#optional-api-tuning-parameters) for more info.\n\n@default 2400",
            "minimum": 1000,
            "maximum": 6000
          },
          "machineDetectionSpeechEndThreshold": {
            "type": "number",
            "description": "The number of milliseconds of silence after speech activity at which point the speech activity is considered complete. Default is 1200 milliseconds.\n\nIncreasing this value will typically be used to better address the short voicemail greeting scenarios. For short voicemails, there is typically 1000-2000ms of audio followed by 1200-2400ms of silence and then additional audio before the beep. Increasing the MachineDetectionSpeechEndThreshold to ~2500ms will treat the 1200-2400ms of silence as a gap in the greeting but not the end of the greeting and will result in a machine detection. The downsides of such a change include:\n- Increasing the delay for human detection by the amount you increase this parameter, e.g., a change of 1200ms to 2500ms increases human detection delay by 1300ms.\n- Cases where a human has two utterances separated by a period of silence (e.g. a \"Hello\", then 2000ms of silence, and another \"Hello\") may be interpreted as a machine.\n\nDecreasing this value will result in faster human detection. The consequence is that it can lead to increased False Human (detected human, actually machine) detections because a silence gap in a voicemail greeting (not necessarily just in short voicemail scenarios) can be incorrectly interpreted as the end of speech.\n\nCheck the [Twilio docs](https://www.twilio.com/docs/voice/answering-machine-detection#optional-api-tuning-parameters) for more info.\n\n@default 1200",
            "minimum": 500,
            "maximum": 5000
          },
          "machineDetectionSilenceTimeout": {
            "type": "number",
            "description": "The number of milliseconds of initial silence after which an unknown AnsweredBy result will be returned. Default is 5000 milliseconds.\n\nIncreasing this value will result in waiting for a longer period of initial silence before returning an 'unknown' AMD result.\n\nDecreasing this value will result in waiting for a shorter period of initial silence before returning an 'unknown' AMD result.\n\nCheck the [Twilio docs](https://www.twilio.com/docs/voice/answering-machine-detection#optional-api-tuning-parameters) for more info.\n\n@default 5000",
            "minimum": 2000,
            "maximum": 10000
          }
        },
        "required": [
          "provider"
        ]
      },
      "VapiVoicemailDetectionPlan": {
        "type": "object",
        "properties": {
          "beepMaxAwaitSeconds": {
            "type": "number",
            "description": "This is the maximum duration from the start of the call that we will wait for a voicemail beep, before speaking our message\n\n- If we detect a voicemail beep before this, we will speak the message at that point.\n\n- Setting too low a value means that the bot will start speaking its voicemail message too early. If it does so before the actual beep, it will get cut off. You should definitely tune this to your use case.\n\n@default 30\n@min 0\n@max 60",
            "minimum": 0,
            "maximum": 30,
            "default": 30
          },
          "provider": {
            "type": "string",
            "description": "This is the provider to use for voicemail detection.",
            "enum": [
              "vapi"
            ]
          },
          "backoffPlan": {
            "description": "This is the backoff plan for the voicemail detection.",
            "allOf": [
              {
                "$ref": "#/components/schemas/VoicemailDetectionBackoffPlan"
              }
            ]
          }
        },
        "required": [
          "provider"
        ]
      },
      "CompliancePlan": {
        "type": "object",
        "properties": {
          "hipaaEnabled": {
            "type": "boolean",
            "description": "When this is enabled, no logs, recordings, or transcriptions will be stored.\nAt the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.",
            "example": {
              "hipaaEnabled": false
            }
          },
          "pciEnabled": {
            "type": "boolean",
            "description": "When this is enabled, the user will be restricted to use PCI-compliant providers, and no logs or transcripts are stored.\nAt the end of the call, you will receive an end-of-call-report message to store on your server. Defaults to false.",
            "example": {
              "pciEnabled": false
            }
          }
        }
      },
      "StructuredDataPlan": {
        "type": "object",
        "properties": {
          "messages": {
            "description": "These are the messages used to generate the structured data.\n\n@default: ```\n[\n  {\n    \"role\": \"system\",\n    \"content\": \"You are an expert data extractor. You will be given a transcript of a call. Extract structured data per the JSON Schema. DO NOT return anything except the structured data.\\n\\nJson Schema:\\\\n{{schema}}\\n\\nOnly respond with the JSON.\"\n  },\n  {\n    \"role\": \"user\",\n    \"content\": \"Here is the transcript:\\n\\n{{transcript}}\\n\\n. Here is the ended reason of the call:\\n\\n{{endedReason}}\\n\\n\"\n  }\n]```\n\nYou can customize by providing any messages you want.\n\nHere are the template variables available:\n- {{transcript}}: the transcript of the call from `call.artifact.transcript`- {{systemPrompt}}: the system prompt of the call from `assistant.model.messages[type=system].content`- {{schema}}: the schema of the structured data from `structuredDataPlan.schema`- {{endedReason}}: the ended reason of the call from `call.endedReason`",
            "type": "array",
            "items": {
              "type": "object"
            }
          },
          "enabled": {
            "type": "boolean",
            "description": "This determines whether structured data is generated and stored in `call.analysis.structuredData`. Defaults to false.\n\nUsage:\n- If you want to extract structured data, set this to true and provide a `schema`.\n\n@default false"
          },
          "schema": {
            "description": "This is the schema of the structured data. The output is stored in `call.analysis.structuredData`.\n\nComplete guide on JSON Schema can be found [here](https://ajv.js.org/json-schema.html#json-data-type).",
            "allOf": [
              {
                "$ref": "#/components/schemas/JsonSchema"
              }
            ]
          },
          "timeoutSeconds": {
            "type": "number",
            "description": "This is how long the request is tried before giving up. When request times out, `call.analysis.structuredData` will be empty.\n\nUsage:\n- To guarantee the structured data is generated, set this value high. Note, this will delay the end of call report in cases where model is slow to respond.\n\n@default 5 seconds",
            "minimum": 1,
            "maximum": 60
          }
        }
      },
      "StructuredDataMultiPlan": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "This is the key of the structured data plan in the catalog."
          },
          "plan": {
            "description": "This is an individual structured data plan in the catalog.",
            "allOf": [
              {
                "$ref": "#/components/schemas/StructuredDataPlan"
              }
            ]
          }
        },
        "required": [
          "key",
          "plan"
        ]
      },
      "SuccessEvaluationPlan": {
        "type": "object",
        "properties": {
          "rubric": {
            "type": "string",
            "enum": [
              "NumericScale",
              "DescriptiveScale",
              "Checklist",
              "Matrix",
              "PercentageScale",
              "LikertScale",
              "AutomaticRubric",
              "PassFail"
            ],
            "description": "This enforces the rubric of the evaluation. The output is stored in `call.analysis.successEvaluation`.\n\nOptions include:\n- 'NumericScale': A scale of 1 to 10.\n- 'DescriptiveScale': A scale of Excellent, Good, Fair, Poor.\n- 'Checklist': A checklist of criteria and their status.\n- 'Matrix': A grid that evaluates multiple criteria across different performance levels.\n- 'PercentageScale': A scale of 0% to 100%.\n- 'LikertScale': A scale of Strongly Agree, Agree, Neutral, Disagree, Strongly Disagree.\n- 'AutomaticRubric': Automatically break down evaluation into several criteria, each with its own score.\n- 'PassFail': A simple 'true' if call passed, 'false' if not.\n\nDefault is 'PassFail'."
          },
          "messages": {
            "description": "These are the messages used to generate the success evaluation.\n\n@default: ```\n[\n  {\n    \"role\": \"system\",\n    \"content\": \"You are an expert call evaluator. You will be given a transcript of a call and the system prompt of the AI participant. Determine if the call was successful based on the objectives inferred from the system prompt. DO NOT return anything except the result.\\n\\nRubric:\\\\n{{rubric}}\\n\\nOnly respond with the result.\"\n  },\n  {\n    \"role\": \"user\",\n    \"content\": \"Here is the transcript:\\n\\n{{transcript}}\\n\\n\"\n  },\n  {\n    \"role\": \"user\",\n    \"content\": \"Here was the system prompt of the call:\\n\\n{{systemPrompt}}\\n\\n. Here is the ended reason of the call:\\n\\n{{endedReason}}\\n\\n\"\n  }\n]```\n\nYou can customize by providing any messages you want.\n\nHere are the template variables available:\n- {{transcript}}: the transcript of the call from `call.artifact.transcript`- {{systemPrompt}}: the system prompt of the call from `assistant.model.messages[type=system].content`- {{rubric}}: the rubric of the success evaluation from `successEvaluationPlan.rubric`- {{endedReason}}: the ended reason of the call from `call.endedReason`",
            "type": "array",
            "items": {
              "type": "object"
            }
          },
          "enabled": {
            "type": "boolean",
            "description": "This determines whether a success evaluation is generated and stored in `call.analysis.successEvaluation`. Defaults to true.\n\nUsage:\n- If you want to disable the success evaluation, set this to false.\n\n@default true"
          },
          "timeoutSeconds": {
            "type": "number",
            "description": "This is how long the request is tried before giving up. When request times out, `call.analysis.successEvaluation` will be empty.\n\nUsage:\n- To guarantee the success evaluation is generated, set this value high. Note, this will delay the end of call report in cases where model is slow to respond.\n\n@default 5 seconds",
            "minimum": 1,
            "maximum": 60
          }
        }
      },
      "AnalysisPlan": {
        "type": "object",
        "properties": {
          "summaryPlan": {
            "description": "This is the plan for generating the summary of the call. This outputs to `call.analysis.summary`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SummaryPlan"
              }
            ]
          },
          "structuredDataPlan": {
            "description": "This is the plan for generating the structured data from the call. This outputs to `call.analysis.structuredData`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/StructuredDataPlan"
              }
            ]
          },
          "structuredDataMultiPlan": {
            "description": "This is an array of structured data plan catalogs. Each entry includes a `key` and a `plan` for generating the structured data from the call. This outputs to `call.analysis.structuredDataMulti`.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StructuredDataMultiPlan"
            }
          },
          "successEvaluationPlan": {
            "description": "This is the plan for generating the success evaluation of the call. This outputs to `call.analysis.successEvaluation`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SuccessEvaluationPlan"
              }
            ]
          }
        }
      },
      "MessagePlan": {
        "type": "object",
        "properties": {
          "idleMessages": {
            "description": "This are the messages that the assistant will speak when the user hasn't responded for `idleTimeoutSeconds`. Each time the timeout is triggered, a random message will be chosen from this array.\n\nUsage:\n- If user gets distracted and doesn't respond for a while, this can be used to grab their attention.\n- If the transcriber doesn't pick up what the user said, this can be used to ask the user to repeat themselves. (From the perspective of the assistant, the conversation is idle since it didn't \"hear\" any user messages.)\n\n@default null (no idle message is spoken)",
            "type": "array",
            "items": {
              "type": "string",
              "maxLength": 1000
            }
          },
          "idleMessageMaxSpokenCount": {
            "type": "number",
            "description": "This determines the maximum number of times `idleMessages` can be spoken during the call.\n\n@default 3",
            "minimum": 1,
            "maximum": 10
          },
          "idleMessageResetCountOnUserSpeechEnabled": {
            "type": "boolean",
            "description": "This determines whether the idle message count is reset whenever the user speaks.\n\n@default false"
          },
          "idleTimeoutSeconds": {
            "type": "number",
            "description": "This is the timeout in seconds before a message from `idleMessages` is spoken. The clock starts when the assistant finishes speaking and remains active until the user speaks.\n\n@default 10",
            "minimum": 5,
            "maximum": 60
          },
          "silenceTimeoutMessage": {
            "type": "string",
            "description": "This is the message that the assistant will say if the call ends due to silence.\n\nIf unspecified, it will hang up without saying anything.",
            "maxLength": 1000
          }
        }
      },
      "AssistantCustomEndpointingRule": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This endpointing rule is based on the last assistant message before customer started speaking.\n\nFlow:\n- Assistant speaks\n- Customer starts speaking\n- Customer transcription comes in\n- This rule is evaluated on the last assistant message\n- If a match is found based on `regex`, the endpointing timeout is set to `timeoutSeconds`\n\nUsage:\n- If you have yes/no questions in your use case like \"are you interested in a loan?\", you can set a shorter timeout.\n- If you have questions where the customer may pause to look up information like \"what's my account number?\", you can set a longer timeout.",
            "enum": [
              "assistant"
            ]
          },
          "regex": {
            "type": "string",
            "description": "This is the regex pattern to match.\n\nNote:\n- This works by using the `RegExp.test` method in Node.JS. Eg. `/hello/.test(\"hello there\")` will return `true`.\n\nHot tip:\n- In JavaScript, escape `\\` when sending the regex pattern. Eg. `\"hello\\sthere\"` will be sent over the wire as `\"hellosthere\"`. Send `\"hello\\\\sthere\"` instead.\n- `RegExp.test` does substring matching, so `/cat/.test(\"I love cats\")` will return `true`. To do full string matching, send \"^cat$\"."
          },
          "regexOptions": {
            "description": "These are the options for the regex match. Defaults to all disabled.\n\n@default []",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RegexOption"
            }
          },
          "timeoutSeconds": {
            "type": "number",
            "description": "This is the endpointing timeout in seconds, if the rule is matched.",
            "minimum": 0,
            "maximum": 15
          }
        },
        "required": [
          "type",
          "regex",
          "timeoutSeconds"
        ]
      },
      "CustomerCustomEndpointingRule": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This endpointing rule is based on current customer message as they are speaking.\n\nFlow:\n- Assistant speaks\n- Customer starts speaking\n- Customer transcription comes in\n- This rule is evaluated on the current customer transcription\n- If a match is found based on `regex`, the endpointing timeout is set to `timeoutSeconds`\n\nUsage:\n- If you want to wait longer while customer is speaking numbers, you can set a longer timeout.",
            "enum": [
              "customer"
            ]
          },
          "regex": {
            "type": "string",
            "description": "This is the regex pattern to match.\n\nNote:\n- This works by using the `RegExp.test` method in Node.JS. Eg. `/hello/.test(\"hello there\")` will return `true`.\n\nHot tip:\n- In JavaScript, escape `\\` when sending the regex pattern. Eg. `\"hello\\sthere\"` will be sent over the wire as `\"hellosthere\"`. Send `\"hello\\\\sthere\"` instead.\n- `RegExp.test` does substring matching, so `/cat/.test(\"I love cats\")` will return `true`. To do full string matching, send \"^cat$\"."
          },
          "regexOptions": {
            "description": "These are the options for the regex match. Defaults to all disabled.\n\n@default []",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RegexOption"
            }
          },
          "timeoutSeconds": {
            "type": "number",
            "description": "This is the endpointing timeout in seconds, if the rule is matched.",
            "minimum": 0,
            "maximum": 15
          }
        },
        "required": [
          "type",
          "regex",
          "timeoutSeconds"
        ]
      },
      "BothCustomEndpointingRule": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This endpointing rule is based on both the last assistant message and the current customer message as they are speaking.\n\nFlow:\n- Assistant speaks\n- Customer starts speaking\n- Customer transcription comes in\n- This rule is evaluated on the last assistant message and the current customer transcription\n- If assistant message matches `assistantRegex` AND customer message matches `customerRegex`, the endpointing timeout is set to `timeoutSeconds`\n\nUsage:\n- If you want to wait longer while customer is speaking numbers, you can set a longer timeout.",
            "enum": [
              "both"
            ]
          },
          "assistantRegex": {
            "type": "string",
            "description": "This is the regex pattern to match the assistant's message.\n\nNote:\n- This works by using the `RegExp.test` method in Node.JS. Eg. `/hello/.test(\"hello there\")` will return `true`.\n\nHot tip:\n- In JavaScript, escape `\\` when sending the regex pattern. Eg. `\"hello\\sthere\"` will be sent over the wire as `\"hellosthere\"`. Send `\"hello\\\\sthere\"` instead.\n- `RegExp.test` does substring matching, so `/cat/.test(\"I love cats\")` will return `true`. To do full string matching, send \"^cat$\"."
          },
          "assistantRegexOptions": {
            "description": "These are the options for the assistant's message regex match. Defaults to all disabled.\n\n@default []",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RegexOption"
            }
          },
          "customerRegex": {
            "type": "string"
          },
          "customerRegexOptions": {
            "description": "These are the options for the customer's message regex match. Defaults to all disabled.\n\n@default []",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RegexOption"
            }
          },
          "timeoutSeconds": {
            "type": "number",
            "description": "This is the endpointing timeout in seconds, if the rule is matched.",
            "minimum": 0,
            "maximum": 15
          }
        },
        "required": [
          "type",
          "assistantRegex",
          "customerRegex",
          "timeoutSeconds"
        ]
      },
      "VapiSmartEndpointingPlan": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the provider for the smart endpointing plan.",
            "enum": [
              "vapi",
              "livekit"
            ],
            "example": "vapi"
          }
        },
        "required": [
          "provider"
        ]
      },
      "LivekitSmartEndpointingPlan": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the provider for the smart endpointing plan.",
            "enum": [
              "vapi",
              "livekit"
            ],
            "example": "livekit"
          },
          "waitFunction": {
            "type": "string",
            "description": "This expression describes how long the bot will wait to start speaking based on the likelihood that the user has reached an endpoint.\n\nThis is a millisecond valued function. It maps probabilities (real numbers on [0,1]) to milliseconds that the bot should wait before speaking ([0, \\infty]). Any negative values that are returned are set to zero (the bot can't start talking in the past).\n\nA probability of zero represents very high confidence that the caller has stopped speaking, and would like the bot to speak to them. A probability of one represents very high confidence that the caller is still speaking.\n\nUnder the hood, this is parsed into a mathjs expression. Whatever you use to write your expression needs to be valid with respect to mathjs\n\n@default \"20 + 500 * sqrt(x) + 2500 * x^3\"",
            "examples": [
              "70 + 4000 * x",
              "200 + 8000 * x",
              "4000 * (1 - cos(pi * x))"
            ]
          }
        },
        "required": [
          "provider"
        ]
      },
      "TranscriptionEndpointingPlan": {
        "type": "object",
        "properties": {
          "onPunctuationSeconds": {
            "type": "number",
            "description": "The minimum number of seconds to wait after transcription ending with punctuation before sending a request to the model. Defaults to 0.1.\n\nThis setting exists because the transcriber punctuates the transcription when it's more confident that customer has completed a thought.\n\n@default 0.1",
            "minimum": 0,
            "maximum": 3,
            "example": 0.1
          },
          "onNoPunctuationSeconds": {
            "type": "number",
            "description": "The minimum number of seconds to wait after transcription ending without punctuation before sending a request to the model. Defaults to 1.5.\n\nThis setting exists to catch the cases where the transcriber was not confident enough to punctuate the transcription, but the customer is done and has been silent for a long time.\n\n@default 1.5",
            "minimum": 0,
            "maximum": 3,
            "example": 1.5
          },
          "onNumberSeconds": {
            "type": "number",
            "description": "The minimum number of seconds to wait after transcription ending with a number before sending a request to the model. Defaults to 0.4.\n\nThis setting exists because the transcriber will sometimes punctuate the transcription ending with a number, even though the customer hasn't uttered the full number. This happens commonly for long numbers when the customer reads the number in chunks.\n\n@default 0.5",
            "minimum": 0,
            "maximum": 3,
            "example": 0.5
          }
        }
      },
      "StartSpeakingPlan": {
        "type": "object",
        "properties": {
          "waitSeconds": {
            "type": "number",
            "description": "This is how long assistant waits before speaking. Defaults to 0.4.\n\nThis is the minimum it will wait but if there is latency is the pipeline, this minimum will be exceeded. This is intended as a stopgap in case the pipeline is moving too fast.\n\nExample:\n- If model generates tokens and voice generates bytes within 100ms, the pipeline still waits 300ms before outputting speech.\n\nUsage:\n- If the customer is taking long pauses, set this to a higher value.\n- If the assistant is accidentally jumping in too much, set this to a higher value.\n\n@default 0.4",
            "minimum": 0,
            "maximum": 5,
            "example": 0.4
          },
          "smartEndpointingEnabled": {
            "example": false,
            "deprecated": true,
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "type": "string",
                "enum": [
                  "livekit"
                ]
              }
            ]
          },
          "smartEndpointingPlan": {
            "description": "This is the plan for smart endpointing. Pick between Vapi smart endpointing or LiveKit smart endpointing (or nothing). We strongly recommend using livekit endpointing when working in English. LiveKit endpointing is not supported in other languages, yet.\n\nIf this is set, it will override and take precedence over `transcriptionEndpointingPlan`.\nThis plan will still be overridden by any matching `customEndpointingRules`.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/VapiSmartEndpointingPlan",
                "title": "Vapi"
              },
              {
                "$ref": "#/components/schemas/LivekitSmartEndpointingPlan",
                "title": "Livekit"
              }
            ]
          },
          "customEndpointingRules": {
            "type": "array",
            "description": "These are the custom endpointing rules to set an endpointing timeout based on a regex on the customer's speech or the assistant's last message.\n\nUsage:\n- If you have yes/no questions like \"are you interested in a loan?\", you can set a shorter timeout.\n- If you have questions where the customer may pause to look up information like \"what's my account number?\", you can set a longer timeout.\n- If you want to wait longer while customer is enumerating a list of numbers, you can set a longer timeout.\n\nThese rules have the highest precedence and will override both `smartEndpointingPlan` and `transcriptionEndpointingPlan` when a rule is matched.\n\nThe rules are evaluated in order and the first one that matches will be used.\n\nOrder of precedence for endpointing:\n1. customEndpointingRules (if any match)\n2. smartEndpointingPlan (if set)\n3. transcriptionEndpointingPlan\n\n@default []",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/AssistantCustomEndpointingRule",
                  "title": "Assistant"
                },
                {
                  "$ref": "#/components/schemas/CustomerCustomEndpointingRule",
                  "title": "Customer"
                },
                {
                  "$ref": "#/components/schemas/BothCustomEndpointingRule",
                  "title": "Both"
                }
              ]
            }
          },
          "transcriptionEndpointingPlan": {
            "description": "This determines how a customer speech is considered done (endpointing) using the transcription of customer's speech.\n\nOnce an endpoint is triggered, the request is sent to `assistant.model`.\n\nNote: This plan is only used if `smartEndpointingPlan` is not set. If both are provided, `smartEndpointingPlan` takes precedence.\nThis plan will also be overridden by any matching `customEndpointingRules`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TranscriptionEndpointingPlan"
              }
            ]
          }
        }
      },
      "StopSpeakingPlan": {
        "type": "object",
        "properties": {
          "numWords": {
            "type": "number",
            "description": "This is the number of words that the customer has to say before the assistant will stop talking.\n\nWords like \"stop\", \"actually\", \"no\", etc. will always interrupt immediately regardless of this value.\n\nWords like \"okay\", \"yeah\", \"right\" will never interrupt.\n\nWhen set to 0, `voiceSeconds` is used in addition to the transcriptions to determine the customer has started speaking.\n\nDefaults to 0.\n\n@default 0",
            "minimum": 0,
            "maximum": 10,
            "example": 0
          },
          "voiceSeconds": {
            "type": "number",
            "description": "This is the seconds customer has to speak before the assistant stops talking. This uses the VAD (Voice Activity Detection) spike to determine if the customer has started speaking.\n\nConsiderations:\n- A lower value might be more responsive but could potentially pick up non-speech sounds.\n- A higher value reduces false positives but might slightly delay the detection of speech onset.\n\nThis is only used if `numWords` is set to 0.\n\nDefaults to 0.2\n\n@default 0.2",
            "minimum": 0,
            "maximum": 0.5,
            "example": 0.2
          },
          "backoffSeconds": {
            "type": "number",
            "description": "This is the seconds to wait before the assistant will start talking again after being interrupted.\n\nDefaults to 1.\n\n@default 1",
            "minimum": 0,
            "maximum": 10,
            "example": 1
          },
          "acknowledgementPhrases": {
            "description": "These are the phrases that will never interrupt the assistant, even if numWords threshold is met.\nThese are typically acknowledgement or backchanneling phrases.",
            "example": [
              "i understand",
              "i see",
              "i got it",
              "i hear you",
              "im listening",
              "im with you",
              "right",
              "okay",
              "ok",
              "sure",
              "alright",
              "got it",
              "understood",
              "yeah",
              "yes",
              "uh-huh",
              "mm-hmm",
              "gotcha",
              "mhmm",
              "ah",
              "yeah okay",
              "yeah sure"
            ],
            "default": [
              "i understand",
              "i see",
              "i got it",
              "i hear you",
              "im listening",
              "im with you",
              "right",
              "okay",
              "ok",
              "sure",
              "alright",
              "got it",
              "understood",
              "yeah",
              "yes",
              "uh-huh",
              "mm-hmm",
              "gotcha",
              "mhmm",
              "ah",
              "yeah okay",
              "yeah sure"
            ],
            "type": "array",
            "items": {
              "type": "string",
              "maxLength": 240
            }
          },
          "interruptionPhrases": {
            "description": "These are the phrases that will always interrupt the assistant immediately, regardless of numWords.\nThese are typically phrases indicating disagreement or desire to stop.",
            "example": [
              "stop",
              "shut",
              "up",
              "enough",
              "quiet",
              "silence",
              "but",
              "dont",
              "not",
              "no",
              "hold",
              "wait",
              "cut",
              "pause",
              "nope",
              "nah",
              "nevermind",
              "never",
              "bad",
              "actually"
            ],
            "default": [
              "stop",
              "shut",
              "up",
              "enough",
              "quiet",
              "silence",
              "but",
              "dont",
              "not",
              "no",
              "hold",
              "wait",
              "cut",
              "pause",
              "nope",
              "nah",
              "nevermind",
              "never",
              "bad",
              "actually"
            ],
            "type": "array",
            "items": {
              "type": "string",
              "maxLength": 240
            }
          }
        }
      },
      "MonitorPlan": {
        "type": "object",
        "properties": {
          "listenEnabled": {
            "type": "boolean",
            "description": "This determines whether the assistant's calls allow live listening. Defaults to true.\n\nFetch `call.monitor.listenUrl` to get the live listening URL.\n\n@default true",
            "example": false
          },
          "listenAuthenticationEnabled": {
            "type": "boolean",
            "description": "This enables authentication on the `call.monitor.listenUrl`.\n\nIf `listenAuthenticationEnabled` is `true`, the `call.monitor.listenUrl` will require an `Authorization: Bearer <vapi-public-api-key>` header.\n\n@default false",
            "example": false
          },
          "controlEnabled": {
            "type": "boolean",
            "description": "This determines whether the assistant's calls allow live control. Defaults to true.\n\nFetch `call.monitor.controlUrl` to get the live control URL.\n\nTo use, send any control message via a POST request to `call.monitor.controlUrl`. Here are the types of controls supported: https://docs.vapi.ai/api-reference/messages/client-inbound-message\n\n@default true",
            "example": false
          },
          "controlAuthenticationEnabled": {
            "type": "boolean",
            "description": "This enables authentication on the `call.monitor.controlUrl`.\n\nIf `controlAuthenticationEnabled` is `true`, the `call.monitor.controlUrl` will require an `Authorization: Bearer <vapi-public-api-key>` header.\n\n@default false",
            "example": false
          }
        }
      },
      "KeypadInputPlan": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "This keeps track of whether the user has enabled keypad input.\nBy default, it is off.\n\n@default false"
          },
          "timeoutSeconds": {
            "type": "number",
            "description": "This is the time in seconds to wait before processing the input.\nIf the input is not received within this time, the input will be ignored.\nIf set to \"off\", the input will be processed when the user enters a delimiter or immediately if no delimiter is used.\n\n@default 2",
            "minimum": 0,
            "maximum": 10
          },
          "delimiters": {
            "type": "string",
            "description": "This is the delimiter(s) that will be used to process the input.\nCan be '#', '*', or an empty array.",
            "enum": [
              "#",
              "*",
              ""
            ]
          }
        }
      },
      "CreateAssistantDTO": {
        "type": "object",
        "properties": {
          "transcriber": {
            "description": "These are the options for the assistant's transcriber.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/AssemblyAITranscriber",
                "title": "AssemblyAITranscriber"
              },
              {
                "$ref": "#/components/schemas/AzureSpeechTranscriber",
                "title": "AzureSpeechTranscriber"
              },
              {
                "$ref": "#/components/schemas/CustomTranscriber",
                "title": "CustomTranscriber"
              },
              {
                "$ref": "#/components/schemas/DeepgramTranscriber",
                "title": "DeepgramTranscriber"
              },
              {
                "$ref": "#/components/schemas/ElevenLabsTranscriber",
                "title": "ElevenLabsTranscriber"
              },
              {
                "$ref": "#/components/schemas/GladiaTranscriber",
                "title": "GladiaTranscriber"
              },
              {
                "$ref": "#/components/schemas/GoogleTranscriber",
                "title": "GoogleTranscriber"
              },
              {
                "$ref": "#/components/schemas/SpeechmaticsTranscriber",
                "title": "SpeechmaticsTranscriber"
              },
              {
                "$ref": "#/components/schemas/TalkscriberTranscriber",
                "title": "TalkscriberTranscriber"
              },
              {
                "$ref": "#/components/schemas/OpenAITranscriber",
                "title": "OpenAITranscriber"
              }
            ]
          },
          "model": {
            "description": "These are the options for the assistant's LLM.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/AnthropicModel",
                "title": "Anthropic"
              },
              {
                "$ref": "#/components/schemas/AnyscaleModel",
                "title": "Anyscale"
              },
              {
                "$ref": "#/components/schemas/CerebrasModel",
                "title": "Cerebras"
              },
              {
                "$ref": "#/components/schemas/CustomLLMModel",
                "title": "CustomLLM"
              },
              {
                "$ref": "#/components/schemas/DeepInfraModel",
                "title": "DeepInfra"
              },
              {
                "$ref": "#/components/schemas/DeepSeekModel",
                "title": "DeepSeek"
              },
              {
                "$ref": "#/components/schemas/GoogleModel",
                "title": "Google"
              },
              {
                "$ref": "#/components/schemas/GroqModel",
                "title": "Groq"
              },
              {
                "$ref": "#/components/schemas/InflectionAIModel",
                "title": "InflectionAI"
              },
              {
                "$ref": "#/components/schemas/OpenAIModel",
                "title": "OpenAI"
              },
              {
                "$ref": "#/components/schemas/OpenRouterModel",
                "title": "OpenRouter"
              },
              {
                "$ref": "#/components/schemas/PerplexityAIModel",
                "title": "PerplexityAI"
              },
              {
                "$ref": "#/components/schemas/TogetherAIModel",
                "title": "Together"
              },
              {
                "$ref": "#/components/schemas/XaiModel",
                "title": "XAI"
              }
            ]
          },
          "voice": {
            "description": "These are the options for the assistant's voice.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/AzureVoice",
                "title": "AzureVoice"
              },
              {
                "$ref": "#/components/schemas/CartesiaVoice",
                "title": "CartesiaVoice"
              },
              {
                "$ref": "#/components/schemas/CustomVoice",
                "title": "CustomVoice"
              },
              {
                "$ref": "#/components/schemas/DeepgramVoice",
                "title": "DeepgramVoice"
              },
              {
                "$ref": "#/components/schemas/ElevenLabsVoice",
                "title": "ElevenLabsVoice"
              },
              {
                "$ref": "#/components/schemas/HumeVoice",
                "title": "HumeVoice"
              },
              {
                "$ref": "#/components/schemas/LMNTVoice",
                "title": "LMNTVoice"
              },
              {
                "$ref": "#/components/schemas/NeuphonicVoice",
                "title": "NeuphonicVoice"
              },
              {
                "$ref": "#/components/schemas/OpenAIVoice",
                "title": "OpenAIVoice"
              },
              {
                "$ref": "#/components/schemas/PlayHTVoice",
                "title": "PlayHTVoice"
              },
              {
                "$ref": "#/components/schemas/RimeAIVoice",
                "title": "RimeAIVoice"
              },
              {
                "$ref": "#/components/schemas/SmallestAIVoice",
                "title": "SmallestAIVoice"
              },
              {
                "$ref": "#/components/schemas/TavusVoice",
                "title": "TavusVoice"
              },
              {
                "$ref": "#/components/schemas/VapiVoice",
                "title": "VapiVoice"
              },
              {
                "$ref": "#/components/schemas/SesameVoice",
                "title": "SesameVoice"
              }
            ]
          },
          "firstMessage": {
            "type": "string",
            "description": "This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).\n\nIf unspecified, assistant will wait for user to speak and use the model to respond once they speak.",
            "example": "Hello! How can I help you today?"
          },
          "firstMessageInterruptionsEnabled": {
            "type": "boolean",
            "default": false
          },
          "firstMessageMode": {
            "type": "string",
            "description": "This is the mode for the first message. Default is 'assistant-speaks-first'.\n\nUse:\n- 'assistant-speaks-first' to have the assistant speak first.\n- 'assistant-waits-for-user' to have the assistant wait for the user to speak first.\n- 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).\n\n@default 'assistant-speaks-first'",
            "enum": [
              "assistant-speaks-first",
              "assistant-speaks-first-with-model-generated-message",
              "assistant-waits-for-user"
            ],
            "example": "assistant-speaks-first"
          },
          "voicemailDetection": {
            "description": "These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].\nThis uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.\nYou can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/GoogleVoicemailDetectionPlan",
                "title": "Google"
              },
              {
                "$ref": "#/components/schemas/OpenAIVoicemailDetectionPlan",
                "title": "OpenAI"
              },
              {
                "$ref": "#/components/schemas/TwilioVoicemailDetectionPlan",
                "title": "Twilio"
              },
              {
                "$ref": "#/components/schemas/VapiVoicemailDetectionPlan",
                "title": "Vapi"
              }
            ]
          },
          "clientMessages": {
            "type": "array",
            "enum": [
              "conversation-update",
              "function-call",
              "function-call-result",
              "hang",
              "language-changed",
              "metadata",
              "model-output",
              "speech-update",
              "status-update",
              "transcript",
              "tool-calls",
              "tool-calls-result",
              "tool.completed",
              "transfer-update",
              "user-interrupted",
              "voice-input",
              "workflow.node.started"
            ],
            "example": [
              "conversation-update",
              "function-call",
              "hang",
              "model-output",
              "speech-update",
              "status-update",
              "transfer-update",
              "transcript",
              "tool-calls",
              "user-interrupted",
              "voice-input",
              "workflow.node.started"
            ],
            "description": "These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transfer-update,transcript,tool-calls,user-interrupted,voice-input,workflow.node.started. You can check the shape of the messages in ClientMessage schema.",
            "items": {
              "type": "string",
              "enum": [
                "conversation-update",
                "function-call",
                "function-call-result",
                "hang",
                "language-changed",
                "metadata",
                "model-output",
                "speech-update",
                "status-update",
                "transcript",
                "tool-calls",
                "tool-calls-result",
                "tool.completed",
                "transfer-update",
                "user-interrupted",
                "voice-input",
                "workflow.node.started"
              ]
            }
          },
          "serverMessages": {
            "type": "array",
            "enum": [
              "conversation-update",
              "end-of-call-report",
              "function-call",
              "hang",
              "language-changed",
              "language-change-detected",
              "model-output",
              "phone-call-control",
              "speech-update",
              "status-update",
              "transcript",
              "transcript[transcriptType=\"final\"]",
              "tool-calls",
              "transfer-destination-request",
              "transfer-update",
              "user-interrupted",
              "voice-input"
            ],
            "example": [
              "conversation-update",
              "end-of-call-report",
              "function-call",
              "hang",
              "speech-update",
              "status-update",
              "tool-calls",
              "transfer-destination-request",
              "user-interrupted"
            ],
            "description": "These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.",
            "items": {
              "type": "string",
              "enum": [
                "conversation-update",
                "end-of-call-report",
                "function-call",
                "hang",
                "language-changed",
                "language-change-detected",
                "model-output",
                "phone-call-control",
                "speech-update",
                "status-update",
                "transcript",
                "transcript[transcriptType=\"final\"]",
                "tool-calls",
                "transfer-destination-request",
                "transfer-update",
                "user-interrupted",
                "voice-input"
              ]
            }
          },
          "silenceTimeoutSeconds": {
            "type": "number",
            "description": "How many seconds of silence to wait before ending the call. Defaults to 30.\n\n@default 30",
            "minimum": 10,
            "maximum": 3600,
            "example": 30
          },
          "maxDurationSeconds": {
            "type": "number",
            "description": "This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.\n\n@default 600 (10 minutes)",
            "minimum": 10,
            "maximum": 43200,
            "example": 600
          },
          "backgroundSound": {
            "description": "This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.\nYou can also provide a custom sound by providing a URL to an audio file.",
            "oneOf": [
              {
                "type": "enum",
                "enum": [
                  "off",
                  "office"
                ],
                "example": "office"
              },
              {
                "type": "string",
                "format": "uri",
                "example": "https://www.soundjay.com/ambient/sounds/people-in-lounge-1.mp3"
              }
            ]
          },
          "backgroundDenoisingEnabled": {
            "type": "boolean",
            "description": "This enables filtering of noise and background speech while the user is talking.\n\nDefault `false` while in beta.\n\n@default false",
            "example": false
          },
          "modelOutputInMessagesEnabled": {
            "type": "boolean",
            "description": "This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.\n\nDefault `false` while in beta.\n\n@default false",
            "example": false
          },
          "transportConfigurations": {
            "type": "array",
            "description": "These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TransportConfigurationTwilio",
                  "title": "Twilio"
                }
              ]
            }
          },
          "observabilityPlan": {
            "description": "This is the plan for observability configuration of assistant's calls.\nCurrently supports Langfuse for tracing and monitoring.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/LangfuseObservabilityPlan",
                "title": "Langfuse"
              }
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/LangfuseObservabilityPlan"
              }
            ]
          },
          "credentials": {
            "type": "array",
            "description": "These are dynamic credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can supplement an additional credentials using this. Dynamic credentials override existing credentials.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CreateAnthropicCredentialDTO",
                  "title": "AnthropicCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateAnyscaleCredentialDTO",
                  "title": "AnyscaleCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateAssemblyAICredentialDTO",
                  "title": "AssemblyAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateAzureCredentialDTO",
                  "title": "AzureCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateAzureOpenAICredentialDTO",
                  "title": "AzureOpenAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateByoSipTrunkCredentialDTO",
                  "title": "ByoSipTrunkCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateCartesiaCredentialDTO",
                  "title": "CartesiaCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateCerebrasCredentialDTO",
                  "title": "CerebrasCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateCloudflareCredentialDTO",
                  "title": "CloudflareCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateCustomLLMCredentialDTO",
                  "title": "CustomLLMCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateDeepgramCredentialDTO",
                  "title": "DeepgramCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateDeepInfraCredentialDTO",
                  "title": "DeepInfraCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateDeepSeekCredentialDTO",
                  "title": "DeepSeekCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateElevenLabsCredentialDTO",
                  "title": "ElevenLabsCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGcpCredentialDTO",
                  "title": "GcpCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGladiaCredentialDTO",
                  "title": "GladiaCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCredentialDTO",
                  "title": "GhlCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCredentialDTO",
                  "title": "GoogleCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGroqCredentialDTO",
                  "title": "GroqCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateHumeCredentialDTO",
                  "title": "HumeCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateInflectionAICredentialDTO",
                  "title": "InflectionAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateLangfuseCredentialDTO",
                  "title": "LangfuseCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateLmntCredentialDTO",
                  "title": "LmntCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateMakeCredentialDTO",
                  "title": "MakeCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateMistralCredentialDTO",
                  "title": "MistralCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateNeuphonicCredentialDTO",
                  "title": "NeuphonicCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateOpenAICredentialDTO",
                  "title": "OpenAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateOpenRouterCredentialDTO",
                  "title": "OpenRouterCredential"
                },
                {
                  "$ref": "#/components/schemas/CreatePerplexityAICredentialDTO",
                  "title": "PerplexityAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreatePlayHTCredentialDTO",
                  "title": "PlayHTCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateRimeAICredentialDTO",
                  "title": "RimeAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateRunpodCredentialDTO",
                  "title": "RunpodCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateS3CredentialDTO",
                  "title": "S3Credential"
                },
                {
                  "$ref": "#/components/schemas/CreateSmallestAICredentialDTO",
                  "title": "SmallestAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateSpeechmaticsCredentialDTO",
                  "title": "SpeechmaticsCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateSupabaseCredentialDTO",
                  "title": "SupabaseCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateTavusCredentialDTO",
                  "title": "TavusCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateTogetherAICredentialDTO",
                  "title": "TogetherAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateTrieveCredentialDTO",
                  "title": "TrieveCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateTwilioCredentialDTO",
                  "title": "TwilioCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateVonageCredentialDTO",
                  "title": "VonageCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateWebhookCredentialDTO",
                  "title": "WebhookCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateXAiCredentialDTO",
                  "title": "XAiCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarOAuth2ClientCredentialDTO",
                  "title": "GoogleCalendarOAuth2ClientCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarOAuth2AuthorizationCredentialDTO",
                  "title": "GoogleCalendarOAuth2AuthorizationCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleSheetsOAuth2AuthorizationCredentialDTO",
                  "title": "GoogleSheetsOAuth2AuthorizationCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateSlackOAuth2AuthorizationCredentialDTO",
                  "title": "SlackOAuth2AuthorizationCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelMCPCredentialDTO",
                  "title": "GoHighLevelMCPCredential"
                }
              ],
              "discriminator": {
                "propertyName": "provider",
                "mapping": {
                  "11labs": "#/components/schemas/CreateElevenLabsCredentialDTO",
                  "anthropic": "#/components/schemas/CreateAnthropicCredentialDTO",
                  "anyscale": "#/components/schemas/CreateAnyscaleCredentialDTO",
                  "assembly-ai": "#/components/schemas/CreateAssemblyAICredentialDTO",
                  "azure-openai": "#/components/schemas/CreateAzureOpenAICredentialDTO",
                  "azure": "#/components/schemas/CreateAzureCredentialDTO",
                  "byo-sip-trunk": "#/components/schemas/CreateByoSipTrunkCredentialDTO",
                  "cartesia": "#/components/schemas/CreateCartesiaCredentialDTO",
                  "cerebras": "#/components/schemas/CreateCerebrasCredentialDTO",
                  "cloudflare": "#/components/schemas/CreateCloudflareCredentialDTO",
                  "custom-llm": "#/components/schemas/CreateCustomLLMCredentialDTO",
                  "deepgram": "#/components/schemas/CreateDeepgramCredentialDTO",
                  "deepinfra": "#/components/schemas/CreateDeepInfraCredentialDTO",
                  "deep-seek": "#/components/schemas/CreateDeepSeekCredentialDTO",
                  "gcp": "#/components/schemas/CreateGcpCredentialDTO",
                  "gladia": "#/components/schemas/CreateGladiaCredentialDTO",
                  "gohighlevel": "#/components/schemas/CreateGoHighLevelCredentialDTO",
                  "google": "#/components/schemas/CreateGoogleCredentialDTO",
                  "groq": "#/components/schemas/CreateGroqCredentialDTO",
                  "inflection-ai": "#/components/schemas/CreateInflectionAICredentialDTO",
                  "langfuse": "#/components/schemas/CreateLangfuseCredentialDTO",
                  "lmnt": "#/components/schemas/CreateLmntCredentialDTO",
                  "make": "#/components/schemas/CreateMakeCredentialDTO",
                  "openai": "#/components/schemas/CreateOpenAICredentialDTO",
                  "openrouter": "#/components/schemas/CreateOpenRouterCredentialDTO",
                  "perplexity-ai": "#/components/schemas/CreatePerplexityAICredentialDTO",
                  "playht": "#/components/schemas/CreatePlayHTCredentialDTO",
                  "rime-ai": "#/components/schemas/CreateRimeAICredentialDTO",
                  "runpod": "#/components/schemas/CreateRunpodCredentialDTO",
                  "s3": "#/components/schemas/CreateS3CredentialDTO",
                  "supabase": "#/components/schemas/CreateSupabaseCredentialDTO",
                  "smallest-ai": "#/components/schemas/CreateSmallestAICredentialDTO",
                  "tavus": "#/components/schemas/CreateTavusCredentialDTO",
                  "together-ai": "#/components/schemas/CreateTogetherAICredentialDTO",
                  "twilio": "#/components/schemas/CreateTwilioCredentialDTO",
                  "vonage": "#/components/schemas/CreateVonageCredentialDTO",
                  "webhook": "#/components/schemas/CreateWebhookCredentialDTO",
                  "xai": "#/components/schemas/CreateXAiCredentialDTO",
                  "neuphonic": "#/components/schemas/CreateNeuphonicCredentialDTO",
                  "hume": "#/components/schemas/CreateHumeCredentialDTO",
                  "mistral": "#/components/schemas/CreateMistralCredentialDTO",
                  "speechmatics": "#/components/schemas/CreateSpeechmaticsCredentialDTO",
                  "trieve": "#/components/schemas/CreateTrieveCredentialDTO",
                  "google.calendar.oauth2-client": "#/components/schemas/CreateGoogleCalendarOAuth2ClientCredentialDTO",
                  "google.calendar.oauth2-authorization": "#/components/schemas/CreateGoogleCalendarOAuth2AuthorizationCredentialDTO",
                  "google.sheets.oauth2-authorization": "#/components/schemas/CreateGoogleSheetsOAuth2AuthorizationCredentialDTO",
                  "slack.oauth2-authorization": "#/components/schemas/CreateSlackOAuth2AuthorizationCredentialDTO",
                  "ghl.oauth2-authorization": "#/components/schemas/CreateGoHighLevelMCPCredentialDTO"
                }
              }
            }
          },
          "hooks": {
            "type": "array",
            "description": "This is a set of actions that will be performed on certain events.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/AssistantHookCallEnding",
                  "title": "AssistantHookCallEnding"
                },
                {
                  "$ref": "#/components/schemas/AssistantHookAssistantSpeechInterrupted",
                  "title": "AssistantHookAssistantSpeechInterrupted"
                },
                {
                  "$ref": "#/components/schemas/AssistantHookCustomerSpeechInterrupted",
                  "title": "AssistantHookCustomerSpeechInterrupted"
                }
              ]
            }
          },
          "name": {
            "type": "string",
            "description": "This is the name of the assistant.\n\nThis is required when you want to transfer between assistants in a call.",
            "maxLength": 40
          },
          "voicemailMessage": {
            "type": "string",
            "description": "This is the message that the assistant will say if the call is forwarded to voicemail.\n\nIf unspecified, it will hang up.",
            "maxLength": 1000
          },
          "endCallMessage": {
            "type": "string",
            "description": "This is the message that the assistant will say if it ends the call.\n\nIf unspecified, it will hang up without saying anything.",
            "maxLength": 1000
          },
          "endCallPhrases": {
            "description": "This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.",
            "type": "array",
            "items": {
              "type": "string",
              "maxLength": 140,
              "minLength": 2
            }
          },
          "compliancePlan": {
            "$ref": "#/components/schemas/CompliancePlan"
          },
          "metadata": {
            "type": "object",
            "description": "This is for metadata you want to store on the assistant."
          },
          "analysisPlan": {
            "description": "This is the plan for analysis of assistant's calls. Stored in `call.analysis`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnalysisPlan"
              }
            ]
          },
          "artifactPlan": {
            "description": "This is the plan for artifacts generated during assistant's calls. Stored in `call.artifact`.\n\nNote: `recordingEnabled` is currently at the root level. It will be moved to `artifactPlan` in the future, but will remain backwards compatible.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ArtifactPlan"
              }
            ]
          },
          "messagePlan": {
            "description": "This is the plan for static predefined messages that can be spoken by the assistant during the call, like `idleMessages`.\n\nNote: `firstMessage`, `voicemailMessage`, and `endCallMessage` are currently at the root level. They will be moved to `messagePlan` in the future, but will remain backwards compatible.",
            "allOf": [
              {
                "$ref": "#/components/schemas/MessagePlan"
              }
            ]
          },
          "startSpeakingPlan": {
            "description": "This is the plan for when the assistant should start talking.\n\nYou should configure this if you're running into these issues:\n- The assistant is too slow to start talking after the customer is done speaking.\n- The assistant is too fast to start talking after the customer is done speaking.\n- The assistant is so fast that it's actually interrupting the customer.",
            "allOf": [
              {
                "$ref": "#/components/schemas/StartSpeakingPlan"
              }
            ]
          },
          "stopSpeakingPlan": {
            "description": "This is the plan for when assistant should stop talking on customer interruption.\n\nYou should configure this if you're running into these issues:\n- The assistant is too slow to recognize customer's interruption.\n- The assistant is too fast to recognize customer's interruption.\n- The assistant is getting interrupted by phrases that are just acknowledgments.\n- The assistant is getting interrupted by background noises.\n- The assistant is not properly stopping -- it starts talking right after getting interrupted.",
            "allOf": [
              {
                "$ref": "#/components/schemas/StopSpeakingPlan"
              }
            ]
          },
          "monitorPlan": {
            "description": "This is the plan for real-time monitoring of the assistant's calls.\n\nUsage:\n- To enable live listening of the assistant's calls, set `monitorPlan.listenEnabled` to `true`.\n- To enable live control of the assistant's calls, set `monitorPlan.controlEnabled` to `true`.\n\nNote, `serverMessages`, `clientMessages`, `serverUrl` and `serverUrlSecret` are currently at the root level but will be moved to `monitorPlan` in the future. Will remain backwards compatible",
            "allOf": [
              {
                "$ref": "#/components/schemas/MonitorPlan"
              }
            ]
          },
          "credentialIds": {
            "description": "These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server.url\n2. phoneNumber.serverUrl\n3. org.serverUrl",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "keypadInputPlan": {
            "$ref": "#/components/schemas/KeypadInputPlan"
          }
        }
      },
      "AssistantOverrides": {
        "type": "object",
        "properties": {
          "transcriber": {
            "description": "These are the options for the assistant's transcriber.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/AssemblyAITranscriber",
                "title": "AssemblyAITranscriber"
              },
              {
                "$ref": "#/components/schemas/AzureSpeechTranscriber",
                "title": "AzureSpeechTranscriber"
              },
              {
                "$ref": "#/components/schemas/CustomTranscriber",
                "title": "CustomTranscriber"
              },
              {
                "$ref": "#/components/schemas/DeepgramTranscriber",
                "title": "DeepgramTranscriber"
              },
              {
                "$ref": "#/components/schemas/ElevenLabsTranscriber",
                "title": "ElevenLabsTranscriber"
              },
              {
                "$ref": "#/components/schemas/GladiaTranscriber",
                "title": "GladiaTranscriber"
              },
              {
                "$ref": "#/components/schemas/GoogleTranscriber",
                "title": "GoogleTranscriber"
              },
              {
                "$ref": "#/components/schemas/SpeechmaticsTranscriber",
                "title": "SpeechmaticsTranscriber"
              },
              {
                "$ref": "#/components/schemas/TalkscriberTranscriber",
                "title": "TalkscriberTranscriber"
              },
              {
                "$ref": "#/components/schemas/OpenAITranscriber",
                "title": "OpenAITranscriber"
              }
            ]
          },
          "model": {
            "description": "These are the options for the assistant's LLM.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/AnthropicModel",
                "title": "Anthropic"
              },
              {
                "$ref": "#/components/schemas/AnyscaleModel",
                "title": "Anyscale"
              },
              {
                "$ref": "#/components/schemas/CerebrasModel",
                "title": "Cerebras"
              },
              {
                "$ref": "#/components/schemas/CustomLLMModel",
                "title": "CustomLLM"
              },
              {
                "$ref": "#/components/schemas/DeepInfraModel",
                "title": "DeepInfra"
              },
              {
                "$ref": "#/components/schemas/DeepSeekModel",
                "title": "DeepSeek"
              },
              {
                "$ref": "#/components/schemas/GoogleModel",
                "title": "Google"
              },
              {
                "$ref": "#/components/schemas/GroqModel",
                "title": "Groq"
              },
              {
                "$ref": "#/components/schemas/InflectionAIModel",
                "title": "InflectionAI"
              },
              {
                "$ref": "#/components/schemas/OpenAIModel",
                "title": "OpenAI"
              },
              {
                "$ref": "#/components/schemas/OpenRouterModel",
                "title": "OpenRouter"
              },
              {
                "$ref": "#/components/schemas/PerplexityAIModel",
                "title": "PerplexityAI"
              },
              {
                "$ref": "#/components/schemas/TogetherAIModel",
                "title": "Together"
              },
              {
                "$ref": "#/components/schemas/XaiModel",
                "title": "XAI"
              }
            ]
          },
          "voice": {
            "description": "These are the options for the assistant's voice.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/AzureVoice",
                "title": "AzureVoice"
              },
              {
                "$ref": "#/components/schemas/CartesiaVoice",
                "title": "CartesiaVoice"
              },
              {
                "$ref": "#/components/schemas/CustomVoice",
                "title": "CustomVoice"
              },
              {
                "$ref": "#/components/schemas/DeepgramVoice",
                "title": "DeepgramVoice"
              },
              {
                "$ref": "#/components/schemas/ElevenLabsVoice",
                "title": "ElevenLabsVoice"
              },
              {
                "$ref": "#/components/schemas/HumeVoice",
                "title": "HumeVoice"
              },
              {
                "$ref": "#/components/schemas/LMNTVoice",
                "title": "LMNTVoice"
              },
              {
                "$ref": "#/components/schemas/NeuphonicVoice",
                "title": "NeuphonicVoice"
              },
              {
                "$ref": "#/components/schemas/OpenAIVoice",
                "title": "OpenAIVoice"
              },
              {
                "$ref": "#/components/schemas/PlayHTVoice",
                "title": "PlayHTVoice"
              },
              {
                "$ref": "#/components/schemas/RimeAIVoice",
                "title": "RimeAIVoice"
              },
              {
                "$ref": "#/components/schemas/SmallestAIVoice",
                "title": "SmallestAIVoice"
              },
              {
                "$ref": "#/components/schemas/TavusVoice",
                "title": "TavusVoice"
              },
              {
                "$ref": "#/components/schemas/VapiVoice",
                "title": "VapiVoice"
              },
              {
                "$ref": "#/components/schemas/SesameVoice",
                "title": "SesameVoice"
              }
            ]
          },
          "firstMessage": {
            "type": "string",
            "description": "This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).\n\nIf unspecified, assistant will wait for user to speak and use the model to respond once they speak.",
            "example": "Hello! How can I help you today?"
          },
          "firstMessageInterruptionsEnabled": {
            "type": "boolean",
            "default": false
          },
          "firstMessageMode": {
            "type": "string",
            "description": "This is the mode for the first message. Default is 'assistant-speaks-first'.\n\nUse:\n- 'assistant-speaks-first' to have the assistant speak first.\n- 'assistant-waits-for-user' to have the assistant wait for the user to speak first.\n- 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).\n\n@default 'assistant-speaks-first'",
            "enum": [
              "assistant-speaks-first",
              "assistant-speaks-first-with-model-generated-message",
              "assistant-waits-for-user"
            ],
            "example": "assistant-speaks-first"
          },
          "voicemailDetection": {
            "description": "These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].\nThis uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.\nYou can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/GoogleVoicemailDetectionPlan",
                "title": "Google"
              },
              {
                "$ref": "#/components/schemas/OpenAIVoicemailDetectionPlan",
                "title": "OpenAI"
              },
              {
                "$ref": "#/components/schemas/TwilioVoicemailDetectionPlan",
                "title": "Twilio"
              },
              {
                "$ref": "#/components/schemas/VapiVoicemailDetectionPlan",
                "title": "Vapi"
              }
            ]
          },
          "clientMessages": {
            "type": "array",
            "enum": [
              "conversation-update",
              "function-call",
              "function-call-result",
              "hang",
              "language-changed",
              "metadata",
              "model-output",
              "speech-update",
              "status-update",
              "transcript",
              "tool-calls",
              "tool-calls-result",
              "tool.completed",
              "transfer-update",
              "user-interrupted",
              "voice-input",
              "workflow.node.started"
            ],
            "example": [
              "conversation-update",
              "function-call",
              "hang",
              "model-output",
              "speech-update",
              "status-update",
              "transfer-update",
              "transcript",
              "tool-calls",
              "user-interrupted",
              "voice-input",
              "workflow.node.started"
            ],
            "description": "These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transfer-update,transcript,tool-calls,user-interrupted,voice-input,workflow.node.started. You can check the shape of the messages in ClientMessage schema.",
            "items": {
              "type": "string",
              "enum": [
                "conversation-update",
                "function-call",
                "function-call-result",
                "hang",
                "language-changed",
                "metadata",
                "model-output",
                "speech-update",
                "status-update",
                "transcript",
                "tool-calls",
                "tool-calls-result",
                "tool.completed",
                "transfer-update",
                "user-interrupted",
                "voice-input",
                "workflow.node.started"
              ]
            }
          },
          "serverMessages": {
            "type": "array",
            "enum": [
              "conversation-update",
              "end-of-call-report",
              "function-call",
              "hang",
              "language-changed",
              "language-change-detected",
              "model-output",
              "phone-call-control",
              "speech-update",
              "status-update",
              "transcript",
              "transcript[transcriptType=\"final\"]",
              "tool-calls",
              "transfer-destination-request",
              "transfer-update",
              "user-interrupted",
              "voice-input"
            ],
            "example": [
              "conversation-update",
              "end-of-call-report",
              "function-call",
              "hang",
              "speech-update",
              "status-update",
              "tool-calls",
              "transfer-destination-request",
              "user-interrupted"
            ],
            "description": "These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.",
            "items": {
              "type": "string",
              "enum": [
                "conversation-update",
                "end-of-call-report",
                "function-call",
                "hang",
                "language-changed",
                "language-change-detected",
                "model-output",
                "phone-call-control",
                "speech-update",
                "status-update",
                "transcript",
                "transcript[transcriptType=\"final\"]",
                "tool-calls",
                "transfer-destination-request",
                "transfer-update",
                "user-interrupted",
                "voice-input"
              ]
            }
          },
          "silenceTimeoutSeconds": {
            "type": "number",
            "description": "How many seconds of silence to wait before ending the call. Defaults to 30.\n\n@default 30",
            "minimum": 10,
            "maximum": 3600,
            "example": 30
          },
          "maxDurationSeconds": {
            "type": "number",
            "description": "This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.\n\n@default 600 (10 minutes)",
            "minimum": 10,
            "maximum": 43200,
            "example": 600
          },
          "backgroundSound": {
            "description": "This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.\nYou can also provide a custom sound by providing a URL to an audio file.",
            "oneOf": [
              {
                "type": "enum",
                "enum": [
                  "off",
                  "office"
                ],
                "example": "office"
              },
              {
                "type": "string",
                "format": "uri",
                "example": "https://www.soundjay.com/ambient/sounds/people-in-lounge-1.mp3"
              }
            ]
          },
          "backgroundDenoisingEnabled": {
            "type": "boolean",
            "description": "This enables filtering of noise and background speech while the user is talking.\n\nDefault `false` while in beta.\n\n@default false",
            "example": false
          },
          "modelOutputInMessagesEnabled": {
            "type": "boolean",
            "description": "This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.\n\nDefault `false` while in beta.\n\n@default false",
            "example": false
          },
          "transportConfigurations": {
            "type": "array",
            "description": "These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TransportConfigurationTwilio",
                  "title": "Twilio"
                }
              ]
            }
          },
          "observabilityPlan": {
            "description": "This is the plan for observability configuration of assistant's calls.\nCurrently supports Langfuse for tracing and monitoring.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/LangfuseObservabilityPlan",
                "title": "Langfuse"
              }
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/LangfuseObservabilityPlan"
              }
            ]
          },
          "credentials": {
            "type": "array",
            "description": "These are dynamic credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can supplement an additional credentials using this. Dynamic credentials override existing credentials.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CreateAnthropicCredentialDTO",
                  "title": "AnthropicCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateAnyscaleCredentialDTO",
                  "title": "AnyscaleCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateAssemblyAICredentialDTO",
                  "title": "AssemblyAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateAzureCredentialDTO",
                  "title": "AzureCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateAzureOpenAICredentialDTO",
                  "title": "AzureOpenAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateByoSipTrunkCredentialDTO",
                  "title": "ByoSipTrunkCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateCartesiaCredentialDTO",
                  "title": "CartesiaCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateCerebrasCredentialDTO",
                  "title": "CerebrasCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateCloudflareCredentialDTO",
                  "title": "CloudflareCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateCustomLLMCredentialDTO",
                  "title": "CustomLLMCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateDeepgramCredentialDTO",
                  "title": "DeepgramCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateDeepInfraCredentialDTO",
                  "title": "DeepInfraCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateDeepSeekCredentialDTO",
                  "title": "DeepSeekCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateElevenLabsCredentialDTO",
                  "title": "ElevenLabsCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGcpCredentialDTO",
                  "title": "GcpCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGladiaCredentialDTO",
                  "title": "GladiaCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCredentialDTO",
                  "title": "GhlCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCredentialDTO",
                  "title": "GoogleCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGroqCredentialDTO",
                  "title": "GroqCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateHumeCredentialDTO",
                  "title": "HumeCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateInflectionAICredentialDTO",
                  "title": "InflectionAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateLangfuseCredentialDTO",
                  "title": "LangfuseCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateLmntCredentialDTO",
                  "title": "LmntCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateMakeCredentialDTO",
                  "title": "MakeCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateMistralCredentialDTO",
                  "title": "MistralCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateNeuphonicCredentialDTO",
                  "title": "NeuphonicCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateOpenAICredentialDTO",
                  "title": "OpenAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateOpenRouterCredentialDTO",
                  "title": "OpenRouterCredential"
                },
                {
                  "$ref": "#/components/schemas/CreatePerplexityAICredentialDTO",
                  "title": "PerplexityAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreatePlayHTCredentialDTO",
                  "title": "PlayHTCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateRimeAICredentialDTO",
                  "title": "RimeAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateRunpodCredentialDTO",
                  "title": "RunpodCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateS3CredentialDTO",
                  "title": "S3Credential"
                },
                {
                  "$ref": "#/components/schemas/CreateSmallestAICredentialDTO",
                  "title": "SmallestAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateSpeechmaticsCredentialDTO",
                  "title": "SpeechmaticsCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateSupabaseCredentialDTO",
                  "title": "SupabaseCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateTavusCredentialDTO",
                  "title": "TavusCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateTogetherAICredentialDTO",
                  "title": "TogetherAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateTrieveCredentialDTO",
                  "title": "TrieveCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateTwilioCredentialDTO",
                  "title": "TwilioCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateVonageCredentialDTO",
                  "title": "VonageCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateWebhookCredentialDTO",
                  "title": "WebhookCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateXAiCredentialDTO",
                  "title": "XAiCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarOAuth2ClientCredentialDTO",
                  "title": "GoogleCalendarOAuth2ClientCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarOAuth2AuthorizationCredentialDTO",
                  "title": "GoogleCalendarOAuth2AuthorizationCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleSheetsOAuth2AuthorizationCredentialDTO",
                  "title": "GoogleSheetsOAuth2AuthorizationCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateSlackOAuth2AuthorizationCredentialDTO",
                  "title": "SlackOAuth2AuthorizationCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelMCPCredentialDTO",
                  "title": "GoHighLevelMCPCredential"
                }
              ],
              "discriminator": {
                "propertyName": "provider",
                "mapping": {
                  "11labs": "#/components/schemas/CreateElevenLabsCredentialDTO",
                  "anthropic": "#/components/schemas/CreateAnthropicCredentialDTO",
                  "anyscale": "#/components/schemas/CreateAnyscaleCredentialDTO",
                  "assembly-ai": "#/components/schemas/CreateAssemblyAICredentialDTO",
                  "azure-openai": "#/components/schemas/CreateAzureOpenAICredentialDTO",
                  "azure": "#/components/schemas/CreateAzureCredentialDTO",
                  "byo-sip-trunk": "#/components/schemas/CreateByoSipTrunkCredentialDTO",
                  "cartesia": "#/components/schemas/CreateCartesiaCredentialDTO",
                  "cerebras": "#/components/schemas/CreateCerebrasCredentialDTO",
                  "cloudflare": "#/components/schemas/CreateCloudflareCredentialDTO",
                  "custom-llm": "#/components/schemas/CreateCustomLLMCredentialDTO",
                  "deepgram": "#/components/schemas/CreateDeepgramCredentialDTO",
                  "deepinfra": "#/components/schemas/CreateDeepInfraCredentialDTO",
                  "deep-seek": "#/components/schemas/CreateDeepSeekCredentialDTO",
                  "gcp": "#/components/schemas/CreateGcpCredentialDTO",
                  "gladia": "#/components/schemas/CreateGladiaCredentialDTO",
                  "gohighlevel": "#/components/schemas/CreateGoHighLevelCredentialDTO",
                  "google": "#/components/schemas/CreateGoogleCredentialDTO",
                  "groq": "#/components/schemas/CreateGroqCredentialDTO",
                  "inflection-ai": "#/components/schemas/CreateInflectionAICredentialDTO",
                  "langfuse": "#/components/schemas/CreateLangfuseCredentialDTO",
                  "lmnt": "#/components/schemas/CreateLmntCredentialDTO",
                  "make": "#/components/schemas/CreateMakeCredentialDTO",
                  "openai": "#/components/schemas/CreateOpenAICredentialDTO",
                  "openrouter": "#/components/schemas/CreateOpenRouterCredentialDTO",
                  "perplexity-ai": "#/components/schemas/CreatePerplexityAICredentialDTO",
                  "playht": "#/components/schemas/CreatePlayHTCredentialDTO",
                  "rime-ai": "#/components/schemas/CreateRimeAICredentialDTO",
                  "runpod": "#/components/schemas/CreateRunpodCredentialDTO",
                  "s3": "#/components/schemas/CreateS3CredentialDTO",
                  "supabase": "#/components/schemas/CreateSupabaseCredentialDTO",
                  "smallest-ai": "#/components/schemas/CreateSmallestAICredentialDTO",
                  "tavus": "#/components/schemas/CreateTavusCredentialDTO",
                  "together-ai": "#/components/schemas/CreateTogetherAICredentialDTO",
                  "twilio": "#/components/schemas/CreateTwilioCredentialDTO",
                  "vonage": "#/components/schemas/CreateVonageCredentialDTO",
                  "webhook": "#/components/schemas/CreateWebhookCredentialDTO",
                  "xai": "#/components/schemas/CreateXAiCredentialDTO",
                  "neuphonic": "#/components/schemas/CreateNeuphonicCredentialDTO",
                  "hume": "#/components/schemas/CreateHumeCredentialDTO",
                  "mistral": "#/components/schemas/CreateMistralCredentialDTO",
                  "speechmatics": "#/components/schemas/CreateSpeechmaticsCredentialDTO",
                  "trieve": "#/components/schemas/CreateTrieveCredentialDTO",
                  "google.calendar.oauth2-client": "#/components/schemas/CreateGoogleCalendarOAuth2ClientCredentialDTO",
                  "google.calendar.oauth2-authorization": "#/components/schemas/CreateGoogleCalendarOAuth2AuthorizationCredentialDTO",
                  "google.sheets.oauth2-authorization": "#/components/schemas/CreateGoogleSheetsOAuth2AuthorizationCredentialDTO",
                  "slack.oauth2-authorization": "#/components/schemas/CreateSlackOAuth2AuthorizationCredentialDTO",
                  "ghl.oauth2-authorization": "#/components/schemas/CreateGoHighLevelMCPCredentialDTO"
                }
              }
            }
          },
          "hooks": {
            "type": "array",
            "description": "This is a set of actions that will be performed on certain events.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/AssistantHookCallEnding",
                  "title": "AssistantHookCallEnding"
                },
                {
                  "$ref": "#/components/schemas/AssistantHookAssistantSpeechInterrupted",
                  "title": "AssistantHookAssistantSpeechInterrupted"
                },
                {
                  "$ref": "#/components/schemas/AssistantHookCustomerSpeechInterrupted",
                  "title": "AssistantHookCustomerSpeechInterrupted"
                }
              ]
            }
          },
          "variableValues": {
            "type": "object",
            "description": "These are values that will be used to replace the template variables in the assistant messages and other text-based fields.\nThis uses LiquidJS syntax. https://liquidjs.com/tutorials/intro-to-liquid.html\n\nSo for example, `{{ name }}` will be replaced with the value of `name` in `variableValues`.\n`{{\"now\" | date: \"%b %d, %Y, %I:%M %p\", \"America/New_York\"}}` will be replaced with the current date and time in New York.\n Some VAPI reserved defaults:\n - *customer* - the customer object"
          },
          "name": {
            "type": "string",
            "description": "This is the name of the assistant.\n\nThis is required when you want to transfer between assistants in a call.",
            "maxLength": 40
          },
          "voicemailMessage": {
            "type": "string",
            "description": "This is the message that the assistant will say if the call is forwarded to voicemail.\n\nIf unspecified, it will hang up.",
            "maxLength": 1000
          },
          "endCallMessage": {
            "type": "string",
            "description": "This is the message that the assistant will say if it ends the call.\n\nIf unspecified, it will hang up without saying anything.",
            "maxLength": 1000
          },
          "endCallPhrases": {
            "description": "This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.",
            "type": "array",
            "items": {
              "type": "string",
              "maxLength": 140,
              "minLength": 2
            }
          },
          "compliancePlan": {
            "$ref": "#/components/schemas/CompliancePlan"
          },
          "metadata": {
            "type": "object",
            "description": "This is for metadata you want to store on the assistant."
          },
          "analysisPlan": {
            "description": "This is the plan for analysis of assistant's calls. Stored in `call.analysis`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnalysisPlan"
              }
            ]
          },
          "artifactPlan": {
            "description": "This is the plan for artifacts generated during assistant's calls. Stored in `call.artifact`.\n\nNote: `recordingEnabled` is currently at the root level. It will be moved to `artifactPlan` in the future, but will remain backwards compatible.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ArtifactPlan"
              }
            ]
          },
          "messagePlan": {
            "description": "This is the plan for static predefined messages that can be spoken by the assistant during the call, like `idleMessages`.\n\nNote: `firstMessage`, `voicemailMessage`, and `endCallMessage` are currently at the root level. They will be moved to `messagePlan` in the future, but will remain backwards compatible.",
            "allOf": [
              {
                "$ref": "#/components/schemas/MessagePlan"
              }
            ]
          },
          "startSpeakingPlan": {
            "description": "This is the plan for when the assistant should start talking.\n\nYou should configure this if you're running into these issues:\n- The assistant is too slow to start talking after the customer is done speaking.\n- The assistant is too fast to start talking after the customer is done speaking.\n- The assistant is so fast that it's actually interrupting the customer.",
            "allOf": [
              {
                "$ref": "#/components/schemas/StartSpeakingPlan"
              }
            ]
          },
          "stopSpeakingPlan": {
            "description": "This is the plan for when assistant should stop talking on customer interruption.\n\nYou should configure this if you're running into these issues:\n- The assistant is too slow to recognize customer's interruption.\n- The assistant is too fast to recognize customer's interruption.\n- The assistant is getting interrupted by phrases that are just acknowledgments.\n- The assistant is getting interrupted by background noises.\n- The assistant is not properly stopping -- it starts talking right after getting interrupted.",
            "allOf": [
              {
                "$ref": "#/components/schemas/StopSpeakingPlan"
              }
            ]
          },
          "monitorPlan": {
            "description": "This is the plan for real-time monitoring of the assistant's calls.\n\nUsage:\n- To enable live listening of the assistant's calls, set `monitorPlan.listenEnabled` to `true`.\n- To enable live control of the assistant's calls, set `monitorPlan.controlEnabled` to `true`.\n\nNote, `serverMessages`, `clientMessages`, `serverUrl` and `serverUrlSecret` are currently at the root level but will be moved to `monitorPlan` in the future. Will remain backwards compatible",
            "allOf": [
              {
                "$ref": "#/components/schemas/MonitorPlan"
              }
            ]
          },
          "credentialIds": {
            "description": "These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server.url\n2. phoneNumber.serverUrl\n3. org.serverUrl",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "keypadInputPlan": {
            "$ref": "#/components/schemas/KeypadInputPlan"
          }
        }
      },
      "SquadMemberDTO": {
        "type": "object",
        "properties": {
          "assistantId": {
            "type": "string",
            "nullable": true,
            "description": "This is the assistant that will be used for the call. To use a transient assistant, use `assistant` instead."
          },
          "assistant": {
            "description": "This is the assistant that will be used for the call. To use an existing assistant, use `assistantId` instead.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "assistantOverrides": {
            "description": "This can be used to override the assistant's settings and provide values for it's template variables.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AssistantOverrides"
              }
            ]
          },
          "assistantDestinations": {
            "description": "These are the others assistants that this assistant can transfer to.\n\nIf the assistant already has transfer call tool, these destinations are just appended to existing ones.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TransferDestinationAssistant"
            }
          }
        }
      },
      "CreateSquadDTO": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "This is the name of the squad."
          },
          "members": {
            "description": "This is the list of assistants that make up the squad.\n\nThe call will start with the first assistant in the list.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SquadMemberDTO"
            }
          },
          "membersOverrides": {
            "description": "This can be used to override all the assistants' settings and provide values for their template variables.\n\nBoth `membersOverrides` and `members[n].assistantOverrides` can be used together. First, `members[n].assistantOverrides` is applied. Then, `membersOverrides` is applied as a global override.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AssistantOverrides"
              }
            ]
          }
        },
        "required": [
          "members"
        ]
      },
      "CreateWorkflowDTO": {
        "type": "object",
        "properties": {
          "nodes": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ConversationNode",
                  "title": "ConversationNode"
                },
                {
                  "$ref": "#/components/schemas/ToolNode",
                  "title": "ToolNode"
                }
              ]
            }
          },
          "model": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/WorkflowOpenAIModel",
                "title": "WorkflowOpenAIModel"
              },
              {
                "$ref": "#/components/schemas/WorkflowAnthropicModel",
                "title": "WorkflowAnthropicModel"
              }
            ]
          },
          "name": {
            "type": "string",
            "maxLength": 80
          },
          "edges": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Edge"
            }
          },
          "globalPrompt": {
            "type": "string",
            "maxLength": 5000
          }
        },
        "required": [
          "nodes",
          "name",
          "edges"
        ]
      },
      "TransferPhoneNumberHookAction": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of action - must be \"transfer\"",
            "enum": [
              "transfer"
            ]
          },
          "destination": {
            "description": "This is the destination details for the transfer - can be a phone number or SIP URI",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "SayPhoneNumberHookAction": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of action - must be \"say\"",
            "enum": [
              "say"
            ]
          },
          "exact": {
            "type": "string",
            "description": "This is the message to say",
            "maxLength": 4000
          }
        },
        "required": [
          "type",
          "exact"
        ]
      },
      "PhoneNumberHookCallRinging": {
        "type": "object",
        "properties": {
          "on": {
            "type": "string",
            "description": "This is the event to trigger the hook on",
            "enum": [
              "call.ringing"
            ],
            "maxLength": 1000
          },
          "do": {
            "type": "array",
            "description": "This is the set of actions to perform when the hook triggers",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TransferPhoneNumberHookAction",
                  "title": "TransferPhoneNumberHookAction"
                },
                {
                  "$ref": "#/components/schemas/SayPhoneNumberHookAction",
                  "title": "SayPhoneNumberHookAction"
                }
              ]
            }
          }
        },
        "required": [
          "on",
          "do"
        ]
      },
      "ImportTwilioPhoneNumberDTO": {
        "type": "object",
        "properties": {
          "fallbackDestination": {
            "description": "This is the fallback destination an inbound call will be transferred to if:\n1. `assistantId` is not set\n2. `squadId` is not set\n3. and, `assistant-request` message to the `serverUrl` fails\n\nIf this is not set and above conditions are met, the inbound call is hung up with an error message.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "hooks": {
            "type": "array",
            "description": "This is the hooks that will be used for incoming calls to this phone number.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/PhoneNumberHookCallRinging",
                  "title": "PhoneNumberHookCallRinging"
                }
              ]
            }
          },
          "smsEnabled": {
            "type": "boolean",
            "description": "Controls whether Vapi sets the messaging webhook URL on the Twilio number during import.\n\nIf set to `false`, Vapi will not update the Twilio messaging URL, leaving it as is.\nIf `true` or omitted (default), Vapi will configure both the voice and messaging URLs.\n\n@default true",
            "default": true
          },
          "twilioPhoneNumber": {
            "type": "string",
            "description": "These are the digits of the phone number you own on your Twilio.",
            "deprecated": true
          },
          "twilioAccountSid": {
            "type": "string",
            "description": "This is your Twilio Account SID that will be used to handle this phone number."
          },
          "twilioAuthToken": {
            "type": "string",
            "description": "This is the Twilio Auth Token that will be used to handle this phone number."
          },
          "twilioApiKey": {
            "type": "string",
            "description": "This is the Twilio API Key that will be used to handle this phone number. If AuthToken is provided, this will be ignored."
          },
          "twilioApiSecret": {
            "type": "string",
            "description": "This is the Twilio API Secret that will be used to handle this phone number. If AuthToken is provided, this will be ignored."
          },
          "name": {
            "type": "string",
            "description": "This is the name of the phone number. This is just for your own reference.",
            "maxLength": 40
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId` nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "workflowId": {
            "type": "string",
            "description": "This is the workflow that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server\n2. phoneNumber.server\n3. org.server",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          }
        },
        "required": [
          "twilioPhoneNumber",
          "twilioAccountSid"
        ]
      },
      "CreateCustomerDTO": {
        "type": "object",
        "properties": {
          "numberE164CheckEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle the E164 check for the `number` field. This is an advanced property which should be used if you know your use case requires it.\n\nUse cases:\n- `false`: To allow non-E164 numbers like `+001234567890`, `1234`, or `abc`. This is useful for dialing out to non-E164 numbers on your SIP trunks.\n- `true` (default): To allow only E164 numbers like `+14155551234`. This is standard for PSTN calls.\n\nIf `false`, the `number` is still required to only contain alphanumeric characters (regex: `/^\\+?[a-zA-Z0-9]+$/`).\n\n@default true (E164 check is enabled)",
            "default": true
          },
          "extension": {
            "type": "string",
            "description": "This is the extension that will be dialed after the call is answered.",
            "maxLength": 10,
            "example": null
          },
          "assistantOverrides": {
            "description": "These are the overrides for the assistant's settings and template variables specific to this customer.\nThis allows customization of the assistant's behavior for individual customers in batch calls.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AssistantOverrides"
              }
            ]
          },
          "number": {
            "type": "string",
            "description": "This is the number of the customer.",
            "minLength": 3,
            "maxLength": 40
          },
          "sipUri": {
            "type": "string",
            "description": "This is the SIP URI of the customer."
          },
          "name": {
            "type": "string",
            "description": "This is the name of the customer. This is just for your own reference.\n\nFor SIP inbound calls, this is extracted from the `From` SIP header with format `\"Display Name\" <sip:username@domain>`.",
            "maxLength": 40
          }
        }
      },
      "SchedulePlan": {
        "type": "object",
        "properties": {
          "earliestAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of the earliest time the call can be scheduled."
          },
          "latestAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of the latest time the call can be scheduled."
          }
        },
        "required": [
          "earliestAt"
        ]
      },
      "Call": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of call.",
            "enum": [
              "inboundPhoneCall",
              "outboundPhoneCall",
              "webCall",
              "vapi.websocketCall"
            ]
          },
          "costs": {
            "type": "array",
            "description": "These are the costs of individual components of the call in USD.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TransportCost",
                  "title": "TransportCost"
                },
                {
                  "$ref": "#/components/schemas/TranscriberCost",
                  "title": "TranscriberCost"
                },
                {
                  "$ref": "#/components/schemas/ModelCost",
                  "title": "ModelCost"
                },
                {
                  "$ref": "#/components/schemas/VoiceCost",
                  "title": "VoiceCost"
                },
                {
                  "$ref": "#/components/schemas/VapiCost",
                  "title": "VapiCost"
                },
                {
                  "$ref": "#/components/schemas/VoicemailDetectionCost",
                  "title": "VoicemailDetectionCost"
                },
                {
                  "$ref": "#/components/schemas/AnalysisCost",
                  "title": "AnalysisCost"
                },
                {
                  "$ref": "#/components/schemas/KnowledgeBaseCost",
                  "title": "KnowledgeBaseCost"
                }
              ]
            }
          },
          "messages": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/UserMessage",
                  "title": "UserMessage"
                },
                {
                  "$ref": "#/components/schemas/SystemMessage",
                  "title": "SystemMessage"
                },
                {
                  "$ref": "#/components/schemas/BotMessage",
                  "title": "BotMessage"
                },
                {
                  "$ref": "#/components/schemas/ToolCallMessage",
                  "title": "ToolCallMessage"
                },
                {
                  "$ref": "#/components/schemas/ToolCallResultMessage",
                  "title": "ToolCallResultMessage"
                }
              ]
            }
          },
          "phoneCallProvider": {
            "type": "string",
            "description": "This is the provider of the call.\n\nOnly relevant for `outboundPhoneCall` and `inboundPhoneCall` type.",
            "deprecated": true,
            "enum": [
              "twilio",
              "vonage",
              "vapi",
              "telnyx"
            ]
          },
          "phoneCallTransport": {
            "type": "string",
            "description": "This is the transport of the phone call.\n\nOnly relevant for `outboundPhoneCall` and `inboundPhoneCall` type.",
            "enum": [
              "sip",
              "pstn"
            ]
          },
          "status": {
            "type": "string",
            "description": "This is the status of the call.",
            "enum": [
              "scheduled",
              "queued",
              "ringing",
              "in-progress",
              "forwarding",
              "ended"
            ]
          },
          "endedReason": {
            "type": "string",
            "description": "This is the explanation for how the call ended.",
            "enum": [
              "call-start-error-neither-assistant-nor-server-set",
              "assistant-request-failed",
              "assistant-request-returned-error",
              "assistant-request-returned-unspeakable-error",
              "assistant-request-returned-invalid-assistant",
              "assistant-request-returned-no-assistant",
              "assistant-request-returned-forwarding-phone-number",
              "call.start.error-get-org",
              "call.start.error-get-subscription",
              "call.start.error-get-assistant",
              "call.start.error-get-phone-number",
              "call.start.error-get-customer",
              "call.start.error-get-resources-validation",
              "call.start.error-vapi-number-international",
              "call.start.error-vapi-number-outbound-daily-limit",
              "call.start.error-get-transport",
              "assistant-not-valid",
              "database-error",
              "assistant-not-found",
              "pipeline-error-openai-voice-failed",
              "pipeline-error-cartesia-voice-failed",
              "pipeline-error-deepgram-voice-failed",
              "pipeline-error-eleven-labs-voice-failed",
              "pipeline-error-playht-voice-failed",
              "pipeline-error-lmnt-voice-failed",
              "pipeline-error-azure-voice-failed",
              "pipeline-error-rime-ai-voice-failed",
              "pipeline-error-smallest-ai-voice-failed",
              "pipeline-error-neuphonic-voice-failed",
              "pipeline-error-hume-voice-failed",
              "pipeline-error-sesame-voice-failed",
              "pipeline-error-tavus-video-failed",
              "call.in-progress.error-vapifault-openai-voice-failed",
              "call.in-progress.error-vapifault-cartesia-voice-failed",
              "call.in-progress.error-vapifault-deepgram-voice-failed",
              "call.in-progress.error-vapifault-eleven-labs-voice-failed",
              "call.in-progress.error-vapifault-playht-voice-failed",
              "call.in-progress.error-vapifault-lmnt-voice-failed",
              "call.in-progress.error-vapifault-azure-voice-failed",
              "call.in-progress.error-vapifault-rime-ai-voice-failed",
              "call.in-progress.error-vapifault-smallest-ai-voice-failed",
              "call.in-progress.error-vapifault-neuphonic-voice-failed",
              "call.in-progress.error-vapifault-hume-voice-failed",
              "call.in-progress.error-vapifault-sesame-voice-failed",
              "call.in-progress.error-vapifault-tavus-video-failed",
              "pipeline-error-vapi-llm-failed",
              "pipeline-error-vapi-400-bad-request-validation-failed",
              "pipeline-error-vapi-401-unauthorized",
              "pipeline-error-vapi-403-model-access-denied",
              "pipeline-error-vapi-429-exceeded-quota",
              "pipeline-error-vapi-500-server-error",
              "pipeline-error-vapi-503-server-overloaded-error",
              "call.in-progress.error-vapifault-vapi-llm-failed",
              "call.in-progress.error-vapifault-vapi-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-vapi-401-unauthorized",
              "call.in-progress.error-vapifault-vapi-403-model-access-denied",
              "call.in-progress.error-vapifault-vapi-429-exceeded-quota",
              "call.in-progress.error-providerfault-vapi-500-server-error",
              "call.in-progress.error-providerfault-vapi-503-server-overloaded-error",
              "pipeline-error-deepgram-transcriber-failed",
              "call.in-progress.error-vapifault-deepgram-transcriber-failed",
              "pipeline-error-gladia-transcriber-failed",
              "call.in-progress.error-vapifault-gladia-transcriber-failed",
              "pipeline-error-speechmatics-transcriber-failed",
              "call.in-progress.error-vapifault-speechmatics-transcriber-failed",
              "pipeline-error-assembly-ai-transcriber-failed",
              "pipeline-error-assembly-ai-returning-400-insufficent-funds",
              "pipeline-error-assembly-ai-returning-400-paid-only-feature",
              "pipeline-error-assembly-ai-returning-401-invalid-credentials",
              "pipeline-error-assembly-ai-returning-500-invalid-schema",
              "pipeline-error-assembly-ai-returning-500-word-boost-parsing-failed",
              "call.in-progress.error-vapifault-assembly-ai-transcriber-failed",
              "call.in-progress.error-vapifault-assembly-ai-returning-400-insufficent-funds",
              "call.in-progress.error-vapifault-assembly-ai-returning-400-paid-only-feature",
              "call.in-progress.error-vapifault-assembly-ai-returning-401-invalid-credentials",
              "call.in-progress.error-vapifault-assembly-ai-returning-500-invalid-schema",
              "call.in-progress.error-vapifault-assembly-ai-returning-500-word-boost-parsing-failed",
              "pipeline-error-talkscriber-transcriber-failed",
              "call.in-progress.error-vapifault-talkscriber-transcriber-failed",
              "pipeline-error-azure-speech-transcriber-failed",
              "call.in-progress.error-vapifault-azure-speech-transcriber-failed",
              "call.in-progress.error-pipeline-no-available-llm-model",
              "worker-shutdown",
              "unknown-error",
              "vonage-disconnected",
              "vonage-failed-to-connect-call",
              "vonage-completed",
              "phone-call-provider-bypass-enabled-but-no-call-received",
              "call.in-progress.error-providerfault-transport-never-connected",
              "call.in-progress.error-vapifault-worker-not-available",
              "call.in-progress.error-vapifault-transport-never-connected",
              "call.in-progress.error-vapifault-transport-connected-but-call-not-active",
              "call.in-progress.error-vapifault-call-started-but-connection-to-transport-missing",
              "call.in-progress.error-vapifault-worker-died",
              "call.in-progress.error-vapifault-openai-llm-failed",
              "call.in-progress.error-vapifault-azure-openai-llm-failed",
              "call.in-progress.error-vapifault-groq-llm-failed",
              "call.in-progress.error-vapifault-google-llm-failed",
              "call.in-progress.error-vapifault-xai-llm-failed",
              "call.in-progress.error-vapifault-mistral-llm-failed",
              "call.in-progress.error-vapifault-inflection-ai-llm-failed",
              "call.in-progress.error-vapifault-cerebras-llm-failed",
              "call.in-progress.error-vapifault-deep-seek-llm-failed",
              "pipeline-error-openai-400-bad-request-validation-failed",
              "pipeline-error-openai-401-unauthorized",
              "pipeline-error-openai-401-incorrect-api-key",
              "pipeline-error-openai-401-account-not-in-organization",
              "pipeline-error-openai-403-model-access-denied",
              "pipeline-error-openai-429-exceeded-quota",
              "pipeline-error-openai-429-rate-limit-reached",
              "pipeline-error-openai-500-server-error",
              "pipeline-error-openai-503-server-overloaded-error",
              "pipeline-error-openai-llm-failed",
              "call.in-progress.error-vapifault-openai-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-openai-401-unauthorized",
              "call.in-progress.error-vapifault-openai-401-incorrect-api-key",
              "call.in-progress.error-vapifault-openai-401-account-not-in-organization",
              "call.in-progress.error-vapifault-openai-403-model-access-denied",
              "call.in-progress.error-vapifault-openai-429-exceeded-quota",
              "call.in-progress.error-vapifault-openai-429-rate-limit-reached",
              "call.in-progress.error-providerfault-openai-500-server-error",
              "call.in-progress.error-providerfault-openai-503-server-overloaded-error",
              "pipeline-error-azure-openai-400-bad-request-validation-failed",
              "pipeline-error-azure-openai-401-unauthorized",
              "pipeline-error-azure-openai-403-model-access-denied",
              "pipeline-error-azure-openai-429-exceeded-quota",
              "pipeline-error-azure-openai-500-server-error",
              "pipeline-error-azure-openai-503-server-overloaded-error",
              "pipeline-error-azure-openai-llm-failed",
              "call.in-progress.error-vapifault-azure-openai-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-azure-openai-401-unauthorized",
              "call.in-progress.error-vapifault-azure-openai-403-model-access-denied",
              "call.in-progress.error-vapifault-azure-openai-429-exceeded-quota",
              "call.in-progress.error-providerfault-azure-openai-500-server-error",
              "call.in-progress.error-providerfault-azure-openai-503-server-overloaded-error",
              "pipeline-error-google-400-bad-request-validation-failed",
              "pipeline-error-google-401-unauthorized",
              "pipeline-error-google-403-model-access-denied",
              "pipeline-error-google-429-exceeded-quota",
              "pipeline-error-google-500-server-error",
              "pipeline-error-google-503-server-overloaded-error",
              "pipeline-error-google-llm-failed",
              "call.in-progress.error-vapifault-google-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-google-401-unauthorized",
              "call.in-progress.error-vapifault-google-403-model-access-denied",
              "call.in-progress.error-vapifault-google-429-exceeded-quota",
              "call.in-progress.error-providerfault-google-500-server-error",
              "call.in-progress.error-providerfault-google-503-server-overloaded-error",
              "pipeline-error-xai-400-bad-request-validation-failed",
              "pipeline-error-xai-401-unauthorized",
              "pipeline-error-xai-403-model-access-denied",
              "pipeline-error-xai-429-exceeded-quota",
              "pipeline-error-xai-500-server-error",
              "pipeline-error-xai-503-server-overloaded-error",
              "pipeline-error-xai-llm-failed",
              "call.in-progress.error-vapifault-xai-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-xai-401-unauthorized",
              "call.in-progress.error-vapifault-xai-403-model-access-denied",
              "call.in-progress.error-vapifault-xai-429-exceeded-quota",
              "call.in-progress.error-providerfault-xai-500-server-error",
              "call.in-progress.error-providerfault-xai-503-server-overloaded-error",
              "pipeline-error-mistral-400-bad-request-validation-failed",
              "pipeline-error-mistral-401-unauthorized",
              "pipeline-error-mistral-403-model-access-denied",
              "pipeline-error-mistral-429-exceeded-quota",
              "pipeline-error-mistral-500-server-error",
              "pipeline-error-mistral-503-server-overloaded-error",
              "pipeline-error-mistral-llm-failed",
              "call.in-progress.error-vapifault-mistral-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-mistral-401-unauthorized",
              "call.in-progress.error-vapifault-mistral-403-model-access-denied",
              "call.in-progress.error-vapifault-mistral-429-exceeded-quota",
              "call.in-progress.error-providerfault-mistral-500-server-error",
              "call.in-progress.error-providerfault-mistral-503-server-overloaded-error",
              "pipeline-error-inflection-ai-400-bad-request-validation-failed",
              "pipeline-error-inflection-ai-401-unauthorized",
              "pipeline-error-inflection-ai-403-model-access-denied",
              "pipeline-error-inflection-ai-429-exceeded-quota",
              "pipeline-error-inflection-ai-500-server-error",
              "pipeline-error-inflection-ai-503-server-overloaded-error",
              "pipeline-error-inflection-ai-llm-failed",
              "call.in-progress.error-vapifault-inflection-ai-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-inflection-ai-401-unauthorized",
              "call.in-progress.error-vapifault-inflection-ai-403-model-access-denied",
              "call.in-progress.error-vapifault-inflection-ai-429-exceeded-quota",
              "call.in-progress.error-providerfault-inflection-ai-500-server-error",
              "call.in-progress.error-providerfault-inflection-ai-503-server-overloaded-error",
              "pipeline-error-deep-seek-400-bad-request-validation-failed",
              "pipeline-error-deep-seek-401-unauthorized",
              "pipeline-error-deep-seek-403-model-access-denied",
              "pipeline-error-deep-seek-429-exceeded-quota",
              "pipeline-error-deep-seek-500-server-error",
              "pipeline-error-deep-seek-503-server-overloaded-error",
              "pipeline-error-deep-seek-llm-failed",
              "call.in-progress.error-vapifault-deep-seek-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-deep-seek-401-unauthorized",
              "call.in-progress.error-vapifault-deep-seek-403-model-access-denied",
              "call.in-progress.error-vapifault-deep-seek-429-exceeded-quota",
              "call.in-progress.error-providerfault-deep-seek-500-server-error",
              "call.in-progress.error-providerfault-deep-seek-503-server-overloaded-error",
              "pipeline-error-groq-400-bad-request-validation-failed",
              "pipeline-error-groq-401-unauthorized",
              "pipeline-error-groq-403-model-access-denied",
              "pipeline-error-groq-429-exceeded-quota",
              "pipeline-error-groq-500-server-error",
              "pipeline-error-groq-503-server-overloaded-error",
              "pipeline-error-groq-llm-failed",
              "call.in-progress.error-vapifault-groq-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-groq-401-unauthorized",
              "call.in-progress.error-vapifault-groq-403-model-access-denied",
              "call.in-progress.error-vapifault-groq-429-exceeded-quota",
              "call.in-progress.error-providerfault-groq-500-server-error",
              "call.in-progress.error-providerfault-groq-503-server-overloaded-error",
              "pipeline-error-cerebras-400-bad-request-validation-failed",
              "pipeline-error-cerebras-401-unauthorized",
              "pipeline-error-cerebras-403-model-access-denied",
              "pipeline-error-cerebras-429-exceeded-quota",
              "pipeline-error-cerebras-500-server-error",
              "pipeline-error-cerebras-503-server-overloaded-error",
              "pipeline-error-cerebras-llm-failed",
              "call.in-progress.error-vapifault-cerebras-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-cerebras-401-unauthorized",
              "call.in-progress.error-vapifault-cerebras-403-model-access-denied",
              "call.in-progress.error-vapifault-cerebras-429-exceeded-quota",
              "call.in-progress.error-providerfault-cerebras-500-server-error",
              "call.in-progress.error-providerfault-cerebras-503-server-overloaded-error",
              "pipeline-error-anthropic-400-bad-request-validation-failed",
              "pipeline-error-anthropic-401-unauthorized",
              "pipeline-error-anthropic-403-model-access-denied",
              "pipeline-error-anthropic-429-exceeded-quota",
              "pipeline-error-anthropic-500-server-error",
              "pipeline-error-anthropic-503-server-overloaded-error",
              "pipeline-error-anthropic-llm-failed",
              "call.in-progress.error-vapifault-anthropic-llm-failed",
              "call.in-progress.error-vapifault-anthropic-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-anthropic-401-unauthorized",
              "call.in-progress.error-vapifault-anthropic-403-model-access-denied",
              "call.in-progress.error-vapifault-anthropic-429-exceeded-quota",
              "call.in-progress.error-providerfault-anthropic-500-server-error",
              "call.in-progress.error-providerfault-anthropic-503-server-overloaded-error",
              "pipeline-error-anthropic-bedrock-400-bad-request-validation-failed",
              "pipeline-error-anthropic-bedrock-401-unauthorized",
              "pipeline-error-anthropic-bedrock-403-model-access-denied",
              "pipeline-error-anthropic-bedrock-429-exceeded-quota",
              "pipeline-error-anthropic-bedrock-500-server-error",
              "pipeline-error-anthropic-bedrock-503-server-overloaded-error",
              "pipeline-error-anthropic-bedrock-llm-failed",
              "call.in-progress.error-vapifault-anthropic-bedrock-llm-failed",
              "call.in-progress.error-vapifault-anthropic-bedrock-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-anthropic-bedrock-401-unauthorized",
              "call.in-progress.error-vapifault-anthropic-bedrock-403-model-access-denied",
              "call.in-progress.error-vapifault-anthropic-bedrock-429-exceeded-quota",
              "call.in-progress.error-providerfault-anthropic-bedrock-500-server-error",
              "call.in-progress.error-providerfault-anthropic-bedrock-503-server-overloaded-error",
              "pipeline-error-anthropic-vertex-400-bad-request-validation-failed",
              "pipeline-error-anthropic-vertex-401-unauthorized",
              "pipeline-error-anthropic-vertex-403-model-access-denied",
              "pipeline-error-anthropic-vertex-429-exceeded-quota",
              "pipeline-error-anthropic-vertex-500-server-error",
              "pipeline-error-anthropic-vertex-503-server-overloaded-error",
              "pipeline-error-anthropic-vertex-llm-failed",
              "call.in-progress.error-vapifault-anthropic-vertex-llm-failed",
              "call.in-progress.error-vapifault-anthropic-vertex-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-anthropic-vertex-401-unauthorized",
              "call.in-progress.error-vapifault-anthropic-vertex-403-model-access-denied",
              "call.in-progress.error-vapifault-anthropic-vertex-429-exceeded-quota",
              "call.in-progress.error-providerfault-anthropic-vertex-500-server-error",
              "call.in-progress.error-providerfault-anthropic-vertex-503-server-overloaded-error",
              "pipeline-error-together-ai-400-bad-request-validation-failed",
              "pipeline-error-together-ai-401-unauthorized",
              "pipeline-error-together-ai-403-model-access-denied",
              "pipeline-error-together-ai-429-exceeded-quota",
              "pipeline-error-together-ai-500-server-error",
              "pipeline-error-together-ai-503-server-overloaded-error",
              "pipeline-error-together-ai-llm-failed",
              "call.in-progress.error-vapifault-together-ai-llm-failed",
              "call.in-progress.error-vapifault-together-ai-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-together-ai-401-unauthorized",
              "call.in-progress.error-vapifault-together-ai-403-model-access-denied",
              "call.in-progress.error-vapifault-together-ai-429-exceeded-quota",
              "call.in-progress.error-providerfault-together-ai-500-server-error",
              "call.in-progress.error-providerfault-together-ai-503-server-overloaded-error",
              "pipeline-error-anyscale-400-bad-request-validation-failed",
              "pipeline-error-anyscale-401-unauthorized",
              "pipeline-error-anyscale-403-model-access-denied",
              "pipeline-error-anyscale-429-exceeded-quota",
              "pipeline-error-anyscale-500-server-error",
              "pipeline-error-anyscale-503-server-overloaded-error",
              "pipeline-error-anyscale-llm-failed",
              "call.in-progress.error-vapifault-anyscale-llm-failed",
              "call.in-progress.error-vapifault-anyscale-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-anyscale-401-unauthorized",
              "call.in-progress.error-vapifault-anyscale-403-model-access-denied",
              "call.in-progress.error-vapifault-anyscale-429-exceeded-quota",
              "call.in-progress.error-providerfault-anyscale-500-server-error",
              "call.in-progress.error-providerfault-anyscale-503-server-overloaded-error",
              "pipeline-error-openrouter-400-bad-request-validation-failed",
              "pipeline-error-openrouter-401-unauthorized",
              "pipeline-error-openrouter-403-model-access-denied",
              "pipeline-error-openrouter-429-exceeded-quota",
              "pipeline-error-openrouter-500-server-error",
              "pipeline-error-openrouter-503-server-overloaded-error",
              "pipeline-error-openrouter-llm-failed",
              "call.in-progress.error-vapifault-openrouter-llm-failed",
              "call.in-progress.error-vapifault-openrouter-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-openrouter-401-unauthorized",
              "call.in-progress.error-vapifault-openrouter-403-model-access-denied",
              "call.in-progress.error-vapifault-openrouter-429-exceeded-quota",
              "call.in-progress.error-providerfault-openrouter-500-server-error",
              "call.in-progress.error-providerfault-openrouter-503-server-overloaded-error",
              "pipeline-error-perplexity-ai-400-bad-request-validation-failed",
              "pipeline-error-perplexity-ai-401-unauthorized",
              "pipeline-error-perplexity-ai-403-model-access-denied",
              "pipeline-error-perplexity-ai-429-exceeded-quota",
              "pipeline-error-perplexity-ai-500-server-error",
              "pipeline-error-perplexity-ai-503-server-overloaded-error",
              "pipeline-error-perplexity-ai-llm-failed",
              "call.in-progress.error-vapifault-perplexity-ai-llm-failed",
              "call.in-progress.error-vapifault-perplexity-ai-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-perplexity-ai-401-unauthorized",
              "call.in-progress.error-vapifault-perplexity-ai-403-model-access-denied",
              "call.in-progress.error-vapifault-perplexity-ai-429-exceeded-quota",
              "call.in-progress.error-providerfault-perplexity-ai-500-server-error",
              "call.in-progress.error-providerfault-perplexity-ai-503-server-overloaded-error",
              "pipeline-error-deepinfra-400-bad-request-validation-failed",
              "pipeline-error-deepinfra-401-unauthorized",
              "pipeline-error-deepinfra-403-model-access-denied",
              "pipeline-error-deepinfra-429-exceeded-quota",
              "pipeline-error-deepinfra-500-server-error",
              "pipeline-error-deepinfra-503-server-overloaded-error",
              "pipeline-error-deepinfra-llm-failed",
              "call.in-progress.error-vapifault-deepinfra-llm-failed",
              "call.in-progress.error-vapifault-deepinfra-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-deepinfra-401-unauthorized",
              "call.in-progress.error-vapifault-deepinfra-403-model-access-denied",
              "call.in-progress.error-vapifault-deepinfra-429-exceeded-quota",
              "call.in-progress.error-providerfault-deepinfra-500-server-error",
              "call.in-progress.error-providerfault-deepinfra-503-server-overloaded-error",
              "pipeline-error-runpod-400-bad-request-validation-failed",
              "pipeline-error-runpod-401-unauthorized",
              "pipeline-error-runpod-403-model-access-denied",
              "pipeline-error-runpod-429-exceeded-quota",
              "pipeline-error-runpod-500-server-error",
              "pipeline-error-runpod-503-server-overloaded-error",
              "pipeline-error-runpod-llm-failed",
              "call.in-progress.error-vapifault-runpod-llm-failed",
              "call.in-progress.error-vapifault-runpod-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-runpod-401-unauthorized",
              "call.in-progress.error-vapifault-runpod-403-model-access-denied",
              "call.in-progress.error-vapifault-runpod-429-exceeded-quota",
              "call.in-progress.error-providerfault-runpod-500-server-error",
              "call.in-progress.error-providerfault-runpod-503-server-overloaded-error",
              "pipeline-error-custom-llm-400-bad-request-validation-failed",
              "pipeline-error-custom-llm-401-unauthorized",
              "pipeline-error-custom-llm-403-model-access-denied",
              "pipeline-error-custom-llm-429-exceeded-quota",
              "pipeline-error-custom-llm-500-server-error",
              "pipeline-error-custom-llm-503-server-overloaded-error",
              "pipeline-error-custom-llm-llm-failed",
              "call.in-progress.error-vapifault-custom-llm-llm-failed",
              "call.in-progress.error-vapifault-custom-llm-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-custom-llm-401-unauthorized",
              "call.in-progress.error-vapifault-custom-llm-403-model-access-denied",
              "call.in-progress.error-vapifault-custom-llm-429-exceeded-quota",
              "call.in-progress.error-providerfault-custom-llm-500-server-error",
              "call.in-progress.error-providerfault-custom-llm-503-server-overloaded-error",
              "pipeline-error-custom-voice-failed",
              "pipeline-error-cartesia-socket-hang-up",
              "pipeline-error-cartesia-requested-payment",
              "pipeline-error-cartesia-500-server-error",
              "pipeline-error-cartesia-503-server-error",
              "pipeline-error-cartesia-522-server-error",
              "call.in-progress.error-vapifault-cartesia-socket-hang-up",
              "call.in-progress.error-vapifault-cartesia-requested-payment",
              "call.in-progress.error-providerfault-cartesia-500-server-error",
              "call.in-progress.error-providerfault-cartesia-503-server-error",
              "call.in-progress.error-providerfault-cartesia-522-server-error",
              "pipeline-error-eleven-labs-voice-not-found",
              "pipeline-error-eleven-labs-quota-exceeded",
              "pipeline-error-eleven-labs-unauthorized-access",
              "pipeline-error-eleven-labs-unauthorized-to-access-model",
              "pipeline-error-eleven-labs-professional-voices-only-for-creator-plus",
              "pipeline-error-eleven-labs-blocked-free-plan-and-requested-upgrade",
              "pipeline-error-eleven-labs-blocked-concurrent-requests-and-requested-upgrade",
              "pipeline-error-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade",
              "pipeline-error-eleven-labs-system-busy-and-requested-upgrade",
              "pipeline-error-eleven-labs-voice-not-fine-tuned",
              "pipeline-error-eleven-labs-invalid-api-key",
              "pipeline-error-eleven-labs-invalid-voice-samples",
              "pipeline-error-eleven-labs-voice-disabled-by-owner",
              "pipeline-error-eleven-labs-blocked-account-in-probation",
              "pipeline-error-eleven-labs-blocked-content-against-their-policy",
              "pipeline-error-eleven-labs-missing-samples-for-voice-clone",
              "pipeline-error-eleven-labs-voice-not-fine-tuned-and-cannot-be-used",
              "pipeline-error-eleven-labs-voice-not-allowed-for-free-users",
              "pipeline-error-eleven-labs-max-character-limit-exceeded",
              "pipeline-error-eleven-labs-blocked-voice-potentially-against-terms-of-service-and-awaiting-verification",
              "pipeline-error-eleven-labs-500-server-error",
              "call.in-progress.error-vapifault-eleven-labs-voice-not-found",
              "call.in-progress.error-vapifault-eleven-labs-quota-exceeded",
              "call.in-progress.error-vapifault-eleven-labs-unauthorized-access",
              "call.in-progress.error-vapifault-eleven-labs-unauthorized-to-access-model",
              "call.in-progress.error-vapifault-eleven-labs-professional-voices-only-for-creator-plus",
              "call.in-progress.error-vapifault-eleven-labs-blocked-free-plan-and-requested-upgrade",
              "call.in-progress.error-vapifault-eleven-labs-blocked-concurrent-requests-and-requested-upgrade",
              "call.in-progress.error-vapifault-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade",
              "call.in-progress.error-vapifault-eleven-labs-system-busy-and-requested-upgrade",
              "call.in-progress.error-vapifault-eleven-labs-voice-not-fine-tuned",
              "call.in-progress.error-vapifault-eleven-labs-invalid-api-key",
              "call.in-progress.error-vapifault-eleven-labs-invalid-voice-samples",
              "call.in-progress.error-vapifault-eleven-labs-voice-disabled-by-owner",
              "call.in-progress.error-vapifault-eleven-labs-blocked-account-in-probation",
              "call.in-progress.error-vapifault-eleven-labs-blocked-content-against-their-policy",
              "call.in-progress.error-vapifault-eleven-labs-missing-samples-for-voice-clone",
              "call.in-progress.error-vapifault-eleven-labs-voice-not-fine-tuned-and-cannot-be-used",
              "call.in-progress.error-vapifault-eleven-labs-voice-not-allowed-for-free-users",
              "call.in-progress.error-vapifault-eleven-labs-max-character-limit-exceeded",
              "call.in-progress.error-vapifault-eleven-labs-blocked-voice-potentially-against-terms-of-service-and-awaiting-verification",
              "call.in-progress.error-providerfault-eleven-labs-500-server-error",
              "pipeline-error-playht-request-timed-out",
              "pipeline-error-playht-invalid-voice",
              "pipeline-error-playht-unexpected-error",
              "pipeline-error-playht-out-of-credits",
              "pipeline-error-playht-invalid-emotion",
              "pipeline-error-playht-voice-must-be-a-valid-voice-manifest-uri",
              "pipeline-error-playht-401-unauthorized",
              "pipeline-error-playht-403-forbidden-out-of-characters",
              "pipeline-error-playht-403-forbidden-api-access-not-available",
              "pipeline-error-playht-429-exceeded-quota",
              "pipeline-error-playht-502-gateway-error",
              "pipeline-error-playht-504-gateway-error",
              "call.in-progress.error-vapifault-playht-request-timed-out",
              "call.in-progress.error-vapifault-playht-invalid-voice",
              "call.in-progress.error-vapifault-playht-unexpected-error",
              "call.in-progress.error-vapifault-playht-out-of-credits",
              "call.in-progress.error-vapifault-playht-invalid-emotion",
              "call.in-progress.error-vapifault-playht-voice-must-be-a-valid-voice-manifest-uri",
              "call.in-progress.error-vapifault-playht-401-unauthorized",
              "call.in-progress.error-vapifault-playht-403-forbidden-out-of-characters",
              "call.in-progress.error-vapifault-playht-403-forbidden-api-access-not-available",
              "call.in-progress.error-vapifault-playht-429-exceeded-quota",
              "call.in-progress.error-providerfault-playht-502-gateway-error",
              "call.in-progress.error-providerfault-playht-504-gateway-error",
              "pipeline-error-custom-transcriber-failed",
              "call.in-progress.error-vapifault-custom-transcriber-failed",
              "pipeline-error-eleven-labs-transcriber-failed",
              "call.in-progress.error-vapifault-eleven-labs-transcriber-failed",
              "pipeline-error-deepgram-returning-400-no-such-model-language-tier-combination",
              "pipeline-error-deepgram-returning-401-invalid-credentials",
              "pipeline-error-deepgram-returning-403-model-access-denied",
              "pipeline-error-deepgram-returning-404-not-found",
              "pipeline-error-deepgram-returning-500-invalid-json",
              "pipeline-error-deepgram-returning-502-network-error",
              "pipeline-error-deepgram-returning-502-bad-gateway-ehostunreach",
              "call.in-progress.error-vapifault-deepgram-returning-400-no-such-model-language-tier-combination",
              "call.in-progress.error-vapifault-deepgram-returning-401-invalid-credentials",
              "call.in-progress.error-vapifault-deepgram-returning-404-not-found",
              "call.in-progress.error-vapifault-deepgram-returning-403-model-access-denied",
              "call.in-progress.error-providerfault-deepgram-returning-500-invalid-json",
              "call.in-progress.error-providerfault-deepgram-returning-502-network-error",
              "call.in-progress.error-providerfault-deepgram-returning-502-bad-gateway-ehostunreach",
              "pipeline-error-google-transcriber-failed",
              "call.in-progress.error-vapifault-google-transcriber-failed",
              "pipeline-error-openai-transcriber-failed",
              "call.in-progress.error-vapifault-openai-transcriber-failed",
              "assistant-ended-call",
              "assistant-said-end-call-phrase",
              "assistant-ended-call-with-hangup-task",
              "assistant-ended-call-after-message-spoken",
              "assistant-forwarded-call",
              "assistant-join-timed-out",
              "call.in-progress.error-assistant-did-not-receive-customer-audio",
              "customer-busy",
              "customer-ended-call",
              "customer-did-not-answer",
              "customer-did-not-give-microphone-permission",
              "exceeded-max-duration",
              "manually-canceled",
              "phone-call-provider-closed-websocket",
              "call.forwarding.operator-busy",
              "silence-timed-out",
              "call.in-progress.error-sip-inbound-call-failed-to-connect",
              "call.in-progress.error-providerfault-outbound-sip-403-forbidden",
              "call.in-progress.error-providerfault-outbound-sip-407-proxy-authentication-required",
              "call.in-progress.error-providerfault-outbound-sip-503-service-unavailable",
              "call.in-progress.error-providerfault-outbound-sip-480-temporarily-unavailable",
              "call.in-progress.error-sip-outbound-call-failed-to-connect",
              "call.ringing.hook-executed-say",
              "call.ringing.hook-executed-transfer",
              "twilio-failed-to-connect-call",
              "twilio-reported-customer-misdialed",
              "vonage-rejected",
              "voicemail"
            ]
          },
          "destination": {
            "description": "This is the destination where the call ended up being transferred to. If the call was not transferred, this will be empty.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the call."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this call belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the call was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the call was last updated."
          },
          "startedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the call was started."
          },
          "endedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the call was ended."
          },
          "cost": {
            "type": "number",
            "description": "This is the cost of the call in USD."
          },
          "costBreakdown": {
            "description": "This is the cost of the call in USD.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CostBreakdown"
              }
            ]
          },
          "artifactPlan": {
            "description": "This is a copy of assistant artifact plan. This isn't actually stored on the call but rather just returned in POST /call/web to enable artifact creation client side.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ArtifactPlan"
              }
            ]
          },
          "analysis": {
            "description": "This is the analysis of the call. Configure in `assistant.analysisPlan`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Analysis"
              }
            ]
          },
          "monitor": {
            "description": "This is to real-time monitor the call. Configure in `assistant.monitorPlan`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Monitor"
              }
            ]
          },
          "artifact": {
            "description": "These are the artifacts created from the call. Configure in `assistant.artifactPlan`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Artifact"
              }
            ]
          },
          "phoneCallProviderId": {
            "type": "string",
            "description": "The ID of the call as provided by the phone number service. callSid in Twilio. conversationUuid in Vonage. callControlId in Telnyx.\n\nOnly relevant for `outboundPhoneCall` and `inboundPhoneCall` type.",
            "deprecated": true
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant ID that will be used for the call. To use a transient assistant, use `assistant` instead.\n\nTo start a call with:\n- Assistant, use `assistantId` or `assistant`\n- Squad, use `squadId` or `squad`\n- Workflow, use `workflowId` or `workflow`"
          },
          "assistant": {
            "description": "This is the assistant that will be used for the call. To use an existing assistant, use `assistantId` instead.\n\nTo start a call with:\n- Assistant, use `assistant`\n- Squad, use `squad`\n- Workflow, use `workflow`",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "assistantOverrides": {
            "description": "These are the overrides for the `assistant` or `assistantId`'s settings and template variables.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AssistantOverrides"
              }
            ]
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for the call. To use a transient squad, use `squad` instead.\n\nTo start a call with:\n- Assistant, use `assistant` or `assistantId`\n- Squad, use `squad` or `squadId`\n- Workflow, use `workflow` or `workflowId`"
          },
          "squad": {
            "description": "This is a squad that will be used for the call. To use an existing squad, use `squadId` instead.\n\nTo start a call with:\n- Assistant, use `assistant` or `assistantId`\n- Squad, use `squad` or `squadId`\n- Workflow, use `workflow` or `workflowId`",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateSquadDTO"
              }
            ]
          },
          "workflowId": {
            "type": "string",
            "description": "[BETA] This feature is in active development. The API and behavior are subject to change as we refine it based on user feedback.\n\nThis is the workflow that will be used for the call. To use a transient workflow, use `workflow` instead.\n\nTo start a call with:\n- Assistant, use `assistant` or `assistantId`\n- Squad, use `squad` or `squadId`\n- Workflow, use `workflow` or `workflowId`"
          },
          "workflow": {
            "description": "[BETA] This feature is in active development. The API and behavior are subject to change as we refine it based on user feedback.\n\nThis is a workflow that will be used for the call. To use an existing workflow, use `workflowId` instead.\n\nTo start a call with:\n- Assistant, use `assistant` or `assistantId`\n- Squad, use `squad` or `squadId`\n- Workflow, use `workflow` or `workflowId`",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateWorkflowDTO"
              }
            ]
          },
          "phoneNumberId": {
            "type": "string",
            "description": "This is the phone number that will be used for the call. To use a transient number, use `phoneNumber` instead.\n\nOnly relevant for `outboundPhoneCall` and `inboundPhoneCall` type."
          },
          "phoneNumber": {
            "description": "This is the phone number that will be used for the call. To use an existing number, use `phoneNumberId` instead.\n\nOnly relevant for `outboundPhoneCall` and `inboundPhoneCall` type.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ImportTwilioPhoneNumberDTO"
              }
            ]
          },
          "customerId": {
            "type": "string",
            "description": "This is the customer that will be called. To call a transient customer , use `customer` instead.\n\nOnly relevant for `outboundPhoneCall` and `inboundPhoneCall` type."
          },
          "customer": {
            "description": "This is the customer that will be called. To call an existing customer, use `customerId` instead.\n\nOnly relevant for `outboundPhoneCall` and `inboundPhoneCall` type.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of the call. This is just for your own reference.",
            "maxLength": 40
          },
          "schedulePlan": {
            "description": "This is the schedule plan of the call.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SchedulePlan"
              }
            ]
          },
          "transport": {
            "type": "object",
            "description": "This is the transport of the call."
          }
        },
        "required": [
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "CallBatchError": {
        "type": "object",
        "properties": {
          "customer": {
            "$ref": "#/components/schemas/CreateCustomerDTO"
          },
          "error": {
            "type": "string"
          }
        },
        "required": [
          "customer",
          "error"
        ]
      },
      "CallBatchResponse": {
        "type": "object",
        "properties": {
          "results": {
            "description": "This is the list of calls that were created.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Call"
            }
          },
          "errors": {
            "description": "This is the list of calls that failed to be created.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CallBatchError"
            }
          }
        },
        "required": [
          "results",
          "errors"
        ]
      },
      "CreateCallDTO": {
        "type": "object",
        "properties": {
          "customers": {
            "description": "This is used to issue batch calls to multiple customers.\n\nOnly relevant for `outboundPhoneCall`. To call a single customer, use `customer` instead.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateCustomerDTO"
            }
          },
          "name": {
            "type": "string",
            "description": "This is the name of the call. This is just for your own reference.",
            "maxLength": 40
          },
          "schedulePlan": {
            "description": "This is the schedule plan of the call.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SchedulePlan"
              }
            ]
          },
          "transport": {
            "type": "object",
            "description": "This is the transport of the call."
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant ID that will be used for the call. To use a transient assistant, use `assistant` instead.\n\nTo start a call with:\n- Assistant, use `assistantId` or `assistant`\n- Squad, use `squadId` or `squad`\n- Workflow, use `workflowId` or `workflow`"
          },
          "assistant": {
            "description": "This is the assistant that will be used for the call. To use an existing assistant, use `assistantId` instead.\n\nTo start a call with:\n- Assistant, use `assistant`\n- Squad, use `squad`\n- Workflow, use `workflow`",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "assistantOverrides": {
            "description": "These are the overrides for the `assistant` or `assistantId`'s settings and template variables.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AssistantOverrides"
              }
            ]
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for the call. To use a transient squad, use `squad` instead.\n\nTo start a call with:\n- Assistant, use `assistant` or `assistantId`\n- Squad, use `squad` or `squadId`\n- Workflow, use `workflow` or `workflowId`"
          },
          "squad": {
            "description": "This is a squad that will be used for the call. To use an existing squad, use `squadId` instead.\n\nTo start a call with:\n- Assistant, use `assistant` or `assistantId`\n- Squad, use `squad` or `squadId`\n- Workflow, use `workflow` or `workflowId`",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateSquadDTO"
              }
            ]
          },
          "workflowId": {
            "type": "string",
            "description": "[BETA] This feature is in active development. The API and behavior are subject to change as we refine it based on user feedback.\n\nThis is the workflow that will be used for the call. To use a transient workflow, use `workflow` instead.\n\nTo start a call with:\n- Assistant, use `assistant` or `assistantId`\n- Squad, use `squad` or `squadId`\n- Workflow, use `workflow` or `workflowId`"
          },
          "workflow": {
            "description": "[BETA] This feature is in active development. The API and behavior are subject to change as we refine it based on user feedback.\n\nThis is a workflow that will be used for the call. To use an existing workflow, use `workflowId` instead.\n\nTo start a call with:\n- Assistant, use `assistant` or `assistantId`\n- Squad, use `squad` or `squadId`\n- Workflow, use `workflow` or `workflowId`",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateWorkflowDTO"
              }
            ]
          },
          "phoneNumberId": {
            "type": "string",
            "description": "This is the phone number that will be used for the call. To use a transient number, use `phoneNumber` instead.\n\nOnly relevant for `outboundPhoneCall` and `inboundPhoneCall` type."
          },
          "phoneNumber": {
            "description": "This is the phone number that will be used for the call. To use an existing number, use `phoneNumberId` instead.\n\nOnly relevant for `outboundPhoneCall` and `inboundPhoneCall` type.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ImportTwilioPhoneNumberDTO"
              }
            ]
          },
          "customerId": {
            "type": "string",
            "description": "This is the customer that will be called. To call a transient customer , use `customer` instead.\n\nOnly relevant for `outboundPhoneCall` and `inboundPhoneCall` type."
          },
          "customer": {
            "description": "This is the customer that will be called. To call an existing customer, use `customerId` instead.\n\nOnly relevant for `outboundPhoneCall` and `inboundPhoneCall` type.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          }
        }
      },
      "PaginationMeta": {
        "type": "object",
        "properties": {
          "itemsPerPage": {
            "type": "number"
          },
          "totalItems": {
            "type": "number"
          },
          "currentPage": {
            "type": "number"
          }
        },
        "required": [
          "itemsPerPage",
          "totalItems",
          "currentPage"
        ]
      },
      "CallPaginatedResponse": {
        "type": "object",
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Call"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/PaginationMeta"
          }
        },
        "required": [
          "results",
          "metadata"
        ]
      },
      "CreateOutboundCallDTO": {
        "type": "object",
        "properties": {
          "customers": {
            "description": "This is used to issue batch calls to multiple customers.\n\nOnly relevant for `outboundPhoneCall`. To call a single customer, use `customer` instead.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateCustomerDTO"
            }
          },
          "name": {
            "type": "string",
            "description": "This is the name of the call. This is just for your own reference.",
            "maxLength": 40
          },
          "schedulePlan": {
            "description": "This is the schedule plan of the call.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SchedulePlan"
              }
            ]
          },
          "transport": {
            "type": "object",
            "description": "This is the transport of the call."
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant ID that will be used for the call. To use a transient assistant, use `assistant` instead.\n\nTo start a call with:\n- Assistant, use `assistantId` or `assistant`\n- Squad, use `squadId` or `squad`\n- Workflow, use `workflowId` or `workflow`"
          },
          "assistant": {
            "description": "This is the assistant that will be used for the call. To use an existing assistant, use `assistantId` instead.\n\nTo start a call with:\n- Assistant, use `assistant`\n- Squad, use `squad`\n- Workflow, use `workflow`",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "assistantOverrides": {
            "description": "These are the overrides for the `assistant` or `assistantId`'s settings and template variables.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AssistantOverrides"
              }
            ]
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for the call. To use a transient squad, use `squad` instead.\n\nTo start a call with:\n- Assistant, use `assistant` or `assistantId`\n- Squad, use `squad` or `squadId`\n- Workflow, use `workflow` or `workflowId`"
          },
          "squad": {
            "description": "This is a squad that will be used for the call. To use an existing squad, use `squadId` instead.\n\nTo start a call with:\n- Assistant, use `assistant` or `assistantId`\n- Squad, use `squad` or `squadId`\n- Workflow, use `workflow` or `workflowId`",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateSquadDTO"
              }
            ]
          },
          "workflowId": {
            "type": "string",
            "description": "[BETA] This feature is in active development. The API and behavior are subject to change as we refine it based on user feedback.\n\nThis is the workflow that will be used for the call. To use a transient workflow, use `workflow` instead.\n\nTo start a call with:\n- Assistant, use `assistant` or `assistantId`\n- Squad, use `squad` or `squadId`\n- Workflow, use `workflow` or `workflowId`"
          },
          "workflow": {
            "description": "[BETA] This feature is in active development. The API and behavior are subject to change as we refine it based on user feedback.\n\nThis is a workflow that will be used for the call. To use an existing workflow, use `workflowId` instead.\n\nTo start a call with:\n- Assistant, use `assistant` or `assistantId`\n- Squad, use `squad` or `squadId`\n- Workflow, use `workflow` or `workflowId`",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateWorkflowDTO"
              }
            ]
          },
          "phoneNumberId": {
            "type": "string",
            "description": "This is the phone number that will be used for the call. To use a transient number, use `phoneNumber` instead.\n\nOnly relevant for `outboundPhoneCall` and `inboundPhoneCall` type."
          },
          "phoneNumber": {
            "description": "This is the phone number that will be used for the call. To use an existing number, use `phoneNumberId` instead.\n\nOnly relevant for `outboundPhoneCall` and `inboundPhoneCall` type.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ImportTwilioPhoneNumberDTO"
              }
            ]
          },
          "customerId": {
            "type": "string",
            "description": "This is the customer that will be called. To call a transient customer , use `customer` instead.\n\nOnly relevant for `outboundPhoneCall` and `inboundPhoneCall` type."
          },
          "customer": {
            "description": "This is the customer that will be called. To call an existing customer, use `customerId` instead.\n\nOnly relevant for `outboundPhoneCall` and `inboundPhoneCall` type.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          }
        }
      },
      "CreateWebCallDTO": {
        "type": "object",
        "properties": {
          "assistantId": {
            "type": "string",
            "description": "This is the assistant ID that will be used for the call. To use a transient assistant, use `assistant` instead.\n\nTo start a call with:\n- Assistant, use `assistantId` or `assistant`\n- Squad, use `squadId` or `squad`\n- Workflow, use `workflowId` or `workflow`"
          },
          "assistant": {
            "description": "This is the assistant that will be used for the call. To use an existing assistant, use `assistantId` instead.\n\nTo start a call with:\n- Assistant, use `assistant`\n- Squad, use `squad`\n- Workflow, use `workflow`",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "assistantOverrides": {
            "description": "These are the overrides for the `assistant` or `assistantId`'s settings and template variables.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AssistantOverrides"
              }
            ]
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for the call. To use a transient squad, use `squad` instead.\n\nTo start a call with:\n- Assistant, use `assistant` or `assistantId`\n- Squad, use `squad` or `squadId`\n- Workflow, use `workflow` or `workflowId`"
          },
          "squad": {
            "description": "This is a squad that will be used for the call. To use an existing squad, use `squadId` instead.\n\nTo start a call with:\n- Assistant, use `assistant` or `assistantId`\n- Squad, use `squad` or `squadId`\n- Workflow, use `workflow` or `workflowId`",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateSquadDTO"
              }
            ]
          },
          "workflowId": {
            "type": "string",
            "description": "[BETA] This feature is in active development. The API and behavior are subject to change as we refine it based on user feedback.\n\nThis is the workflow that will be used for the call. To use a transient workflow, use `workflow` instead.\n\nTo start a call with:\n- Assistant, use `assistant` or `assistantId`\n- Squad, use `squad` or `squadId`\n- Workflow, use `workflow` or `workflowId`"
          },
          "workflow": {
            "description": "[BETA] This feature is in active development. The API and behavior are subject to change as we refine it based on user feedback.\n\nThis is a workflow that will be used for the call. To use an existing workflow, use `workflowId` instead.\n\nTo start a call with:\n- Assistant, use `assistant` or `assistantId`\n- Squad, use `squad` or `squadId`\n- Workflow, use `workflow` or `workflowId`",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateWorkflowDTO"
              }
            ]
          }
        }
      },
      "UpdateCallDTO": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "This is the name of the call. This is just for your own reference.",
            "maxLength": 40
          }
        }
      },
      "DeveloperMessage": {
        "type": "object",
        "properties": {
          "role": {
            "type": "string",
            "description": "This is the role of the message author",
            "default": "developer",
            "enum": [
              "developer"
            ]
          },
          "content": {
            "type": "string",
            "description": "This is the content of the developer message",
            "maxLength": 10000
          },
          "name": {
            "type": "string",
            "description": "This is an optional name for the participant",
            "maxLength": 40
          }
        },
        "required": [
          "role",
          "content"
        ]
      },
      "SystemMessage": {
        "type": "object",
        "properties": {
          "role": {
            "type": "string",
            "description": "The role of the system in the conversation."
          },
          "message": {
            "type": "string",
            "description": "The message content from the system."
          },
          "time": {
            "type": "number",
            "description": "The timestamp when the message was sent."
          },
          "secondsFromStart": {
            "type": "number",
            "description": "The number of seconds from the start of the conversation."
          }
        },
        "required": [
          "role",
          "message",
          "time",
          "secondsFromStart"
        ]
      },
      "UserMessage": {
        "type": "object",
        "properties": {
          "role": {
            "type": "string",
            "description": "The role of the user in the conversation."
          },
          "message": {
            "type": "string",
            "description": "The message content from the user."
          },
          "time": {
            "type": "number",
            "description": "The timestamp when the message was sent."
          },
          "endTime": {
            "type": "number",
            "description": "The timestamp when the message ended."
          },
          "secondsFromStart": {
            "type": "number",
            "description": "The number of seconds from the start of the conversation."
          },
          "duration": {
            "type": "number",
            "description": "The duration of the message in seconds."
          }
        },
        "required": [
          "role",
          "message",
          "time",
          "endTime",
          "secondsFromStart"
        ]
      },
      "ToolCallFunction": {
        "type": "object",
        "properties": {
          "arguments": {
            "type": "string",
            "description": "This is the arguments to call the function with"
          },
          "name": {
            "type": "string",
            "description": "This is the name of the function to call",
            "maxLength": 40
          }
        },
        "required": [
          "arguments",
          "name"
        ]
      },
      "ToolCall": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "This is the ID of the tool call"
          },
          "type": {
            "type": "string",
            "description": "This is the type of tool"
          },
          "function": {
            "description": "This is the function that was called",
            "allOf": [
              {
                "$ref": "#/components/schemas/ToolCallFunction"
              }
            ]
          }
        },
        "required": [
          "id",
          "type",
          "function"
        ]
      },
      "AssistantMessage": {
        "type": "object",
        "properties": {
          "role": {
            "type": "string",
            "description": "This is the role of the message author",
            "default": "assistant",
            "enum": [
              "assistant"
            ]
          },
          "content": {
            "type": "string",
            "description": "This is the content of the assistant message",
            "maxLength": 10000
          },
          "refusal": {
            "type": "string",
            "description": "This is the refusal message generated by the model",
            "maxLength": 10000
          },
          "tool_calls": {
            "description": "This is the tool calls generated by the model",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ToolCall"
            }
          },
          "name": {
            "type": "string",
            "description": "This is an optional name for the participant",
            "maxLength": 40
          }
        },
        "required": [
          "role"
        ]
      },
      "ToolMessage": {
        "type": "object",
        "properties": {
          "role": {
            "type": "string",
            "description": "This is the role of the message author",
            "default": "tool",
            "enum": [
              "tool"
            ]
          },
          "content": {
            "type": "string",
            "description": "This is the content of the tool message",
            "maxLength": 10000
          },
          "tool_call_id": {
            "type": "string",
            "description": "This is the ID of the tool call this message is responding to"
          },
          "name": {
            "type": "string",
            "description": "This is an optional name for the participant",
            "maxLength": 40
          }
        },
        "required": [
          "role",
          "content",
          "tool_call_id"
        ]
      },
      "FunctionCall": {
        "type": "object",
        "properties": {
          "arguments": {
            "type": "string",
            "description": "This is the arguments to call the function with"
          },
          "name": {
            "type": "string",
            "description": "This is the name of the function to call",
            "maxLength": 40
          }
        },
        "required": [
          "arguments",
          "name"
        ]
      },
      "Chat": {
        "type": "object",
        "properties": {
          "assistantId": {
            "type": "string",
            "description": "This is the assistant that will be used for the chat. To use an existing assistant, use `assistantId` instead."
          },
          "assistant": {
            "description": "This is the assistant that will be used for the chat. To use an existing assistant, use `assistantId` instead.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of the chat. This is just for your own reference.",
            "maxLength": 40
          },
          "sessionId": {
            "type": "string",
            "description": "This is the ID of the session that will be used for the chat.\nMutually exclusive with previousChatId."
          },
          "input": {
            "description": "This is the input text for the chat.\nCan be a string or an array of chat messages.",
            "oneOf": [
              {
                "type": "string",
                "title": "String"
              },
              {
                "type": "array",
                "items": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/SystemMessage",
                      "title": "SystemMessage"
                    },
                    {
                      "$ref": "#/components/schemas/UserMessage",
                      "title": "UserMessage"
                    },
                    {
                      "$ref": "#/components/schemas/AssistantMessage",
                      "title": "AssistantMessage"
                    },
                    {
                      "$ref": "#/components/schemas/ToolMessage",
                      "title": "ToolMessage"
                    },
                    {
                      "$ref": "#/components/schemas/DeveloperMessage",
                      "title": "DeveloperMessage"
                    }
                  ]
                },
                "title": "MessageArray"
              }
            ],
            "examples": [
              "Hello, how can you help me?",
              [
                {
                  "role": "user",
                  "content": "Hello, how can you help me?"
                }
              ]
            ]
          },
          "stream": {
            "type": "boolean",
            "description": "This is a flag that determines whether the response should be streamed.\nWhen true, the response will be sent as chunks of text.",
            "default": false
          },
          "previousChatId": {
            "type": "string",
            "description": "This is the ID of the chat that will be used as context for the new chat.\nThe messages from the previous chat will be used as context.\nMutually exclusive with sessionId."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the chat."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this chat belongs to."
          },
          "messages": {
            "type": "array",
            "description": "This is an array of messages used as context for the chat.\nUsed to provide message history for multi-turn conversations.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/SystemMessage",
                  "title": "SystemMessage"
                },
                {
                  "$ref": "#/components/schemas/UserMessage",
                  "title": "UserMessage"
                },
                {
                  "$ref": "#/components/schemas/AssistantMessage",
                  "title": "AssistantMessage"
                },
                {
                  "$ref": "#/components/schemas/ToolMessage",
                  "title": "ToolMessage"
                },
                {
                  "$ref": "#/components/schemas/DeveloperMessage",
                  "title": "DeveloperMessage"
                }
              ]
            }
          },
          "output": {
            "type": "array",
            "description": "This is the output messages generated by the system in response to the input.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/SystemMessage",
                  "title": "SystemMessage"
                },
                {
                  "$ref": "#/components/schemas/UserMessage",
                  "title": "UserMessage"
                },
                {
                  "$ref": "#/components/schemas/AssistantMessage",
                  "title": "AssistantMessage"
                },
                {
                  "$ref": "#/components/schemas/ToolMessage",
                  "title": "ToolMessage"
                },
                {
                  "$ref": "#/components/schemas/DeveloperMessage",
                  "title": "DeveloperMessage"
                }
              ]
            }
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the chat was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the chat was last updated."
          }
        },
        "required": [
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "CreateChatDTO": {
        "type": "object",
        "properties": {
          "assistantId": {
            "type": "string",
            "description": "This is the assistant that will be used for the chat. To use an existing assistant, use `assistantId` instead."
          },
          "assistant": {
            "description": "This is the assistant that will be used for the chat. To use an existing assistant, use `assistantId` instead.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of the chat. This is just for your own reference.",
            "maxLength": 40
          },
          "sessionId": {
            "type": "string",
            "description": "This is the ID of the session that will be used for the chat.\nMutually exclusive with previousChatId."
          },
          "input": {
            "description": "This is the input text for the chat.\nCan be a string or an array of chat messages.\nThis field is REQUIRED for chat creation.",
            "oneOf": [
              {
                "type": "string",
                "title": "String"
              },
              {
                "type": "array",
                "items": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/SystemMessage",
                      "title": "SystemMessage"
                    },
                    {
                      "$ref": "#/components/schemas/UserMessage",
                      "title": "UserMessage"
                    },
                    {
                      "$ref": "#/components/schemas/AssistantMessage",
                      "title": "AssistantMessage"
                    },
                    {
                      "$ref": "#/components/schemas/ToolMessage",
                      "title": "ToolMessage"
                    },
                    {
                      "$ref": "#/components/schemas/DeveloperMessage",
                      "title": "DeveloperMessage"
                    }
                  ]
                },
                "title": "MessageArray"
              }
            ],
            "examples": [
              "Hello, how can you help me?",
              [
                {
                  "role": "user",
                  "content": "Hello, how can you help me?"
                }
              ]
            ]
          },
          "stream": {
            "type": "boolean",
            "description": "This is a flag that determines whether the response should be streamed.\nWhen true, the response will be sent as chunks of text.",
            "default": false
          },
          "previousChatId": {
            "type": "string",
            "description": "This is the ID of the chat that will be used as context for the new chat.\nThe messages from the previous chat will be used as context.\nMutually exclusive with sessionId."
          }
        },
        "required": [
          "input"
        ]
      },
      "GetChatPaginatedDTO": {
        "type": "object",
        "properties": {
          "assistantId": {
            "type": "string",
            "description": "This is the unique identifier for the assistant that will be used for the chat."
          },
          "workflowId": {
            "type": "string",
            "description": "This is the unique identifier for the workflow that will be used for the chat."
          },
          "sessionId": {
            "type": "string",
            "description": "This is the unique identifier for the session that will be used for the chat."
          },
          "page": {
            "type": "number",
            "description": "This is the page number to return. Defaults to 1.",
            "minimum": 1
          },
          "sortOrder": {
            "type": "string",
            "description": "This is the sort order for pagination. Defaults to 'DESC'.",
            "enum": [
              "ASC",
              "DESC"
            ]
          },
          "limit": {
            "type": "number",
            "description": "This is the maximum number of items to return. Defaults to 100.",
            "minimum": 0,
            "maximum": 1000
          },
          "createdAtGt": {
            "format": "date-time",
            "type": "string",
            "description": "This will return items where the createdAt is greater than the specified value."
          },
          "createdAtLt": {
            "format": "date-time",
            "type": "string",
            "description": "This will return items where the createdAt is less than the specified value."
          },
          "createdAtGe": {
            "format": "date-time",
            "type": "string",
            "description": "This will return items where the createdAt is greater than or equal to the specified value."
          },
          "createdAtLe": {
            "format": "date-time",
            "type": "string",
            "description": "This will return items where the createdAt is less than or equal to the specified value."
          },
          "updatedAtGt": {
            "format": "date-time",
            "type": "string",
            "description": "This will return items where the updatedAt is greater than the specified value."
          },
          "updatedAtLt": {
            "format": "date-time",
            "type": "string",
            "description": "This will return items where the updatedAt is less than the specified value."
          },
          "updatedAtGe": {
            "format": "date-time",
            "type": "string",
            "description": "This will return items where the updatedAt is greater than or equal to the specified value."
          },
          "updatedAtLe": {
            "format": "date-time",
            "type": "string",
            "description": "This will return items where the updatedAt is less than or equal to the specified value."
          }
        }
      },
      "ChatPaginatedResponse": {
        "type": "object",
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Chat"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/PaginationMeta"
          }
        },
        "required": [
          "results",
          "metadata"
        ]
      },
      "CreateChatStreamResponse": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the streaming response."
          },
          "path": {
            "type": "string",
            "description": "This is the path to the content being updated.\nFormat: `chat.output[{contentIndex}].content` where contentIndex identifies the specific content item.",
            "example": "chat.output[0].content"
          },
          "delta": {
            "type": "string",
            "description": "This is the incremental content chunk being streamed."
          }
        },
        "required": [
          "id",
          "path",
          "delta"
        ]
      },
      "OpenAIResponsesRequest": {
        "type": "object",
        "properties": {
          "assistantId": {
            "type": "string",
            "description": "This is the assistant that will be used for the chat. To use an existing assistant, use `assistantId` instead."
          },
          "assistant": {
            "description": "This is the assistant that will be used for the chat. To use an existing assistant, use `assistantId` instead.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of the chat. This is just for your own reference.",
            "maxLength": 40
          },
          "sessionId": {
            "type": "string",
            "description": "This is the ID of the session that will be used for the chat.\nMutually exclusive with previousChatId."
          },
          "input": {
            "description": "This is the input text for the chat.\nCan be a string or an array of chat messages.\nThis field is REQUIRED for chat creation.",
            "oneOf": [
              {
                "type": "string",
                "title": "String"
              },
              {
                "type": "array",
                "items": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/SystemMessage",
                      "title": "SystemMessage"
                    },
                    {
                      "$ref": "#/components/schemas/UserMessage",
                      "title": "UserMessage"
                    },
                    {
                      "$ref": "#/components/schemas/AssistantMessage",
                      "title": "AssistantMessage"
                    },
                    {
                      "$ref": "#/components/schemas/ToolMessage",
                      "title": "ToolMessage"
                    },
                    {
                      "$ref": "#/components/schemas/DeveloperMessage",
                      "title": "DeveloperMessage"
                    }
                  ]
                },
                "title": "MessageArray"
              }
            ],
            "examples": [
              "Hello, how can you help me?",
              [
                {
                  "role": "user",
                  "content": "Hello, how can you help me?"
                }
              ]
            ]
          },
          "stream": {
            "type": "boolean",
            "description": "Whether to stream the response or not.",
            "default": true
          },
          "previousChatId": {
            "type": "string",
            "description": "This is the ID of the chat that will be used as context for the new chat.\nThe messages from the previous chat will be used as context.\nMutually exclusive with sessionId."
          }
        },
        "required": [
          "input"
        ]
      },
      "ResponseOutputText": {
        "type": "object",
        "properties": {
          "annotations": {
            "default": [],
            "description": "Annotations in the text output",
            "type": "array",
            "items": {
              "type": "object"
            }
          },
          "text": {
            "type": "string",
            "description": "The text output from the model"
          },
          "type": {
            "type": "string",
            "default": "output_text",
            "description": "The type of the output text",
            "enum": [
              "output_text"
            ]
          }
        },
        "required": [
          "annotations",
          "text",
          "type"
        ]
      },
      "ResponseOutputMessage": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The unique ID of the output message"
          },
          "content": {
            "description": "Content of the output message",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResponseOutputText"
            }
          },
          "role": {
            "type": "string",
            "default": "assistant",
            "description": "The role of the output message",
            "enum": [
              "assistant"
            ]
          },
          "status": {
            "type": "string",
            "description": "The status of the message",
            "enum": [
              "in_progress",
              "completed",
              "incomplete"
            ]
          },
          "type": {
            "type": "string",
            "default": "message",
            "description": "The type of the output message",
            "enum": [
              "message"
            ]
          }
        },
        "required": [
          "id",
          "content",
          "role",
          "status",
          "type"
        ]
      },
      "ResponseObject": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for this Response"
          },
          "object": {
            "type": "string",
            "default": "response",
            "description": "The object type",
            "enum": [
              "response"
            ]
          },
          "created_at": {
            "type": "number",
            "description": "Unix timestamp (in seconds) of when this Response was created"
          },
          "status": {
            "type": "string",
            "description": "Status of the response",
            "enum": [
              "completed",
              "failed",
              "in_progress",
              "incomplete"
            ]
          },
          "error": {
            "type": "string",
            "nullable": true,
            "default": null,
            "description": "Error message if the response failed"
          },
          "output": {
            "description": "Output messages from the model",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResponseOutputMessage"
            }
          }
        },
        "required": [
          "id",
          "object",
          "created_at",
          "status",
          "output"
        ]
      },
      "ResponseTextDeltaEvent": {
        "type": "object",
        "properties": {
          "content_index": {
            "type": "number",
            "description": "Index of the content part"
          },
          "delta": {
            "type": "string",
            "description": "Text delta being added"
          },
          "item_id": {
            "type": "string",
            "description": "ID of the output item"
          },
          "output_index": {
            "type": "number",
            "description": "Index of the output item"
          },
          "type": {
            "type": "string",
            "default": "response.output_text.delta",
            "description": "Event type",
            "enum": [
              "response.output_text.delta"
            ]
          }
        },
        "required": [
          "content_index",
          "delta",
          "item_id",
          "output_index",
          "type"
        ]
      },
      "ResponseTextDoneEvent": {
        "type": "object",
        "properties": {
          "content_index": {
            "type": "number",
            "description": "Index of the content part"
          },
          "item_id": {
            "type": "string",
            "description": "ID of the output item"
          },
          "output_index": {
            "type": "number",
            "description": "Index of the output item"
          },
          "text": {
            "type": "string",
            "description": "Complete text content"
          },
          "type": {
            "type": "string",
            "default": "response.output_text.done",
            "description": "Event type",
            "enum": [
              "response.output_text.done"
            ]
          }
        },
        "required": [
          "content_index",
          "item_id",
          "output_index",
          "text",
          "type"
        ]
      },
      "ResponseCompletedEvent": {
        "type": "object",
        "properties": {
          "response": {
            "description": "The completed response",
            "allOf": [
              {
                "$ref": "#/components/schemas/ResponseObject"
              }
            ]
          },
          "type": {
            "type": "string",
            "default": "response.completed",
            "description": "Event type",
            "enum": [
              "response.completed"
            ]
          }
        },
        "required": [
          "response",
          "type"
        ]
      },
      "ResponseErrorEvent": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "default": "error",
            "description": "Event type",
            "enum": [
              "error"
            ]
          },
          "code": {
            "type": "string",
            "description": "Error code",
            "example": "ERR_SOMETHING"
          },
          "message": {
            "type": "string",
            "description": "Error message",
            "example": "Something went wrong"
          },
          "param": {
            "type": "string",
            "nullable": true,
            "description": "Parameter that caused the error"
          },
          "sequence_number": {
            "type": "number",
            "description": "Sequence number of the event",
            "example": 1
          }
        },
        "required": [
          "type",
          "code",
          "message",
          "sequence_number"
        ]
      },
      "Session": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the session."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that owns this session."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 timestamp indicating when the session was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 timestamp indicating when the session was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is a user-defined name for the session. Maximum length is 40 characters.",
            "maxLength": 40
          },
          "status": {
            "type": "string",
            "description": "This is the current status of the session. Can be either 'active' or 'completed'.",
            "enum": [
              "active",
              "completed"
            ]
          },
          "expirationSeconds": {
            "type": "number",
            "description": "Session expiration time in seconds. Defaults to 24 hours (86400 seconds) if not set.",
            "minimum": 60,
            "maximum": 2592000,
            "example": 86400
          },
          "assistantId": {
            "type": "string",
            "description": "This is the ID of the assistant associated with this session. Use this when referencing an existing assistant."
          },
          "assistant": {
            "description": "This is the assistant configuration for this session. Use this when creating a new assistant configuration.\nIf assistantId is provided, this will be ignored.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "messages": {
            "type": "array",
            "description": "This is an array of chat messages in the session.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/SystemMessage",
                  "title": "SystemMessage"
                },
                {
                  "$ref": "#/components/schemas/UserMessage",
                  "title": "UserMessage"
                },
                {
                  "$ref": "#/components/schemas/AssistantMessage",
                  "title": "AssistantMessage"
                },
                {
                  "$ref": "#/components/schemas/ToolMessage",
                  "title": "ToolMessage"
                },
                {
                  "$ref": "#/components/schemas/DeveloperMessage",
                  "title": "DeveloperMessage"
                }
              ]
            }
          },
          "customer": {
            "description": "This is the customer information associated with this session.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "phoneNumberId": {
            "type": "string",
            "description": "This is the ID of the phone number associated with this session."
          },
          "phoneNumber": {
            "description": "This is the phone number configuration for this session.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ImportTwilioPhoneNumberDTO"
              }
            ]
          }
        },
        "required": [
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "CreateSessionDTO": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "This is a user-defined name for the session. Maximum length is 40 characters.",
            "maxLength": 40
          },
          "status": {
            "type": "string",
            "description": "This is the current status of the session. Can be either 'active' or 'completed'.",
            "enum": [
              "active",
              "completed"
            ]
          },
          "expirationSeconds": {
            "type": "number",
            "description": "Session expiration time in seconds. Defaults to 24 hours (86400 seconds) if not set.",
            "minimum": 60,
            "maximum": 2592000,
            "example": 86400
          },
          "assistantId": {
            "type": "string",
            "description": "This is the ID of the assistant associated with this session. Use this when referencing an existing assistant."
          },
          "assistant": {
            "description": "This is the assistant configuration for this session. Use this when creating a new assistant configuration.\nIf assistantId is provided, this will be ignored.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "messages": {
            "type": "array",
            "description": "This is an array of chat messages in the session.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/SystemMessage",
                  "title": "SystemMessage"
                },
                {
                  "$ref": "#/components/schemas/UserMessage",
                  "title": "UserMessage"
                },
                {
                  "$ref": "#/components/schemas/AssistantMessage",
                  "title": "AssistantMessage"
                },
                {
                  "$ref": "#/components/schemas/ToolMessage",
                  "title": "ToolMessage"
                },
                {
                  "$ref": "#/components/schemas/DeveloperMessage",
                  "title": "DeveloperMessage"
                }
              ]
            }
          },
          "customer": {
            "description": "This is the customer information associated with this session.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "phoneNumberId": {
            "type": "string",
            "description": "This is the ID of the phone number associated with this session."
          },
          "phoneNumber": {
            "description": "This is the phone number configuration for this session.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ImportTwilioPhoneNumberDTO"
              }
            ]
          }
        }
      },
      "UpdateSessionDTO": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "This is the new name for the session. Maximum length is 40 characters.",
            "maxLength": 40
          },
          "status": {
            "type": "string",
            "description": "This is the new status for the session.",
            "enum": [
              "active",
              "completed"
            ]
          },
          "expirationSeconds": {
            "type": "number",
            "description": "Session expiration time in seconds. Defaults to 24 hours (86400 seconds) if not set.",
            "minimum": 60,
            "maximum": 2592000,
            "example": 86400
          },
          "messages": {
            "type": "array",
            "description": "This is the updated array of chat messages.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/SystemMessage",
                  "title": "SystemMessage"
                },
                {
                  "$ref": "#/components/schemas/UserMessage",
                  "title": "UserMessage"
                },
                {
                  "$ref": "#/components/schemas/AssistantMessage",
                  "title": "AssistantMessage"
                },
                {
                  "$ref": "#/components/schemas/ToolMessage",
                  "title": "ToolMessage"
                },
                {
                  "$ref": "#/components/schemas/DeveloperMessage",
                  "title": "DeveloperMessage"
                }
              ]
            }
          }
        }
      },
      "GetSessionPaginatedDTO": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "This is the name of the session to filter by."
          },
          "assistantId": {
            "type": "string",
            "description": "This is the ID of the assistant to filter sessions by."
          },
          "workflowId": {
            "type": "string",
            "description": "This is the ID of the workflow to filter sessions by."
          },
          "page": {
            "type": "number",
            "description": "This is the page number to return. Defaults to 1.",
            "minimum": 1
          },
          "sortOrder": {
            "type": "string",
            "description": "This is the sort order for pagination. Defaults to 'DESC'.",
            "enum": [
              "ASC",
              "DESC"
            ]
          },
          "limit": {
            "type": "number",
            "description": "This is the maximum number of items to return. Defaults to 100.",
            "minimum": 0,
            "maximum": 1000
          },
          "createdAtGt": {
            "format": "date-time",
            "type": "string",
            "description": "This will return items where the createdAt is greater than the specified value."
          },
          "createdAtLt": {
            "format": "date-time",
            "type": "string",
            "description": "This will return items where the createdAt is less than the specified value."
          },
          "createdAtGe": {
            "format": "date-time",
            "type": "string",
            "description": "This will return items where the createdAt is greater than or equal to the specified value."
          },
          "createdAtLe": {
            "format": "date-time",
            "type": "string",
            "description": "This will return items where the createdAt is less than or equal to the specified value."
          },
          "updatedAtGt": {
            "format": "date-time",
            "type": "string",
            "description": "This will return items where the updatedAt is greater than the specified value."
          },
          "updatedAtLt": {
            "format": "date-time",
            "type": "string",
            "description": "This will return items where the updatedAt is less than the specified value."
          },
          "updatedAtGe": {
            "format": "date-time",
            "type": "string",
            "description": "This will return items where the updatedAt is greater than or equal to the specified value."
          },
          "updatedAtLe": {
            "format": "date-time",
            "type": "string",
            "description": "This will return items where the updatedAt is less than or equal to the specified value."
          }
        }
      },
      "SessionPaginatedResponse": {
        "type": "object",
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Session"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/PaginationMeta"
          }
        },
        "required": [
          "results",
          "metadata"
        ]
      },
      "Assistant": {
        "type": "object",
        "properties": {
          "transcriber": {
            "description": "These are the options for the assistant's transcriber.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/AssemblyAITranscriber",
                "title": "AssemblyAITranscriber"
              },
              {
                "$ref": "#/components/schemas/AzureSpeechTranscriber",
                "title": "AzureSpeechTranscriber"
              },
              {
                "$ref": "#/components/schemas/CustomTranscriber",
                "title": "CustomTranscriber"
              },
              {
                "$ref": "#/components/schemas/DeepgramTranscriber",
                "title": "DeepgramTranscriber"
              },
              {
                "$ref": "#/components/schemas/ElevenLabsTranscriber",
                "title": "ElevenLabsTranscriber"
              },
              {
                "$ref": "#/components/schemas/GladiaTranscriber",
                "title": "GladiaTranscriber"
              },
              {
                "$ref": "#/components/schemas/GoogleTranscriber",
                "title": "GoogleTranscriber"
              },
              {
                "$ref": "#/components/schemas/SpeechmaticsTranscriber",
                "title": "SpeechmaticsTranscriber"
              },
              {
                "$ref": "#/components/schemas/TalkscriberTranscriber",
                "title": "TalkscriberTranscriber"
              },
              {
                "$ref": "#/components/schemas/OpenAITranscriber",
                "title": "OpenAITranscriber"
              }
            ]
          },
          "model": {
            "description": "These are the options for the assistant's LLM.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/AnthropicModel",
                "title": "Anthropic"
              },
              {
                "$ref": "#/components/schemas/AnyscaleModel",
                "title": "Anyscale"
              },
              {
                "$ref": "#/components/schemas/CerebrasModel",
                "title": "Cerebras"
              },
              {
                "$ref": "#/components/schemas/CustomLLMModel",
                "title": "CustomLLM"
              },
              {
                "$ref": "#/components/schemas/DeepInfraModel",
                "title": "DeepInfra"
              },
              {
                "$ref": "#/components/schemas/DeepSeekModel",
                "title": "DeepSeek"
              },
              {
                "$ref": "#/components/schemas/GoogleModel",
                "title": "Google"
              },
              {
                "$ref": "#/components/schemas/GroqModel",
                "title": "Groq"
              },
              {
                "$ref": "#/components/schemas/InflectionAIModel",
                "title": "InflectionAI"
              },
              {
                "$ref": "#/components/schemas/OpenAIModel",
                "title": "OpenAI"
              },
              {
                "$ref": "#/components/schemas/OpenRouterModel",
                "title": "OpenRouter"
              },
              {
                "$ref": "#/components/schemas/PerplexityAIModel",
                "title": "PerplexityAI"
              },
              {
                "$ref": "#/components/schemas/TogetherAIModel",
                "title": "Together"
              },
              {
                "$ref": "#/components/schemas/XaiModel",
                "title": "XAI"
              }
            ]
          },
          "voice": {
            "description": "These are the options for the assistant's voice.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/AzureVoice",
                "title": "AzureVoice"
              },
              {
                "$ref": "#/components/schemas/CartesiaVoice",
                "title": "CartesiaVoice"
              },
              {
                "$ref": "#/components/schemas/CustomVoice",
                "title": "CustomVoice"
              },
              {
                "$ref": "#/components/schemas/DeepgramVoice",
                "title": "DeepgramVoice"
              },
              {
                "$ref": "#/components/schemas/ElevenLabsVoice",
                "title": "ElevenLabsVoice"
              },
              {
                "$ref": "#/components/schemas/HumeVoice",
                "title": "HumeVoice"
              },
              {
                "$ref": "#/components/schemas/LMNTVoice",
                "title": "LMNTVoice"
              },
              {
                "$ref": "#/components/schemas/NeuphonicVoice",
                "title": "NeuphonicVoice"
              },
              {
                "$ref": "#/components/schemas/OpenAIVoice",
                "title": "OpenAIVoice"
              },
              {
                "$ref": "#/components/schemas/PlayHTVoice",
                "title": "PlayHTVoice"
              },
              {
                "$ref": "#/components/schemas/RimeAIVoice",
                "title": "RimeAIVoice"
              },
              {
                "$ref": "#/components/schemas/SmallestAIVoice",
                "title": "SmallestAIVoice"
              },
              {
                "$ref": "#/components/schemas/TavusVoice",
                "title": "TavusVoice"
              },
              {
                "$ref": "#/components/schemas/VapiVoice",
                "title": "VapiVoice"
              },
              {
                "$ref": "#/components/schemas/SesameVoice",
                "title": "SesameVoice"
              }
            ]
          },
          "firstMessage": {
            "type": "string",
            "description": "This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).\n\nIf unspecified, assistant will wait for user to speak and use the model to respond once they speak.",
            "example": "Hello! How can I help you today?"
          },
          "firstMessageInterruptionsEnabled": {
            "type": "boolean",
            "default": false
          },
          "firstMessageMode": {
            "type": "string",
            "description": "This is the mode for the first message. Default is 'assistant-speaks-first'.\n\nUse:\n- 'assistant-speaks-first' to have the assistant speak first.\n- 'assistant-waits-for-user' to have the assistant wait for the user to speak first.\n- 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).\n\n@default 'assistant-speaks-first'",
            "enum": [
              "assistant-speaks-first",
              "assistant-speaks-first-with-model-generated-message",
              "assistant-waits-for-user"
            ],
            "example": "assistant-speaks-first"
          },
          "voicemailDetection": {
            "description": "These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].\nThis uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.\nYou can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/GoogleVoicemailDetectionPlan",
                "title": "Google"
              },
              {
                "$ref": "#/components/schemas/OpenAIVoicemailDetectionPlan",
                "title": "OpenAI"
              },
              {
                "$ref": "#/components/schemas/TwilioVoicemailDetectionPlan",
                "title": "Twilio"
              },
              {
                "$ref": "#/components/schemas/VapiVoicemailDetectionPlan",
                "title": "Vapi"
              }
            ]
          },
          "clientMessages": {
            "type": "array",
            "enum": [
              "conversation-update",
              "function-call",
              "function-call-result",
              "hang",
              "language-changed",
              "metadata",
              "model-output",
              "speech-update",
              "status-update",
              "transcript",
              "tool-calls",
              "tool-calls-result",
              "tool.completed",
              "transfer-update",
              "user-interrupted",
              "voice-input",
              "workflow.node.started"
            ],
            "example": [
              "conversation-update",
              "function-call",
              "hang",
              "model-output",
              "speech-update",
              "status-update",
              "transfer-update",
              "transcript",
              "tool-calls",
              "user-interrupted",
              "voice-input",
              "workflow.node.started"
            ],
            "description": "These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transfer-update,transcript,tool-calls,user-interrupted,voice-input,workflow.node.started. You can check the shape of the messages in ClientMessage schema.",
            "items": {
              "type": "string",
              "enum": [
                "conversation-update",
                "function-call",
                "function-call-result",
                "hang",
                "language-changed",
                "metadata",
                "model-output",
                "speech-update",
                "status-update",
                "transcript",
                "tool-calls",
                "tool-calls-result",
                "tool.completed",
                "transfer-update",
                "user-interrupted",
                "voice-input",
                "workflow.node.started"
              ]
            }
          },
          "serverMessages": {
            "type": "array",
            "enum": [
              "conversation-update",
              "end-of-call-report",
              "function-call",
              "hang",
              "language-changed",
              "language-change-detected",
              "model-output",
              "phone-call-control",
              "speech-update",
              "status-update",
              "transcript",
              "transcript[transcriptType=\"final\"]",
              "tool-calls",
              "transfer-destination-request",
              "transfer-update",
              "user-interrupted",
              "voice-input"
            ],
            "example": [
              "conversation-update",
              "end-of-call-report",
              "function-call",
              "hang",
              "speech-update",
              "status-update",
              "tool-calls",
              "transfer-destination-request",
              "user-interrupted"
            ],
            "description": "These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.",
            "items": {
              "type": "string",
              "enum": [
                "conversation-update",
                "end-of-call-report",
                "function-call",
                "hang",
                "language-changed",
                "language-change-detected",
                "model-output",
                "phone-call-control",
                "speech-update",
                "status-update",
                "transcript",
                "transcript[transcriptType=\"final\"]",
                "tool-calls",
                "transfer-destination-request",
                "transfer-update",
                "user-interrupted",
                "voice-input"
              ]
            }
          },
          "silenceTimeoutSeconds": {
            "type": "number",
            "description": "How many seconds of silence to wait before ending the call. Defaults to 30.\n\n@default 30",
            "minimum": 10,
            "maximum": 3600,
            "example": 30
          },
          "maxDurationSeconds": {
            "type": "number",
            "description": "This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.\n\n@default 600 (10 minutes)",
            "minimum": 10,
            "maximum": 43200,
            "example": 600
          },
          "backgroundSound": {
            "description": "This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.\nYou can also provide a custom sound by providing a URL to an audio file.",
            "oneOf": [
              {
                "type": "enum",
                "enum": [
                  "off",
                  "office"
                ],
                "example": "office"
              },
              {
                "type": "string",
                "format": "uri",
                "example": "https://www.soundjay.com/ambient/sounds/people-in-lounge-1.mp3"
              }
            ]
          },
          "backgroundDenoisingEnabled": {
            "type": "boolean",
            "description": "This enables filtering of noise and background speech while the user is talking.\n\nDefault `false` while in beta.\n\n@default false",
            "example": false
          },
          "modelOutputInMessagesEnabled": {
            "type": "boolean",
            "description": "This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.\n\nDefault `false` while in beta.\n\n@default false",
            "example": false
          },
          "transportConfigurations": {
            "type": "array",
            "description": "These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TransportConfigurationTwilio",
                  "title": "Twilio"
                }
              ]
            }
          },
          "observabilityPlan": {
            "description": "This is the plan for observability configuration of assistant's calls.\nCurrently supports Langfuse for tracing and monitoring.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/LangfuseObservabilityPlan",
                "title": "Langfuse"
              }
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/LangfuseObservabilityPlan"
              }
            ]
          },
          "credentials": {
            "type": "array",
            "description": "These are dynamic credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can supplement an additional credentials using this. Dynamic credentials override existing credentials.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CreateAnthropicCredentialDTO",
                  "title": "AnthropicCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateAnyscaleCredentialDTO",
                  "title": "AnyscaleCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateAssemblyAICredentialDTO",
                  "title": "AssemblyAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateAzureCredentialDTO",
                  "title": "AzureCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateAzureOpenAICredentialDTO",
                  "title": "AzureOpenAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateByoSipTrunkCredentialDTO",
                  "title": "ByoSipTrunkCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateCartesiaCredentialDTO",
                  "title": "CartesiaCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateCerebrasCredentialDTO",
                  "title": "CerebrasCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateCloudflareCredentialDTO",
                  "title": "CloudflareCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateCustomLLMCredentialDTO",
                  "title": "CustomLLMCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateDeepgramCredentialDTO",
                  "title": "DeepgramCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateDeepInfraCredentialDTO",
                  "title": "DeepInfraCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateDeepSeekCredentialDTO",
                  "title": "DeepSeekCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateElevenLabsCredentialDTO",
                  "title": "ElevenLabsCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGcpCredentialDTO",
                  "title": "GcpCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGladiaCredentialDTO",
                  "title": "GladiaCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCredentialDTO",
                  "title": "GhlCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCredentialDTO",
                  "title": "GoogleCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGroqCredentialDTO",
                  "title": "GroqCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateHumeCredentialDTO",
                  "title": "HumeCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateInflectionAICredentialDTO",
                  "title": "InflectionAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateLangfuseCredentialDTO",
                  "title": "LangfuseCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateLmntCredentialDTO",
                  "title": "LmntCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateMakeCredentialDTO",
                  "title": "MakeCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateMistralCredentialDTO",
                  "title": "MistralCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateNeuphonicCredentialDTO",
                  "title": "NeuphonicCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateOpenAICredentialDTO",
                  "title": "OpenAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateOpenRouterCredentialDTO",
                  "title": "OpenRouterCredential"
                },
                {
                  "$ref": "#/components/schemas/CreatePerplexityAICredentialDTO",
                  "title": "PerplexityAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreatePlayHTCredentialDTO",
                  "title": "PlayHTCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateRimeAICredentialDTO",
                  "title": "RimeAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateRunpodCredentialDTO",
                  "title": "RunpodCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateS3CredentialDTO",
                  "title": "S3Credential"
                },
                {
                  "$ref": "#/components/schemas/CreateSmallestAICredentialDTO",
                  "title": "SmallestAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateSpeechmaticsCredentialDTO",
                  "title": "SpeechmaticsCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateSupabaseCredentialDTO",
                  "title": "SupabaseCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateTavusCredentialDTO",
                  "title": "TavusCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateTogetherAICredentialDTO",
                  "title": "TogetherAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateTrieveCredentialDTO",
                  "title": "TrieveCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateTwilioCredentialDTO",
                  "title": "TwilioCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateVonageCredentialDTO",
                  "title": "VonageCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateWebhookCredentialDTO",
                  "title": "WebhookCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateXAiCredentialDTO",
                  "title": "XAiCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarOAuth2ClientCredentialDTO",
                  "title": "GoogleCalendarOAuth2ClientCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarOAuth2AuthorizationCredentialDTO",
                  "title": "GoogleCalendarOAuth2AuthorizationCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleSheetsOAuth2AuthorizationCredentialDTO",
                  "title": "GoogleSheetsOAuth2AuthorizationCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateSlackOAuth2AuthorizationCredentialDTO",
                  "title": "SlackOAuth2AuthorizationCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelMCPCredentialDTO",
                  "title": "GoHighLevelMCPCredential"
                }
              ],
              "discriminator": {
                "propertyName": "provider",
                "mapping": {
                  "11labs": "#/components/schemas/CreateElevenLabsCredentialDTO",
                  "anthropic": "#/components/schemas/CreateAnthropicCredentialDTO",
                  "anyscale": "#/components/schemas/CreateAnyscaleCredentialDTO",
                  "assembly-ai": "#/components/schemas/CreateAssemblyAICredentialDTO",
                  "azure-openai": "#/components/schemas/CreateAzureOpenAICredentialDTO",
                  "azure": "#/components/schemas/CreateAzureCredentialDTO",
                  "byo-sip-trunk": "#/components/schemas/CreateByoSipTrunkCredentialDTO",
                  "cartesia": "#/components/schemas/CreateCartesiaCredentialDTO",
                  "cerebras": "#/components/schemas/CreateCerebrasCredentialDTO",
                  "cloudflare": "#/components/schemas/CreateCloudflareCredentialDTO",
                  "custom-llm": "#/components/schemas/CreateCustomLLMCredentialDTO",
                  "deepgram": "#/components/schemas/CreateDeepgramCredentialDTO",
                  "deepinfra": "#/components/schemas/CreateDeepInfraCredentialDTO",
                  "deep-seek": "#/components/schemas/CreateDeepSeekCredentialDTO",
                  "gcp": "#/components/schemas/CreateGcpCredentialDTO",
                  "gladia": "#/components/schemas/CreateGladiaCredentialDTO",
                  "gohighlevel": "#/components/schemas/CreateGoHighLevelCredentialDTO",
                  "google": "#/components/schemas/CreateGoogleCredentialDTO",
                  "groq": "#/components/schemas/CreateGroqCredentialDTO",
                  "inflection-ai": "#/components/schemas/CreateInflectionAICredentialDTO",
                  "langfuse": "#/components/schemas/CreateLangfuseCredentialDTO",
                  "lmnt": "#/components/schemas/CreateLmntCredentialDTO",
                  "make": "#/components/schemas/CreateMakeCredentialDTO",
                  "openai": "#/components/schemas/CreateOpenAICredentialDTO",
                  "openrouter": "#/components/schemas/CreateOpenRouterCredentialDTO",
                  "perplexity-ai": "#/components/schemas/CreatePerplexityAICredentialDTO",
                  "playht": "#/components/schemas/CreatePlayHTCredentialDTO",
                  "rime-ai": "#/components/schemas/CreateRimeAICredentialDTO",
                  "runpod": "#/components/schemas/CreateRunpodCredentialDTO",
                  "s3": "#/components/schemas/CreateS3CredentialDTO",
                  "supabase": "#/components/schemas/CreateSupabaseCredentialDTO",
                  "smallest-ai": "#/components/schemas/CreateSmallestAICredentialDTO",
                  "tavus": "#/components/schemas/CreateTavusCredentialDTO",
                  "together-ai": "#/components/schemas/CreateTogetherAICredentialDTO",
                  "twilio": "#/components/schemas/CreateTwilioCredentialDTO",
                  "vonage": "#/components/schemas/CreateVonageCredentialDTO",
                  "webhook": "#/components/schemas/CreateWebhookCredentialDTO",
                  "xai": "#/components/schemas/CreateXAiCredentialDTO",
                  "neuphonic": "#/components/schemas/CreateNeuphonicCredentialDTO",
                  "hume": "#/components/schemas/CreateHumeCredentialDTO",
                  "mistral": "#/components/schemas/CreateMistralCredentialDTO",
                  "speechmatics": "#/components/schemas/CreateSpeechmaticsCredentialDTO",
                  "trieve": "#/components/schemas/CreateTrieveCredentialDTO",
                  "google.calendar.oauth2-client": "#/components/schemas/CreateGoogleCalendarOAuth2ClientCredentialDTO",
                  "google.calendar.oauth2-authorization": "#/components/schemas/CreateGoogleCalendarOAuth2AuthorizationCredentialDTO",
                  "google.sheets.oauth2-authorization": "#/components/schemas/CreateGoogleSheetsOAuth2AuthorizationCredentialDTO",
                  "slack.oauth2-authorization": "#/components/schemas/CreateSlackOAuth2AuthorizationCredentialDTO",
                  "ghl.oauth2-authorization": "#/components/schemas/CreateGoHighLevelMCPCredentialDTO"
                }
              }
            }
          },
          "hooks": {
            "type": "array",
            "description": "This is a set of actions that will be performed on certain events.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/AssistantHookCallEnding",
                  "title": "AssistantHookCallEnding"
                },
                {
                  "$ref": "#/components/schemas/AssistantHookAssistantSpeechInterrupted",
                  "title": "AssistantHookAssistantSpeechInterrupted"
                },
                {
                  "$ref": "#/components/schemas/AssistantHookCustomerSpeechInterrupted",
                  "title": "AssistantHookCustomerSpeechInterrupted"
                }
              ]
            }
          },
          "name": {
            "type": "string",
            "description": "This is the name of the assistant.\n\nThis is required when you want to transfer between assistants in a call.",
            "maxLength": 40
          },
          "voicemailMessage": {
            "type": "string",
            "description": "This is the message that the assistant will say if the call is forwarded to voicemail.\n\nIf unspecified, it will hang up.",
            "maxLength": 1000
          },
          "endCallMessage": {
            "type": "string",
            "description": "This is the message that the assistant will say if it ends the call.\n\nIf unspecified, it will hang up without saying anything.",
            "maxLength": 1000
          },
          "endCallPhrases": {
            "description": "This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.",
            "type": "array",
            "items": {
              "type": "string",
              "maxLength": 140,
              "minLength": 2
            }
          },
          "compliancePlan": {
            "$ref": "#/components/schemas/CompliancePlan"
          },
          "metadata": {
            "type": "object",
            "description": "This is for metadata you want to store on the assistant."
          },
          "analysisPlan": {
            "description": "This is the plan for analysis of assistant's calls. Stored in `call.analysis`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnalysisPlan"
              }
            ]
          },
          "artifactPlan": {
            "description": "This is the plan for artifacts generated during assistant's calls. Stored in `call.artifact`.\n\nNote: `recordingEnabled` is currently at the root level. It will be moved to `artifactPlan` in the future, but will remain backwards compatible.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ArtifactPlan"
              }
            ]
          },
          "messagePlan": {
            "description": "This is the plan for static predefined messages that can be spoken by the assistant during the call, like `idleMessages`.\n\nNote: `firstMessage`, `voicemailMessage`, and `endCallMessage` are currently at the root level. They will be moved to `messagePlan` in the future, but will remain backwards compatible.",
            "allOf": [
              {
                "$ref": "#/components/schemas/MessagePlan"
              }
            ]
          },
          "startSpeakingPlan": {
            "description": "This is the plan for when the assistant should start talking.\n\nYou should configure this if you're running into these issues:\n- The assistant is too slow to start talking after the customer is done speaking.\n- The assistant is too fast to start talking after the customer is done speaking.\n- The assistant is so fast that it's actually interrupting the customer.",
            "allOf": [
              {
                "$ref": "#/components/schemas/StartSpeakingPlan"
              }
            ]
          },
          "stopSpeakingPlan": {
            "description": "This is the plan for when assistant should stop talking on customer interruption.\n\nYou should configure this if you're running into these issues:\n- The assistant is too slow to recognize customer's interruption.\n- The assistant is too fast to recognize customer's interruption.\n- The assistant is getting interrupted by phrases that are just acknowledgments.\n- The assistant is getting interrupted by background noises.\n- The assistant is not properly stopping -- it starts talking right after getting interrupted.",
            "allOf": [
              {
                "$ref": "#/components/schemas/StopSpeakingPlan"
              }
            ]
          },
          "monitorPlan": {
            "description": "This is the plan for real-time monitoring of the assistant's calls.\n\nUsage:\n- To enable live listening of the assistant's calls, set `monitorPlan.listenEnabled` to `true`.\n- To enable live control of the assistant's calls, set `monitorPlan.controlEnabled` to `true`.\n\nNote, `serverMessages`, `clientMessages`, `serverUrl` and `serverUrlSecret` are currently at the root level but will be moved to `monitorPlan` in the future. Will remain backwards compatible",
            "allOf": [
              {
                "$ref": "#/components/schemas/MonitorPlan"
              }
            ]
          },
          "credentialIds": {
            "description": "These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server.url\n2. phoneNumber.serverUrl\n3. org.serverUrl",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "keypadInputPlan": {
            "$ref": "#/components/schemas/KeypadInputPlan"
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the assistant."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this assistant belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          }
        },
        "required": [
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "AssistantPaginatedResponse": {
        "type": "object",
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Assistant"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/PaginationMeta"
          }
        },
        "required": [
          "results",
          "metadata"
        ]
      },
      "AssistantVersionPaginatedResponse": {
        "type": "object",
        "properties": {
          "results": {
            "type": "array"
          },
          "metadata": {
            "$ref": "#/components/schemas/PaginationMeta"
          },
          "nextPageState": {
            "type": "string"
          }
        },
        "required": [
          "results",
          "metadata"
        ]
      },
      "UpdateAssistantDTO": {
        "type": "object",
        "properties": {
          "transcriber": {
            "description": "These are the options for the assistant's transcriber.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/AssemblyAITranscriber",
                "title": "AssemblyAITranscriber"
              },
              {
                "$ref": "#/components/schemas/AzureSpeechTranscriber",
                "title": "AzureSpeechTranscriber"
              },
              {
                "$ref": "#/components/schemas/CustomTranscriber",
                "title": "CustomTranscriber"
              },
              {
                "$ref": "#/components/schemas/DeepgramTranscriber",
                "title": "DeepgramTranscriber"
              },
              {
                "$ref": "#/components/schemas/ElevenLabsTranscriber",
                "title": "ElevenLabsTranscriber"
              },
              {
                "$ref": "#/components/schemas/GladiaTranscriber",
                "title": "GladiaTranscriber"
              },
              {
                "$ref": "#/components/schemas/GoogleTranscriber",
                "title": "GoogleTranscriber"
              },
              {
                "$ref": "#/components/schemas/SpeechmaticsTranscriber",
                "title": "SpeechmaticsTranscriber"
              },
              {
                "$ref": "#/components/schemas/TalkscriberTranscriber",
                "title": "TalkscriberTranscriber"
              },
              {
                "$ref": "#/components/schemas/OpenAITranscriber",
                "title": "OpenAITranscriber"
              }
            ]
          },
          "model": {
            "description": "These are the options for the assistant's LLM.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/AnthropicModel",
                "title": "Anthropic"
              },
              {
                "$ref": "#/components/schemas/AnyscaleModel",
                "title": "Anyscale"
              },
              {
                "$ref": "#/components/schemas/CerebrasModel",
                "title": "Cerebras"
              },
              {
                "$ref": "#/components/schemas/CustomLLMModel",
                "title": "CustomLLM"
              },
              {
                "$ref": "#/components/schemas/DeepInfraModel",
                "title": "DeepInfra"
              },
              {
                "$ref": "#/components/schemas/DeepSeekModel",
                "title": "DeepSeek"
              },
              {
                "$ref": "#/components/schemas/GoogleModel",
                "title": "Google"
              },
              {
                "$ref": "#/components/schemas/GroqModel",
                "title": "Groq"
              },
              {
                "$ref": "#/components/schemas/InflectionAIModel",
                "title": "InflectionAI"
              },
              {
                "$ref": "#/components/schemas/OpenAIModel",
                "title": "OpenAI"
              },
              {
                "$ref": "#/components/schemas/OpenRouterModel",
                "title": "OpenRouter"
              },
              {
                "$ref": "#/components/schemas/PerplexityAIModel",
                "title": "PerplexityAI"
              },
              {
                "$ref": "#/components/schemas/TogetherAIModel",
                "title": "Together"
              },
              {
                "$ref": "#/components/schemas/XaiModel",
                "title": "XAI"
              }
            ]
          },
          "voice": {
            "description": "These are the options for the assistant's voice.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/AzureVoice",
                "title": "AzureVoice"
              },
              {
                "$ref": "#/components/schemas/CartesiaVoice",
                "title": "CartesiaVoice"
              },
              {
                "$ref": "#/components/schemas/CustomVoice",
                "title": "CustomVoice"
              },
              {
                "$ref": "#/components/schemas/DeepgramVoice",
                "title": "DeepgramVoice"
              },
              {
                "$ref": "#/components/schemas/ElevenLabsVoice",
                "title": "ElevenLabsVoice"
              },
              {
                "$ref": "#/components/schemas/HumeVoice",
                "title": "HumeVoice"
              },
              {
                "$ref": "#/components/schemas/LMNTVoice",
                "title": "LMNTVoice"
              },
              {
                "$ref": "#/components/schemas/NeuphonicVoice",
                "title": "NeuphonicVoice"
              },
              {
                "$ref": "#/components/schemas/OpenAIVoice",
                "title": "OpenAIVoice"
              },
              {
                "$ref": "#/components/schemas/PlayHTVoice",
                "title": "PlayHTVoice"
              },
              {
                "$ref": "#/components/schemas/RimeAIVoice",
                "title": "RimeAIVoice"
              },
              {
                "$ref": "#/components/schemas/SmallestAIVoice",
                "title": "SmallestAIVoice"
              },
              {
                "$ref": "#/components/schemas/TavusVoice",
                "title": "TavusVoice"
              },
              {
                "$ref": "#/components/schemas/VapiVoice",
                "title": "VapiVoice"
              },
              {
                "$ref": "#/components/schemas/SesameVoice",
                "title": "SesameVoice"
              }
            ]
          },
          "firstMessage": {
            "type": "string",
            "description": "This is the first message that the assistant will say. This can also be a URL to a containerized audio file (mp3, wav, etc.).\n\nIf unspecified, assistant will wait for user to speak and use the model to respond once they speak.",
            "example": "Hello! How can I help you today?"
          },
          "firstMessageInterruptionsEnabled": {
            "type": "boolean",
            "default": false
          },
          "firstMessageMode": {
            "type": "string",
            "description": "This is the mode for the first message. Default is 'assistant-speaks-first'.\n\nUse:\n- 'assistant-speaks-first' to have the assistant speak first.\n- 'assistant-waits-for-user' to have the assistant wait for the user to speak first.\n- 'assistant-speaks-first-with-model-generated-message' to have the assistant speak first with a message generated by the model based on the conversation state. (`assistant.model.messages` at call start, `call.messages` at squad transfer points).\n\n@default 'assistant-speaks-first'",
            "enum": [
              "assistant-speaks-first",
              "assistant-speaks-first-with-model-generated-message",
              "assistant-waits-for-user"
            ],
            "example": "assistant-speaks-first"
          },
          "voicemailDetection": {
            "description": "These are the settings to configure or disable voicemail detection. Alternatively, voicemail detection can be configured using the model.tools=[VoicemailTool].\nThis uses Twilio's built-in detection while the VoicemailTool relies on the model to detect if a voicemail was reached.\nYou can use neither of them, one of them, or both of them. By default, Twilio built-in detection is enabled while VoicemailTool is not.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/GoogleVoicemailDetectionPlan",
                "title": "Google"
              },
              {
                "$ref": "#/components/schemas/OpenAIVoicemailDetectionPlan",
                "title": "OpenAI"
              },
              {
                "$ref": "#/components/schemas/TwilioVoicemailDetectionPlan",
                "title": "Twilio"
              },
              {
                "$ref": "#/components/schemas/VapiVoicemailDetectionPlan",
                "title": "Vapi"
              }
            ]
          },
          "clientMessages": {
            "type": "array",
            "enum": [
              "conversation-update",
              "function-call",
              "function-call-result",
              "hang",
              "language-changed",
              "metadata",
              "model-output",
              "speech-update",
              "status-update",
              "transcript",
              "tool-calls",
              "tool-calls-result",
              "tool.completed",
              "transfer-update",
              "user-interrupted",
              "voice-input",
              "workflow.node.started"
            ],
            "example": [
              "conversation-update",
              "function-call",
              "hang",
              "model-output",
              "speech-update",
              "status-update",
              "transfer-update",
              "transcript",
              "tool-calls",
              "user-interrupted",
              "voice-input",
              "workflow.node.started"
            ],
            "description": "These are the messages that will be sent to your Client SDKs. Default is conversation-update,function-call,hang,model-output,speech-update,status-update,transfer-update,transcript,tool-calls,user-interrupted,voice-input,workflow.node.started. You can check the shape of the messages in ClientMessage schema.",
            "items": {
              "type": "string",
              "enum": [
                "conversation-update",
                "function-call",
                "function-call-result",
                "hang",
                "language-changed",
                "metadata",
                "model-output",
                "speech-update",
                "status-update",
                "transcript",
                "tool-calls",
                "tool-calls-result",
                "tool.completed",
                "transfer-update",
                "user-interrupted",
                "voice-input",
                "workflow.node.started"
              ]
            }
          },
          "serverMessages": {
            "type": "array",
            "enum": [
              "conversation-update",
              "end-of-call-report",
              "function-call",
              "hang",
              "language-changed",
              "language-change-detected",
              "model-output",
              "phone-call-control",
              "speech-update",
              "status-update",
              "transcript",
              "transcript[transcriptType=\"final\"]",
              "tool-calls",
              "transfer-destination-request",
              "transfer-update",
              "user-interrupted",
              "voice-input"
            ],
            "example": [
              "conversation-update",
              "end-of-call-report",
              "function-call",
              "hang",
              "speech-update",
              "status-update",
              "tool-calls",
              "transfer-destination-request",
              "user-interrupted"
            ],
            "description": "These are the messages that will be sent to your Server URL. Default is conversation-update,end-of-call-report,function-call,hang,speech-update,status-update,tool-calls,transfer-destination-request,user-interrupted. You can check the shape of the messages in ServerMessage schema.",
            "items": {
              "type": "string",
              "enum": [
                "conversation-update",
                "end-of-call-report",
                "function-call",
                "hang",
                "language-changed",
                "language-change-detected",
                "model-output",
                "phone-call-control",
                "speech-update",
                "status-update",
                "transcript",
                "transcript[transcriptType=\"final\"]",
                "tool-calls",
                "transfer-destination-request",
                "transfer-update",
                "user-interrupted",
                "voice-input"
              ]
            }
          },
          "silenceTimeoutSeconds": {
            "type": "number",
            "description": "How many seconds of silence to wait before ending the call. Defaults to 30.\n\n@default 30",
            "minimum": 10,
            "maximum": 3600,
            "example": 30
          },
          "maxDurationSeconds": {
            "type": "number",
            "description": "This is the maximum number of seconds that the call will last. When the call reaches this duration, it will be ended.\n\n@default 600 (10 minutes)",
            "minimum": 10,
            "maximum": 43200,
            "example": 600
          },
          "backgroundSound": {
            "description": "This is the background sound in the call. Default for phone calls is 'office' and default for web calls is 'off'.\nYou can also provide a custom sound by providing a URL to an audio file.",
            "oneOf": [
              {
                "type": "enum",
                "enum": [
                  "off",
                  "office"
                ],
                "example": "office"
              },
              {
                "type": "string",
                "format": "uri",
                "example": "https://www.soundjay.com/ambient/sounds/people-in-lounge-1.mp3"
              }
            ]
          },
          "backgroundDenoisingEnabled": {
            "type": "boolean",
            "description": "This enables filtering of noise and background speech while the user is talking.\n\nDefault `false` while in beta.\n\n@default false",
            "example": false
          },
          "modelOutputInMessagesEnabled": {
            "type": "boolean",
            "description": "This determines whether the model's output is used in conversation history rather than the transcription of assistant's speech.\n\nDefault `false` while in beta.\n\n@default false",
            "example": false
          },
          "transportConfigurations": {
            "type": "array",
            "description": "These are the configurations to be passed to the transport providers of assistant's calls, like Twilio. You can store multiple configurations for different transport providers. For a call, only the configuration matching the call transport provider is used.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TransportConfigurationTwilio",
                  "title": "Twilio"
                }
              ]
            }
          },
          "observabilityPlan": {
            "description": "This is the plan for observability configuration of assistant's calls.\nCurrently supports Langfuse for tracing and monitoring.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/LangfuseObservabilityPlan",
                "title": "Langfuse"
              }
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/LangfuseObservabilityPlan"
              }
            ]
          },
          "credentials": {
            "type": "array",
            "description": "These are dynamic credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can supplement an additional credentials using this. Dynamic credentials override existing credentials.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CreateAnthropicCredentialDTO",
                  "title": "AnthropicCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateAnyscaleCredentialDTO",
                  "title": "AnyscaleCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateAssemblyAICredentialDTO",
                  "title": "AssemblyAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateAzureCredentialDTO",
                  "title": "AzureCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateAzureOpenAICredentialDTO",
                  "title": "AzureOpenAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateByoSipTrunkCredentialDTO",
                  "title": "ByoSipTrunkCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateCartesiaCredentialDTO",
                  "title": "CartesiaCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateCerebrasCredentialDTO",
                  "title": "CerebrasCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateCloudflareCredentialDTO",
                  "title": "CloudflareCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateCustomLLMCredentialDTO",
                  "title": "CustomLLMCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateDeepgramCredentialDTO",
                  "title": "DeepgramCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateDeepInfraCredentialDTO",
                  "title": "DeepInfraCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateDeepSeekCredentialDTO",
                  "title": "DeepSeekCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateElevenLabsCredentialDTO",
                  "title": "ElevenLabsCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGcpCredentialDTO",
                  "title": "GcpCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGladiaCredentialDTO",
                  "title": "GladiaCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelCredentialDTO",
                  "title": "GhlCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCredentialDTO",
                  "title": "GoogleCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGroqCredentialDTO",
                  "title": "GroqCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateHumeCredentialDTO",
                  "title": "HumeCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateInflectionAICredentialDTO",
                  "title": "InflectionAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateLangfuseCredentialDTO",
                  "title": "LangfuseCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateLmntCredentialDTO",
                  "title": "LmntCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateMakeCredentialDTO",
                  "title": "MakeCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateMistralCredentialDTO",
                  "title": "MistralCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateNeuphonicCredentialDTO",
                  "title": "NeuphonicCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateOpenAICredentialDTO",
                  "title": "OpenAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateOpenRouterCredentialDTO",
                  "title": "OpenRouterCredential"
                },
                {
                  "$ref": "#/components/schemas/CreatePerplexityAICredentialDTO",
                  "title": "PerplexityAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreatePlayHTCredentialDTO",
                  "title": "PlayHTCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateRimeAICredentialDTO",
                  "title": "RimeAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateRunpodCredentialDTO",
                  "title": "RunpodCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateS3CredentialDTO",
                  "title": "S3Credential"
                },
                {
                  "$ref": "#/components/schemas/CreateSmallestAICredentialDTO",
                  "title": "SmallestAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateSpeechmaticsCredentialDTO",
                  "title": "SpeechmaticsCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateSupabaseCredentialDTO",
                  "title": "SupabaseCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateTavusCredentialDTO",
                  "title": "TavusCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateTogetherAICredentialDTO",
                  "title": "TogetherAICredential"
                },
                {
                  "$ref": "#/components/schemas/CreateTrieveCredentialDTO",
                  "title": "TrieveCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateTwilioCredentialDTO",
                  "title": "TwilioCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateVonageCredentialDTO",
                  "title": "VonageCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateWebhookCredentialDTO",
                  "title": "WebhookCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateXAiCredentialDTO",
                  "title": "XAiCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarOAuth2ClientCredentialDTO",
                  "title": "GoogleCalendarOAuth2ClientCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleCalendarOAuth2AuthorizationCredentialDTO",
                  "title": "GoogleCalendarOAuth2AuthorizationCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoogleSheetsOAuth2AuthorizationCredentialDTO",
                  "title": "GoogleSheetsOAuth2AuthorizationCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateSlackOAuth2AuthorizationCredentialDTO",
                  "title": "SlackOAuth2AuthorizationCredential"
                },
                {
                  "$ref": "#/components/schemas/CreateGoHighLevelMCPCredentialDTO",
                  "title": "GoHighLevelMCPCredential"
                }
              ],
              "discriminator": {
                "propertyName": "provider",
                "mapping": {
                  "11labs": "#/components/schemas/CreateElevenLabsCredentialDTO",
                  "anthropic": "#/components/schemas/CreateAnthropicCredentialDTO",
                  "anyscale": "#/components/schemas/CreateAnyscaleCredentialDTO",
                  "assembly-ai": "#/components/schemas/CreateAssemblyAICredentialDTO",
                  "azure-openai": "#/components/schemas/CreateAzureOpenAICredentialDTO",
                  "azure": "#/components/schemas/CreateAzureCredentialDTO",
                  "byo-sip-trunk": "#/components/schemas/CreateByoSipTrunkCredentialDTO",
                  "cartesia": "#/components/schemas/CreateCartesiaCredentialDTO",
                  "cerebras": "#/components/schemas/CreateCerebrasCredentialDTO",
                  "cloudflare": "#/components/schemas/CreateCloudflareCredentialDTO",
                  "custom-llm": "#/components/schemas/CreateCustomLLMCredentialDTO",
                  "deepgram": "#/components/schemas/CreateDeepgramCredentialDTO",
                  "deepinfra": "#/components/schemas/CreateDeepInfraCredentialDTO",
                  "deep-seek": "#/components/schemas/CreateDeepSeekCredentialDTO",
                  "gcp": "#/components/schemas/CreateGcpCredentialDTO",
                  "gladia": "#/components/schemas/CreateGladiaCredentialDTO",
                  "gohighlevel": "#/components/schemas/CreateGoHighLevelCredentialDTO",
                  "google": "#/components/schemas/CreateGoogleCredentialDTO",
                  "groq": "#/components/schemas/CreateGroqCredentialDTO",
                  "inflection-ai": "#/components/schemas/CreateInflectionAICredentialDTO",
                  "langfuse": "#/components/schemas/CreateLangfuseCredentialDTO",
                  "lmnt": "#/components/schemas/CreateLmntCredentialDTO",
                  "make": "#/components/schemas/CreateMakeCredentialDTO",
                  "openai": "#/components/schemas/CreateOpenAICredentialDTO",
                  "openrouter": "#/components/schemas/CreateOpenRouterCredentialDTO",
                  "perplexity-ai": "#/components/schemas/CreatePerplexityAICredentialDTO",
                  "playht": "#/components/schemas/CreatePlayHTCredentialDTO",
                  "rime-ai": "#/components/schemas/CreateRimeAICredentialDTO",
                  "runpod": "#/components/schemas/CreateRunpodCredentialDTO",
                  "s3": "#/components/schemas/CreateS3CredentialDTO",
                  "supabase": "#/components/schemas/CreateSupabaseCredentialDTO",
                  "smallest-ai": "#/components/schemas/CreateSmallestAICredentialDTO",
                  "tavus": "#/components/schemas/CreateTavusCredentialDTO",
                  "together-ai": "#/components/schemas/CreateTogetherAICredentialDTO",
                  "twilio": "#/components/schemas/CreateTwilioCredentialDTO",
                  "vonage": "#/components/schemas/CreateVonageCredentialDTO",
                  "webhook": "#/components/schemas/CreateWebhookCredentialDTO",
                  "xai": "#/components/schemas/CreateXAiCredentialDTO",
                  "neuphonic": "#/components/schemas/CreateNeuphonicCredentialDTO",
                  "hume": "#/components/schemas/CreateHumeCredentialDTO",
                  "mistral": "#/components/schemas/CreateMistralCredentialDTO",
                  "speechmatics": "#/components/schemas/CreateSpeechmaticsCredentialDTO",
                  "trieve": "#/components/schemas/CreateTrieveCredentialDTO",
                  "google.calendar.oauth2-client": "#/components/schemas/CreateGoogleCalendarOAuth2ClientCredentialDTO",
                  "google.calendar.oauth2-authorization": "#/components/schemas/CreateGoogleCalendarOAuth2AuthorizationCredentialDTO",
                  "google.sheets.oauth2-authorization": "#/components/schemas/CreateGoogleSheetsOAuth2AuthorizationCredentialDTO",
                  "slack.oauth2-authorization": "#/components/schemas/CreateSlackOAuth2AuthorizationCredentialDTO",
                  "ghl.oauth2-authorization": "#/components/schemas/CreateGoHighLevelMCPCredentialDTO"
                }
              }
            }
          },
          "hooks": {
            "type": "array",
            "description": "This is a set of actions that will be performed on certain events.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/AssistantHookCallEnding",
                  "title": "AssistantHookCallEnding"
                },
                {
                  "$ref": "#/components/schemas/AssistantHookAssistantSpeechInterrupted",
                  "title": "AssistantHookAssistantSpeechInterrupted"
                },
                {
                  "$ref": "#/components/schemas/AssistantHookCustomerSpeechInterrupted",
                  "title": "AssistantHookCustomerSpeechInterrupted"
                }
              ]
            }
          },
          "name": {
            "type": "string",
            "description": "This is the name of the assistant.\n\nThis is required when you want to transfer between assistants in a call.",
            "maxLength": 40
          },
          "voicemailMessage": {
            "type": "string",
            "description": "This is the message that the assistant will say if the call is forwarded to voicemail.\n\nIf unspecified, it will hang up.",
            "maxLength": 1000
          },
          "endCallMessage": {
            "type": "string",
            "description": "This is the message that the assistant will say if it ends the call.\n\nIf unspecified, it will hang up without saying anything.",
            "maxLength": 1000
          },
          "endCallPhrases": {
            "description": "This list contains phrases that, if spoken by the assistant, will trigger the call to be hung up. Case insensitive.",
            "type": "array",
            "items": {
              "type": "string",
              "maxLength": 140,
              "minLength": 2
            }
          },
          "compliancePlan": {
            "$ref": "#/components/schemas/CompliancePlan"
          },
          "metadata": {
            "type": "object",
            "description": "This is for metadata you want to store on the assistant."
          },
          "analysisPlan": {
            "description": "This is the plan for analysis of assistant's calls. Stored in `call.analysis`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnalysisPlan"
              }
            ]
          },
          "artifactPlan": {
            "description": "This is the plan for artifacts generated during assistant's calls. Stored in `call.artifact`.\n\nNote: `recordingEnabled` is currently at the root level. It will be moved to `artifactPlan` in the future, but will remain backwards compatible.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ArtifactPlan"
              }
            ]
          },
          "messagePlan": {
            "description": "This is the plan for static predefined messages that can be spoken by the assistant during the call, like `idleMessages`.\n\nNote: `firstMessage`, `voicemailMessage`, and `endCallMessage` are currently at the root level. They will be moved to `messagePlan` in the future, but will remain backwards compatible.",
            "allOf": [
              {
                "$ref": "#/components/schemas/MessagePlan"
              }
            ]
          },
          "startSpeakingPlan": {
            "description": "This is the plan for when the assistant should start talking.\n\nYou should configure this if you're running into these issues:\n- The assistant is too slow to start talking after the customer is done speaking.\n- The assistant is too fast to start talking after the customer is done speaking.\n- The assistant is so fast that it's actually interrupting the customer.",
            "allOf": [
              {
                "$ref": "#/components/schemas/StartSpeakingPlan"
              }
            ]
          },
          "stopSpeakingPlan": {
            "description": "This is the plan for when assistant should stop talking on customer interruption.\n\nYou should configure this if you're running into these issues:\n- The assistant is too slow to recognize customer's interruption.\n- The assistant is too fast to recognize customer's interruption.\n- The assistant is getting interrupted by phrases that are just acknowledgments.\n- The assistant is getting interrupted by background noises.\n- The assistant is not properly stopping -- it starts talking right after getting interrupted.",
            "allOf": [
              {
                "$ref": "#/components/schemas/StopSpeakingPlan"
              }
            ]
          },
          "monitorPlan": {
            "description": "This is the plan for real-time monitoring of the assistant's calls.\n\nUsage:\n- To enable live listening of the assistant's calls, set `monitorPlan.listenEnabled` to `true`.\n- To enable live control of the assistant's calls, set `monitorPlan.controlEnabled` to `true`.\n\nNote, `serverMessages`, `clientMessages`, `serverUrl` and `serverUrlSecret` are currently at the root level but will be moved to `monitorPlan` in the future. Will remain backwards compatible",
            "allOf": [
              {
                "$ref": "#/components/schemas/MonitorPlan"
              }
            ]
          },
          "credentialIds": {
            "description": "These are the credentials that will be used for the assistant calls. By default, all the credentials are available for use in the call but you can provide a subset using this.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server.url\n2. phoneNumber.serverUrl\n3. org.serverUrl",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "keypadInputPlan": {
            "$ref": "#/components/schemas/KeypadInputPlan"
          }
        }
      },
      "ByoPhoneNumber": {
        "type": "object",
        "properties": {
          "fallbackDestination": {
            "description": "This is the fallback destination an inbound call will be transferred to if:\n1. `assistantId` is not set\n2. `squadId` is not set\n3. and, `assistant-request` message to the `serverUrl` fails\n\nIf this is not set and above conditions are met, the inbound call is hung up with an error message.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "hooks": {
            "type": "array",
            "description": "This is the hooks that will be used for incoming calls to this phone number.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/PhoneNumberHookCallRinging",
                  "title": "PhoneNumberHookCallRinging"
                }
              ]
            }
          },
          "provider": {
            "type": "string",
            "description": "This is to bring your own phone numbers from your own SIP trunks or Carriers.",
            "enum": [
              "byo-phone-number"
            ]
          },
          "numberE164CheckEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle the E164 check for the `number` field. This is an advanced property which should be used if you know your use case requires it.\n\nUse cases:\n- `false`: To allow non-E164 numbers like `+001234567890`, `1234`, or `abc`. This is useful for dialing out to non-E164 numbers on your SIP trunks.\n- `true` (default): To allow only E164 numbers like `+14155551234`. This is standard for PSTN calls.\n\nIf `false`, the `number` is still required to only contain alphanumeric characters (regex: `/^\\+?[a-zA-Z0-9]+$/`).\n\n@default true (E164 check is enabled)",
            "default": true
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the phone number."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this phone number belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the phone number was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the phone number was last updated."
          },
          "status": {
            "type": "string",
            "description": "This is the status of the phone number.",
            "enum": [
              "active",
              "activating",
              "blocked"
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of the phone number. This is just for your own reference.",
            "maxLength": 40
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId` nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "workflowId": {
            "type": "string",
            "description": "This is the workflow that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server\n2. phoneNumber.server\n3. org.server",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "number": {
            "type": "string",
            "description": "This is the number of the customer.",
            "minLength": 3,
            "maxLength": 40
          },
          "credentialId": {
            "type": "string",
            "description": "This is the credential of your own SIP trunk or Carrier (type `byo-sip-trunk`) which can be used to make calls to this phone number.\n\nYou can add the SIP trunk or Carrier credential in the Provider Credentials page on the Dashboard to get the credentialId."
          }
        },
        "required": [
          "provider",
          "id",
          "orgId",
          "createdAt",
          "updatedAt",
          "credentialId"
        ]
      },
      "TwilioPhoneNumber": {
        "type": "object",
        "properties": {
          "fallbackDestination": {
            "description": "This is the fallback destination an inbound call will be transferred to if:\n1. `assistantId` is not set\n2. `squadId` is not set\n3. and, `assistant-request` message to the `serverUrl` fails\n\nIf this is not set and above conditions are met, the inbound call is hung up with an error message.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "hooks": {
            "type": "array",
            "description": "This is the hooks that will be used for incoming calls to this phone number.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/PhoneNumberHookCallRinging",
                  "title": "PhoneNumberHookCallRinging"
                }
              ]
            }
          },
          "provider": {
            "type": "string",
            "description": "This is to use numbers bought on Twilio.",
            "enum": [
              "twilio"
            ]
          },
          "smsEnabled": {
            "type": "boolean",
            "description": "Controls whether Vapi sets the messaging webhook URL on the Twilio number during import.\n\nIf set to `false`, Vapi will not update the Twilio messaging URL, leaving it as is.\nIf `true` or omitted (default), Vapi will configure both the voice and messaging URLs.\n\n@default true",
            "default": true
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the phone number."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this phone number belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the phone number was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the phone number was last updated."
          },
          "status": {
            "type": "string",
            "description": "This is the status of the phone number.",
            "enum": [
              "active",
              "activating",
              "blocked"
            ]
          },
          "twilioAuthToken": {
            "type": "string",
            "description": "This is the Twilio Auth Token for the phone number."
          },
          "twilioApiKey": {
            "type": "string",
            "description": "This is the Twilio API Key for the phone number."
          },
          "twilioApiSecret": {
            "type": "string",
            "description": "This is the Twilio API Secret for the phone number."
          },
          "name": {
            "type": "string",
            "description": "This is the name of the phone number. This is just for your own reference.",
            "maxLength": 40
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId` nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "workflowId": {
            "type": "string",
            "description": "This is the workflow that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server\n2. phoneNumber.server\n3. org.server",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "number": {
            "type": "string",
            "description": "These are the digits of the phone number you own on your Twilio."
          },
          "twilioAccountSid": {
            "type": "string",
            "description": "This is the Twilio Account SID for the phone number."
          }
        },
        "required": [
          "provider",
          "id",
          "orgId",
          "createdAt",
          "updatedAt",
          "number",
          "twilioAccountSid"
        ]
      },
      "VonagePhoneNumber": {
        "type": "object",
        "properties": {
          "fallbackDestination": {
            "description": "This is the fallback destination an inbound call will be transferred to if:\n1. `assistantId` is not set\n2. `squadId` is not set\n3. and, `assistant-request` message to the `serverUrl` fails\n\nIf this is not set and above conditions are met, the inbound call is hung up with an error message.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "hooks": {
            "type": "array",
            "description": "This is the hooks that will be used for incoming calls to this phone number.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/PhoneNumberHookCallRinging",
                  "title": "PhoneNumberHookCallRinging"
                }
              ]
            }
          },
          "provider": {
            "type": "string",
            "description": "This is to use numbers bought on Vonage.",
            "enum": [
              "vonage"
            ]
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the phone number."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this phone number belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the phone number was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the phone number was last updated."
          },
          "status": {
            "type": "string",
            "description": "This is the status of the phone number.",
            "enum": [
              "active",
              "activating",
              "blocked"
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of the phone number. This is just for your own reference.",
            "maxLength": 40
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId` nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "workflowId": {
            "type": "string",
            "description": "This is the workflow that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server\n2. phoneNumber.server\n3. org.server",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "number": {
            "type": "string",
            "description": "These are the digits of the phone number you own on your Vonage."
          },
          "credentialId": {
            "type": "string",
            "description": "This is the credential you added in dashboard.vapi.ai/keys. This is used to configure the number to send inbound calls to Vapi, make outbound calls and do live call updates like transfers and hangups."
          }
        },
        "required": [
          "provider",
          "id",
          "orgId",
          "createdAt",
          "updatedAt",
          "number",
          "credentialId"
        ]
      },
      "SipAuthentication": {
        "type": "object",
        "properties": {
          "realm": {
            "type": "string",
            "description": "This will be expected in the `realm` field of the `authorization` header of the SIP INVITE. Defaults to sip.vapi.ai."
          },
          "username": {
            "type": "string",
            "description": "This will be expected in the `username` field of the `authorization` header of the SIP INVITE.",
            "minLength": 20,
            "maxLength": 40
          },
          "password": {
            "type": "string",
            "description": "This will be expected to generate the `response` field of the `authorization` header of the SIP INVITE, through digest authentication.",
            "minLength": 20,
            "maxLength": 40
          }
        },
        "required": [
          "username",
          "password"
        ]
      },
      "VapiPhoneNumber": {
        "type": "object",
        "properties": {
          "fallbackDestination": {
            "description": "This is the fallback destination an inbound call will be transferred to if:\n1. `assistantId` is not set\n2. `squadId` is not set\n3. and, `assistant-request` message to the `serverUrl` fails\n\nIf this is not set and above conditions are met, the inbound call is hung up with an error message.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "hooks": {
            "type": "array",
            "description": "This is the hooks that will be used for incoming calls to this phone number.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/PhoneNumberHookCallRinging",
                  "title": "PhoneNumberHookCallRinging"
                }
              ]
            }
          },
          "provider": {
            "type": "string",
            "description": "This is to create free SIP phone numbers on Vapi.",
            "enum": [
              "vapi"
            ]
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the phone number."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this phone number belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the phone number was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the phone number was last updated."
          },
          "status": {
            "type": "string",
            "description": "This is the status of the phone number.",
            "enum": [
              "active",
              "activating",
              "blocked"
            ]
          },
          "number": {
            "type": "string",
            "description": "These are the digits of the phone number you purchased from Vapi."
          },
          "name": {
            "type": "string",
            "description": "This is the name of the phone number. This is just for your own reference.",
            "maxLength": 40
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId` nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "workflowId": {
            "type": "string",
            "description": "This is the workflow that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server\n2. phoneNumber.server\n3. org.server",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "numberDesiredAreaCode": {
            "type": "string",
            "description": "This is the area code of the phone number to purchase.",
            "minLength": 3,
            "maxLength": 3
          },
          "sipUri": {
            "type": "string",
            "description": "This is the SIP URI of the phone number. You can SIP INVITE this. The assistant attached to this number will answer.\n\nThis is case-insensitive."
          },
          "authentication": {
            "description": "This enables authentication for incoming SIP INVITE requests to the `sipUri`.\n\nIf not set, any username/password to the 401 challenge of the SIP INVITE will be accepted.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SipAuthentication"
              }
            ]
          }
        },
        "required": [
          "provider",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "TelnyxPhoneNumber": {
        "type": "object",
        "properties": {
          "fallbackDestination": {
            "description": "This is the fallback destination an inbound call will be transferred to if:\n1. `assistantId` is not set\n2. `squadId` is not set\n3. and, `assistant-request` message to the `serverUrl` fails\n\nIf this is not set and above conditions are met, the inbound call is hung up with an error message.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "hooks": {
            "type": "array",
            "description": "This is the hooks that will be used for incoming calls to this phone number.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/PhoneNumberHookCallRinging",
                  "title": "PhoneNumberHookCallRinging"
                }
              ]
            }
          },
          "provider": {
            "type": "string",
            "description": "This is to use numbers bought on Telnyx.",
            "enum": [
              "telnyx"
            ]
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the phone number."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this phone number belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the phone number was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the phone number was last updated."
          },
          "status": {
            "type": "string",
            "description": "This is the status of the phone number.",
            "enum": [
              "active",
              "activating",
              "blocked"
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of the phone number. This is just for your own reference.",
            "maxLength": 40
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId` nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "workflowId": {
            "type": "string",
            "description": "This is the workflow that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server\n2. phoneNumber.server\n3. org.server",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "number": {
            "type": "string",
            "description": "These are the digits of the phone number you own on your Telnyx."
          },
          "credentialId": {
            "type": "string",
            "description": "This is the credential you added in dashboard.vapi.ai/keys. This is used to configure the number to send inbound calls to Vapi, make outbound calls and do live call updates like transfers and hangups."
          }
        },
        "required": [
          "provider",
          "id",
          "orgId",
          "createdAt",
          "updatedAt",
          "number",
          "credentialId"
        ]
      },
      "CreateByoPhoneNumberDTO": {
        "type": "object",
        "properties": {
          "fallbackDestination": {
            "description": "This is the fallback destination an inbound call will be transferred to if:\n1. `assistantId` is not set\n2. `squadId` is not set\n3. and, `assistant-request` message to the `serverUrl` fails\n\nIf this is not set and above conditions are met, the inbound call is hung up with an error message.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "hooks": {
            "type": "array",
            "description": "This is the hooks that will be used for incoming calls to this phone number.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/PhoneNumberHookCallRinging",
                  "title": "PhoneNumberHookCallRinging"
                }
              ]
            }
          },
          "provider": {
            "type": "string",
            "description": "This is to bring your own phone numbers from your own SIP trunks or Carriers.",
            "enum": [
              "byo-phone-number"
            ]
          },
          "numberE164CheckEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle the E164 check for the `number` field. This is an advanced property which should be used if you know your use case requires it.\n\nUse cases:\n- `false`: To allow non-E164 numbers like `+001234567890`, `1234`, or `abc`. This is useful for dialing out to non-E164 numbers on your SIP trunks.\n- `true` (default): To allow only E164 numbers like `+14155551234`. This is standard for PSTN calls.\n\nIf `false`, the `number` is still required to only contain alphanumeric characters (regex: `/^\\+?[a-zA-Z0-9]+$/`).\n\n@default true (E164 check is enabled)",
            "default": true
          },
          "number": {
            "type": "string",
            "description": "This is the number of the customer.",
            "minLength": 3,
            "maxLength": 40
          },
          "credentialId": {
            "type": "string",
            "description": "This is the credential of your own SIP trunk or Carrier (type `byo-sip-trunk`) which can be used to make calls to this phone number.\n\nYou can add the SIP trunk or Carrier credential in the Provider Credentials page on the Dashboard to get the credentialId."
          },
          "name": {
            "type": "string",
            "description": "This is the name of the phone number. This is just for your own reference.",
            "maxLength": 40
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId` nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "workflowId": {
            "type": "string",
            "description": "This is the workflow that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server\n2. phoneNumber.server\n3. org.server",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          }
        },
        "required": [
          "provider",
          "credentialId"
        ]
      },
      "CreateTwilioPhoneNumberDTO": {
        "type": "object",
        "properties": {
          "fallbackDestination": {
            "description": "This is the fallback destination an inbound call will be transferred to if:\n1. `assistantId` is not set\n2. `squadId` is not set\n3. and, `assistant-request` message to the `serverUrl` fails\n\nIf this is not set and above conditions are met, the inbound call is hung up with an error message.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "hooks": {
            "type": "array",
            "description": "This is the hooks that will be used for incoming calls to this phone number.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/PhoneNumberHookCallRinging",
                  "title": "PhoneNumberHookCallRinging"
                }
              ]
            }
          },
          "provider": {
            "type": "string",
            "description": "This is to use numbers bought on Twilio.",
            "enum": [
              "twilio"
            ]
          },
          "smsEnabled": {
            "type": "boolean",
            "description": "Controls whether Vapi sets the messaging webhook URL on the Twilio number during import.\n\nIf set to `false`, Vapi will not update the Twilio messaging URL, leaving it as is.\nIf `true` or omitted (default), Vapi will configure both the voice and messaging URLs.\n\n@default true",
            "default": true
          },
          "number": {
            "type": "string",
            "description": "These are the digits of the phone number you own on your Twilio."
          },
          "twilioAccountSid": {
            "type": "string",
            "description": "This is the Twilio Account SID for the phone number."
          },
          "twilioAuthToken": {
            "type": "string",
            "description": "This is the Twilio Auth Token for the phone number."
          },
          "twilioApiKey": {
            "type": "string",
            "description": "This is the Twilio API Key for the phone number."
          },
          "twilioApiSecret": {
            "type": "string",
            "description": "This is the Twilio API Secret for the phone number."
          },
          "name": {
            "type": "string",
            "description": "This is the name of the phone number. This is just for your own reference.",
            "maxLength": 40
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId` nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "workflowId": {
            "type": "string",
            "description": "This is the workflow that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server\n2. phoneNumber.server\n3. org.server",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          }
        },
        "required": [
          "provider",
          "number",
          "twilioAccountSid"
        ]
      },
      "CreateVonagePhoneNumberDTO": {
        "type": "object",
        "properties": {
          "fallbackDestination": {
            "description": "This is the fallback destination an inbound call will be transferred to if:\n1. `assistantId` is not set\n2. `squadId` is not set\n3. and, `assistant-request` message to the `serverUrl` fails\n\nIf this is not set and above conditions are met, the inbound call is hung up with an error message.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "hooks": {
            "type": "array",
            "description": "This is the hooks that will be used for incoming calls to this phone number.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/PhoneNumberHookCallRinging",
                  "title": "PhoneNumberHookCallRinging"
                }
              ]
            }
          },
          "provider": {
            "type": "string",
            "description": "This is to use numbers bought on Vonage.",
            "enum": [
              "vonage"
            ]
          },
          "number": {
            "type": "string",
            "description": "These are the digits of the phone number you own on your Vonage."
          },
          "credentialId": {
            "type": "string",
            "description": "This is the credential you added in dashboard.vapi.ai/keys. This is used to configure the number to send inbound calls to Vapi, make outbound calls and do live call updates like transfers and hangups."
          },
          "name": {
            "type": "string",
            "description": "This is the name of the phone number. This is just for your own reference.",
            "maxLength": 40
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId` nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "workflowId": {
            "type": "string",
            "description": "This is the workflow that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server\n2. phoneNumber.server\n3. org.server",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          }
        },
        "required": [
          "provider",
          "number",
          "credentialId"
        ]
      },
      "CreateVapiPhoneNumberDTO": {
        "type": "object",
        "properties": {
          "fallbackDestination": {
            "description": "This is the fallback destination an inbound call will be transferred to if:\n1. `assistantId` is not set\n2. `squadId` is not set\n3. and, `assistant-request` message to the `serverUrl` fails\n\nIf this is not set and above conditions are met, the inbound call is hung up with an error message.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "hooks": {
            "type": "array",
            "description": "This is the hooks that will be used for incoming calls to this phone number.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/PhoneNumberHookCallRinging",
                  "title": "PhoneNumberHookCallRinging"
                }
              ]
            }
          },
          "provider": {
            "type": "string",
            "description": "This is to create free SIP phone numbers on Vapi.",
            "enum": [
              "vapi"
            ]
          },
          "numberDesiredAreaCode": {
            "type": "string",
            "description": "This is the area code of the phone number to purchase.",
            "minLength": 3,
            "maxLength": 3
          },
          "sipUri": {
            "type": "string",
            "description": "This is the SIP URI of the phone number. You can SIP INVITE this. The assistant attached to this number will answer.\n\nThis is case-insensitive."
          },
          "authentication": {
            "description": "This enables authentication for incoming SIP INVITE requests to the `sipUri`.\n\nIf not set, any username/password to the 401 challenge of the SIP INVITE will be accepted.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SipAuthentication"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of the phone number. This is just for your own reference.",
            "maxLength": 40
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId` nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "workflowId": {
            "type": "string",
            "description": "This is the workflow that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server\n2. phoneNumber.server\n3. org.server",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          }
        },
        "required": [
          "provider"
        ]
      },
      "CreateTelnyxPhoneNumberDTO": {
        "type": "object",
        "properties": {
          "fallbackDestination": {
            "description": "This is the fallback destination an inbound call will be transferred to if:\n1. `assistantId` is not set\n2. `squadId` is not set\n3. and, `assistant-request` message to the `serverUrl` fails\n\nIf this is not set and above conditions are met, the inbound call is hung up with an error message.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "hooks": {
            "type": "array",
            "description": "This is the hooks that will be used for incoming calls to this phone number.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/PhoneNumberHookCallRinging",
                  "title": "PhoneNumberHookCallRinging"
                }
              ]
            }
          },
          "provider": {
            "type": "string",
            "description": "This is to use numbers bought on Telnyx.",
            "enum": [
              "telnyx"
            ]
          },
          "number": {
            "type": "string",
            "description": "These are the digits of the phone number you own on your Telnyx."
          },
          "credentialId": {
            "type": "string",
            "description": "This is the credential you added in dashboard.vapi.ai/keys. This is used to configure the number to send inbound calls to Vapi, make outbound calls and do live call updates like transfers and hangups."
          },
          "name": {
            "type": "string",
            "description": "This is the name of the phone number. This is just for your own reference.",
            "maxLength": 40
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId` nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "workflowId": {
            "type": "string",
            "description": "This is the workflow that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server\n2. phoneNumber.server\n3. org.server",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          }
        },
        "required": [
          "provider",
          "number",
          "credentialId"
        ]
      },
      "UpdateByoPhoneNumberDTO": {
        "type": "object",
        "properties": {
          "fallbackDestination": {
            "description": "This is the fallback destination an inbound call will be transferred to if:\n1. `assistantId` is not set\n2. `squadId` is not set\n3. and, `assistant-request` message to the `serverUrl` fails\n\nIf this is not set and above conditions are met, the inbound call is hung up with an error message.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "hooks": {
            "type": "array",
            "description": "This is the hooks that will be used for incoming calls to this phone number.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/PhoneNumberHookCallRinging",
                  "title": "PhoneNumberHookCallRinging"
                }
              ]
            }
          },
          "numberE164CheckEnabled": {
            "type": "boolean",
            "description": "This is the flag to toggle the E164 check for the `number` field. This is an advanced property which should be used if you know your use case requires it.\n\nUse cases:\n- `false`: To allow non-E164 numbers like `+001234567890`, `1234`, or `abc`. This is useful for dialing out to non-E164 numbers on your SIP trunks.\n- `true` (default): To allow only E164 numbers like `+14155551234`. This is standard for PSTN calls.\n\nIf `false`, the `number` is still required to only contain alphanumeric characters (regex: `/^\\+?[a-zA-Z0-9]+$/`).\n\n@default true (E164 check is enabled)",
            "default": true
          },
          "name": {
            "type": "string",
            "description": "This is the name of the phone number. This is just for your own reference.",
            "maxLength": 40
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId` nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "workflowId": {
            "type": "string",
            "description": "This is the workflow that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server\n2. phoneNumber.server\n3. org.server",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "number": {
            "type": "string",
            "description": "This is the number of the customer.",
            "minLength": 3,
            "maxLength": 40
          },
          "credentialId": {
            "type": "string",
            "description": "This is the credential of your own SIP trunk or Carrier (type `byo-sip-trunk`) which can be used to make calls to this phone number.\n\nYou can add the SIP trunk or Carrier credential in the Provider Credentials page on the Dashboard to get the credentialId."
          }
        }
      },
      "UpdateTwilioPhoneNumberDTO": {
        "type": "object",
        "properties": {
          "fallbackDestination": {
            "description": "This is the fallback destination an inbound call will be transferred to if:\n1. `assistantId` is not set\n2. `squadId` is not set\n3. and, `assistant-request` message to the `serverUrl` fails\n\nIf this is not set and above conditions are met, the inbound call is hung up with an error message.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "hooks": {
            "type": "array",
            "description": "This is the hooks that will be used for incoming calls to this phone number.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/PhoneNumberHookCallRinging",
                  "title": "PhoneNumberHookCallRinging"
                }
              ]
            }
          },
          "smsEnabled": {
            "type": "boolean",
            "description": "Controls whether Vapi sets the messaging webhook URL on the Twilio number during import.\n\nIf set to `false`, Vapi will not update the Twilio messaging URL, leaving it as is.\nIf `true` or omitted (default), Vapi will configure both the voice and messaging URLs.\n\n@default true",
            "default": true
          },
          "name": {
            "type": "string",
            "description": "This is the name of the phone number. This is just for your own reference.",
            "maxLength": 40
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId` nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "workflowId": {
            "type": "string",
            "description": "This is the workflow that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server\n2. phoneNumber.server\n3. org.server",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "number": {
            "type": "string",
            "description": "These are the digits of the phone number you own on your Twilio."
          },
          "twilioAccountSid": {
            "type": "string",
            "description": "This is the Twilio Account SID for the phone number."
          },
          "twilioAuthToken": {
            "type": "string",
            "description": "This is the Twilio Auth Token for the phone number."
          },
          "twilioApiKey": {
            "type": "string",
            "description": "This is the Twilio API Key for the phone number."
          },
          "twilioApiSecret": {
            "type": "string",
            "description": "This is the Twilio API Secret for the phone number."
          }
        }
      },
      "UpdateVonagePhoneNumberDTO": {
        "type": "object",
        "properties": {
          "fallbackDestination": {
            "description": "This is the fallback destination an inbound call will be transferred to if:\n1. `assistantId` is not set\n2. `squadId` is not set\n3. and, `assistant-request` message to the `serverUrl` fails\n\nIf this is not set and above conditions are met, the inbound call is hung up with an error message.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "hooks": {
            "type": "array",
            "description": "This is the hooks that will be used for incoming calls to this phone number.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/PhoneNumberHookCallRinging",
                  "title": "PhoneNumberHookCallRinging"
                }
              ]
            }
          },
          "name": {
            "type": "string",
            "description": "This is the name of the phone number. This is just for your own reference.",
            "maxLength": 40
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId` nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "workflowId": {
            "type": "string",
            "description": "This is the workflow that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server\n2. phoneNumber.server\n3. org.server",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "number": {
            "type": "string",
            "description": "These are the digits of the phone number you own on your Vonage."
          },
          "credentialId": {
            "type": "string",
            "description": "This is the credential you added in dashboard.vapi.ai/keys. This is used to configure the number to send inbound calls to Vapi, make outbound calls and do live call updates like transfers and hangups."
          }
        }
      },
      "UpdateVapiPhoneNumberDTO": {
        "type": "object",
        "properties": {
          "fallbackDestination": {
            "description": "This is the fallback destination an inbound call will be transferred to if:\n1. `assistantId` is not set\n2. `squadId` is not set\n3. and, `assistant-request` message to the `serverUrl` fails\n\nIf this is not set and above conditions are met, the inbound call is hung up with an error message.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "hooks": {
            "type": "array",
            "description": "This is the hooks that will be used for incoming calls to this phone number.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/PhoneNumberHookCallRinging",
                  "title": "PhoneNumberHookCallRinging"
                }
              ]
            }
          },
          "name": {
            "type": "string",
            "description": "This is the name of the phone number. This is just for your own reference.",
            "maxLength": 40
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId` nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "workflowId": {
            "type": "string",
            "description": "This is the workflow that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server\n2. phoneNumber.server\n3. org.server",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "sipUri": {
            "type": "string",
            "description": "This is the SIP URI of the phone number. You can SIP INVITE this. The assistant attached to this number will answer.\n\nThis is case-insensitive."
          },
          "authentication": {
            "description": "This enables authentication for incoming SIP INVITE requests to the `sipUri`.\n\nIf not set, any username/password to the 401 challenge of the SIP INVITE will be accepted.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SipAuthentication"
              }
            ]
          }
        }
      },
      "UpdateTelnyxPhoneNumberDTO": {
        "type": "object",
        "properties": {
          "fallbackDestination": {
            "description": "This is the fallback destination an inbound call will be transferred to if:\n1. `assistantId` is not set\n2. `squadId` is not set\n3. and, `assistant-request` message to the `serverUrl` fails\n\nIf this is not set and above conditions are met, the inbound call is hung up with an error message.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "hooks": {
            "type": "array",
            "description": "This is the hooks that will be used for incoming calls to this phone number.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/PhoneNumberHookCallRinging",
                  "title": "PhoneNumberHookCallRinging"
                }
              ]
            }
          },
          "name": {
            "type": "string",
            "description": "This is the name of the phone number. This is just for your own reference.",
            "maxLength": 40
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId` nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "workflowId": {
            "type": "string",
            "description": "This is the workflow that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server\n2. phoneNumber.server\n3. org.server",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "number": {
            "type": "string",
            "description": "These are the digits of the phone number you own on your Telnyx."
          },
          "credentialId": {
            "type": "string",
            "description": "This is the credential you added in dashboard.vapi.ai/keys. This is used to configure the number to send inbound calls to Vapi, make outbound calls and do live call updates like transfers and hangups."
          }
        }
      },
      "ImportVonagePhoneNumberDTO": {
        "type": "object",
        "properties": {
          "fallbackDestination": {
            "description": "This is the fallback destination an inbound call will be transferred to if:\n1. `assistantId` is not set\n2. `squadId` is not set\n3. and, `assistant-request` message to the `serverUrl` fails\n\nIf this is not set and above conditions are met, the inbound call is hung up with an error message.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "hooks": {
            "type": "array",
            "description": "This is the hooks that will be used for incoming calls to this phone number.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/PhoneNumberHookCallRinging",
                  "title": "PhoneNumberHookCallRinging"
                }
              ]
            }
          },
          "vonagePhoneNumber": {
            "type": "string",
            "description": "These are the digits of the phone number you own on your Vonage.",
            "deprecated": true
          },
          "credentialId": {
            "type": "string",
            "description": "This is the credential you added in dashboard.vapi.ai/keys. This is used to configure the number to send inbound calls to Vapi, make outbound calls and do live call updates like transfers and hangups."
          },
          "name": {
            "type": "string",
            "description": "This is the name of the phone number. This is just for your own reference.",
            "maxLength": 40
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId` nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "workflowId": {
            "type": "string",
            "description": "This is the workflow that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for incoming calls to this phone number.\n\nIf neither `assistantId`, `squadId`, nor `workflowId` is set, `assistant-request` will be sent to your Server URL. Check `ServerMessage` and `ServerMessageResponse` for the shape of the message and response that is expected."
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server\n2. phoneNumber.server\n3. org.server",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          }
        },
        "required": [
          "vonagePhoneNumber",
          "credentialId"
        ]
      },
      "PhoneNumberPaginatedResponse": {
        "type": "object",
        "properties": {
          "results": {
            "type": "array",
            "description": "A list of phone numbers, which can be of any provider type.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ByoPhoneNumber"
                },
                {
                  "$ref": "#/components/schemas/TwilioPhoneNumber"
                },
                {
                  "$ref": "#/components/schemas/VonagePhoneNumber"
                },
                {
                  "$ref": "#/components/schemas/VapiPhoneNumber"
                },
                {
                  "$ref": "#/components/schemas/TelnyxPhoneNumber"
                }
              ]
            }
          },
          "metadata": {
            "description": "Metadata about the pagination.",
            "allOf": [
              {
                "$ref": "#/components/schemas/PaginationMeta"
              }
            ]
          }
        },
        "required": [
          "results",
          "metadata"
        ]
      },
      "DtmfTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "dtmf"
            ],
            "description": "The type of tool. \"dtmf\" for DTMF tool."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "EndCallTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "endCall"
            ],
            "description": "The type of tool. \"endCall\" for End Call tool."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "FunctionTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "function"
            ],
            "description": "The type of tool. \"function\" for Function tool."
          },
          "async": {
            "type": "boolean",
            "example": false,
            "description": "This determines if the tool is async.\n\n  If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.\n\n  If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.\n\n  Defaults to synchronous (`false`)."
          },
          "server": {
            "description": "\n  This is the server where a `tool-calls` webhook will be sent.\n\n  Notes:\n  - Webhook is sent to this server when a tool call is made.\n  - Webhook contains the call, assistant, and phone number objects.\n  - Webhook contains the variables set on the assistant.\n  - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.\n  - Webhook expects a response with tool call result.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "GhlTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "ghl"
            ],
            "description": "The type of tool. \"ghl\" for GHL tool."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          },
          "metadata": {
            "$ref": "#/components/schemas/GhlToolMetadata"
          }
        },
        "required": [
          "type",
          "id",
          "orgId",
          "createdAt",
          "updatedAt",
          "metadata"
        ]
      },
      "MakeTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "make"
            ],
            "description": "The type of tool. \"make\" for Make tool."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          },
          "metadata": {
            "$ref": "#/components/schemas/MakeToolMetadata"
          }
        },
        "required": [
          "type",
          "id",
          "orgId",
          "createdAt",
          "updatedAt",
          "metadata"
        ]
      },
      "TransferCallTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "transferCall"
            ]
          },
          "destinations": {
            "type": "array",
            "description": "These are the destinations that the call can be transferred to. If no destinations are provided, server.url will be used to get the transfer destination once the tool is called.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TransferDestinationAssistant",
                  "title": "Assistant"
                },
                {
                  "$ref": "#/components/schemas/TransferDestinationNumber",
                  "title": "Number"
                },
                {
                  "$ref": "#/components/schemas/TransferDestinationSip",
                  "title": "Sip"
                }
              ]
            }
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "OutputTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "output"
            ],
            "description": "The type of tool. \"output\" for Output tool."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "BashTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "bash"
            ],
            "description": "The type of tool. \"bash\" for Bash tool."
          },
          "subType": {
            "type": "string",
            "enum": [
              "bash_20241022"
            ],
            "description": "The sub type of tool."
          },
          "server": {
            "description": "\n  This is the server where a `tool-calls` webhook will be sent.\n\n  Notes:\n  - Webhook is sent to this server when a tool call is made.\n  - Webhook contains the call, assistant, and phone number objects.\n  - Webhook contains the variables set on the assistant.\n  - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.\n  - Webhook expects a response with tool call result.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "The name of the tool, fixed to 'bash'",
            "default": "bash",
            "enum": [
              "bash"
            ]
          }
        },
        "required": [
          "type",
          "subType",
          "id",
          "orgId",
          "createdAt",
          "updatedAt",
          "name"
        ]
      },
      "ComputerTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "computer"
            ],
            "description": "The type of tool. \"computer\" for Computer tool."
          },
          "subType": {
            "type": "string",
            "enum": [
              "computer_20241022"
            ],
            "description": "The sub type of tool."
          },
          "server": {
            "description": "\n  This is the server where a `tool-calls` webhook will be sent.\n\n  Notes:\n  - Webhook is sent to this server when a tool call is made.\n  - Webhook contains the call, assistant, and phone number objects.\n  - Webhook contains the variables set on the assistant.\n  - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.\n  - Webhook expects a response with tool call result.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "The name of the tool, fixed to 'computer'",
            "default": "computer",
            "enum": [
              "computer"
            ]
          },
          "displayWidthPx": {
            "type": "number",
            "description": "The display width in pixels"
          },
          "displayHeightPx": {
            "type": "number",
            "description": "The display height in pixels"
          },
          "displayNumber": {
            "type": "number",
            "description": "Optional display number"
          }
        },
        "required": [
          "type",
          "subType",
          "id",
          "orgId",
          "createdAt",
          "updatedAt",
          "name",
          "displayWidthPx",
          "displayHeightPx"
        ]
      },
      "TextEditorTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "textEditor"
            ],
            "description": "The type of tool. \"textEditor\" for Text Editor tool."
          },
          "subType": {
            "type": "string",
            "enum": [
              "text_editor_20241022"
            ],
            "description": "The sub type of tool."
          },
          "server": {
            "description": "\n  This is the server where a `tool-calls` webhook will be sent.\n\n  Notes:\n  - Webhook is sent to this server when a tool call is made.\n  - Webhook contains the call, assistant, and phone number objects.\n  - Webhook contains the variables set on the assistant.\n  - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.\n  - Webhook expects a response with tool call result.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "The name of the tool, fixed to 'str_replace_editor'",
            "default": "str_replace_editor",
            "enum": [
              "str_replace_editor"
            ]
          }
        },
        "required": [
          "type",
          "subType",
          "id",
          "orgId",
          "createdAt",
          "updatedAt",
          "name"
        ]
      },
      "QueryTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "query"
            ],
            "description": "The type of tool. \"query\" for Query tool."
          },
          "knowledgeBases": {
            "description": "The knowledge bases to query",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/KnowledgeBase"
            }
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "GoogleCalendarCreateEventTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "google.calendar.event.create"
            ],
            "description": "The type of tool. \"google.calendar.event.create\" for Google Calendar tool."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "GoogleSheetsRowAppendTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "google.sheets.row.append"
            ],
            "description": "The type of tool. \"google.sheets.row.append\" for Google Sheets tool."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "GoogleCalendarCheckAvailabilityTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "google.calendar.availability.check"
            ],
            "description": "The type of tool. \"google.calendar.availability.check\" for Google Calendar availability check tool."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "SlackSendMessageTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "slack.message.send"
            ],
            "description": "The type of tool. \"slack.message.send\" for Slack send message tool."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "SmsTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "sms"
            ],
            "description": "The type of tool. \"sms\" for Twilio SMS sending tool."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "McpTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "mcp"
            ],
            "description": "The type of tool. \"mcp\" for MCP tool."
          },
          "server": {
            "description": "\n  This is the server where a `tool-calls` webhook will be sent.\n\n  Notes:\n  - Webhook is sent to this server when a tool call is made.\n  - Webhook contains the call, assistant, and phone number objects.\n  - Webhook contains the variables set on the assistant.\n  - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.\n  - Webhook expects a response with tool call result.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "GoHighLevelCalendarAvailabilityTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "gohighlevel.calendar.availability.check"
            ],
            "description": "The type of tool. \"gohighlevel.calendar.availability.check\" for GoHighLevel Calendar availability check tool."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "GoHighLevelCalendarEventCreateTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "gohighlevel.calendar.event.create"
            ],
            "description": "The type of tool. \"gohighlevel.calendar.event.create\" for GoHighLevel Calendar event create tool."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "GoHighLevelContactCreateTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "gohighlevel.contact.create"
            ],
            "description": "The type of tool. \"gohighlevel.contact.create\" for GoHighLevel contact create tool."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "GoHighLevelContactGetTool": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "gohighlevel.contact.get"
            ],
            "description": "The type of tool. \"gohighlevel.contact.get\" for GoHighLevel contact get tool."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the tool."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization that this tool belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the tool was last updated."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "CreateApiRequestToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "apiRequest"
            ],
            "description": "The type of tool. \"apiRequest\" for API request tool."
          },
          "method": {
            "type": "string",
            "enum": [
              "POST",
              "GET"
            ]
          },
          "timeoutSeconds": {
            "type": "number",
            "description": "This is the timeout in seconds for the request. Defaults to 20 seconds.\n\n@default 20",
            "minimum": 1,
            "maximum": 300,
            "example": 20
          },
          "name": {
            "type": "string",
            "description": "This is the name of the tool. This will be passed to the model.",
            "maxLength": 40
          },
          "description": {
            "type": "string",
            "description": "This is the description of the tool. This will be passed to the model.",
            "maxLength": 1000
          },
          "url": {
            "type": "string",
            "description": "This is where the request will be sent."
          },
          "body": {
            "description": "This is the body of the request.",
            "allOf": [
              {
                "$ref": "#/components/schemas/JsonSchema"
              }
            ]
          },
          "headers": {
            "description": "These are the headers to send in the request.",
            "allOf": [
              {
                "$ref": "#/components/schemas/JsonSchema"
              }
            ]
          },
          "backoffPlan": {
            "description": "This is the backoff plan if the request fails. Defaults to undefined (the request will not be retried).\n\n@default undefined (the request will not be retried)",
            "allOf": [
              {
                "$ref": "#/components/schemas/BackoffPlan"
              }
            ]
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "method",
          "url"
        ]
      },
      "CreateOutputToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "output"
            ],
            "description": "The type of tool. \"output\" for Output tool."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "CreateBashToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "bash"
            ],
            "description": "The type of tool. \"bash\" for Bash tool."
          },
          "subType": {
            "type": "string",
            "enum": [
              "bash_20241022"
            ],
            "description": "The sub type of tool."
          },
          "server": {
            "description": "\n  This is the server where a `tool-calls` webhook will be sent.\n\n  Notes:\n  - Webhook is sent to this server when a tool call is made.\n  - Webhook contains the call, assistant, and phone number objects.\n  - Webhook contains the variables set on the assistant.\n  - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.\n  - Webhook expects a response with tool call result.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "The name of the tool, fixed to 'bash'",
            "default": "bash",
            "enum": [
              "bash"
            ]
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "subType",
          "name"
        ]
      },
      "CreateComputerToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "computer"
            ],
            "description": "The type of tool. \"computer\" for Computer tool."
          },
          "subType": {
            "type": "string",
            "enum": [
              "computer_20241022"
            ],
            "description": "The sub type of tool."
          },
          "server": {
            "description": "\n  This is the server where a `tool-calls` webhook will be sent.\n\n  Notes:\n  - Webhook is sent to this server when a tool call is made.\n  - Webhook contains the call, assistant, and phone number objects.\n  - Webhook contains the variables set on the assistant.\n  - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.\n  - Webhook expects a response with tool call result.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "The name of the tool, fixed to 'computer'",
            "default": "computer",
            "enum": [
              "computer"
            ]
          },
          "displayWidthPx": {
            "type": "number",
            "description": "The display width in pixels"
          },
          "displayHeightPx": {
            "type": "number",
            "description": "The display height in pixels"
          },
          "displayNumber": {
            "type": "number",
            "description": "Optional display number"
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "subType",
          "name",
          "displayWidthPx",
          "displayHeightPx"
        ]
      },
      "CreateTextEditorToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "textEditor"
            ],
            "description": "The type of tool. \"textEditor\" for Text Editor tool."
          },
          "subType": {
            "type": "string",
            "enum": [
              "text_editor_20241022"
            ],
            "description": "The sub type of tool."
          },
          "server": {
            "description": "\n  This is the server where a `tool-calls` webhook will be sent.\n\n  Notes:\n  - Webhook is sent to this server when a tool call is made.\n  - Webhook contains the call, assistant, and phone number objects.\n  - Webhook contains the variables set on the assistant.\n  - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.\n  - Webhook expects a response with tool call result.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "The name of the tool, fixed to 'str_replace_editor'",
            "default": "str_replace_editor",
            "enum": [
              "str_replace_editor"
            ]
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "subType",
          "name"
        ]
      },
      "CreateSmsToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "sms"
            ],
            "description": "The type of tool. \"sms\" for Twilio SMS sending tool."
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "UpdateDtmfToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        }
      },
      "UpdateEndCallToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        }
      },
      "UpdateFunctionToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "async": {
            "type": "boolean",
            "example": false,
            "description": "This determines if the tool is async.\n\n  If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.\n\n  If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.\n\n  Defaults to synchronous (`false`)."
          },
          "server": {
            "description": "\n  This is the server where a `tool-calls` webhook will be sent.\n\n  Notes:\n  - Webhook is sent to this server when a tool call is made.\n  - Webhook contains the call, assistant, and phone number objects.\n  - Webhook contains the variables set on the assistant.\n  - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.\n  - Webhook expects a response with tool call result.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        }
      },
      "UpdateGhlToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          },
          "metadata": {
            "$ref": "#/components/schemas/GhlToolMetadata"
          }
        }
      },
      "UpdateMakeToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          },
          "metadata": {
            "$ref": "#/components/schemas/MakeToolMetadata"
          }
        }
      },
      "UpdateTransferCallToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "destinations": {
            "type": "array",
            "description": "These are the destinations that the call can be transferred to. If no destinations are provided, server.url will be used to get the transfer destination once the tool is called.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TransferDestinationAssistant",
                  "title": "Assistant"
                },
                {
                  "$ref": "#/components/schemas/TransferDestinationNumber",
                  "title": "Number"
                },
                {
                  "$ref": "#/components/schemas/TransferDestinationSip",
                  "title": "Sip"
                }
              ]
            }
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        }
      },
      "UpdateOutputToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        }
      },
      "UpdateBashToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "subType": {
            "type": "string",
            "enum": [
              "bash_20241022"
            ],
            "description": "The sub type of tool."
          },
          "server": {
            "description": "\n  This is the server where a `tool-calls` webhook will be sent.\n\n  Notes:\n  - Webhook is sent to this server when a tool call is made.\n  - Webhook contains the call, assistant, and phone number objects.\n  - Webhook contains the variables set on the assistant.\n  - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.\n  - Webhook expects a response with tool call result.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "The name of the tool, fixed to 'bash'",
            "default": "bash",
            "enum": [
              "bash"
            ]
          }
        }
      },
      "UpdateComputerToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "subType": {
            "type": "string",
            "enum": [
              "computer_20241022"
            ],
            "description": "The sub type of tool."
          },
          "server": {
            "description": "\n  This is the server where a `tool-calls` webhook will be sent.\n\n  Notes:\n  - Webhook is sent to this server when a tool call is made.\n  - Webhook contains the call, assistant, and phone number objects.\n  - Webhook contains the variables set on the assistant.\n  - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.\n  - Webhook expects a response with tool call result.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "The name of the tool, fixed to 'computer'",
            "default": "computer",
            "enum": [
              "computer"
            ]
          },
          "displayWidthPx": {
            "type": "number",
            "description": "The display width in pixels"
          },
          "displayHeightPx": {
            "type": "number",
            "description": "The display height in pixels"
          },
          "displayNumber": {
            "type": "number",
            "description": "Optional display number"
          }
        }
      },
      "UpdateTextEditorToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "subType": {
            "type": "string",
            "enum": [
              "text_editor_20241022"
            ],
            "description": "The sub type of tool."
          },
          "server": {
            "description": "\n  This is the server where a `tool-calls` webhook will be sent.\n\n  Notes:\n  - Webhook is sent to this server when a tool call is made.\n  - Webhook contains the call, assistant, and phone number objects.\n  - Webhook contains the variables set on the assistant.\n  - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.\n  - Webhook expects a response with tool call result.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "The name of the tool, fixed to 'str_replace_editor'",
            "default": "str_replace_editor",
            "enum": [
              "str_replace_editor"
            ]
          }
        }
      },
      "UpdateQueryToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "knowledgeBases": {
            "description": "The knowledge bases to query",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/KnowledgeBase"
            }
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        }
      },
      "UpdateGoogleCalendarCreateEventToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        }
      },
      "UpdateGoogleSheetsRowAppendToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        }
      },
      "UpdateGoogleCalendarCheckAvailabilityToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        }
      },
      "UpdateSlackSendMessageToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        }
      },
      "UpdateSmsToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        }
      },
      "UpdateMcpToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "server": {
            "description": "\n  This is the server where a `tool-calls` webhook will be sent.\n\n  Notes:\n  - Webhook is sent to this server when a tool call is made.\n  - Webhook contains the call, assistant, and phone number objects.\n  - Webhook contains the variables set on the assistant.\n  - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.\n  - Webhook expects a response with tool call result.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        }
      },
      "UpdateGoHighLevelCalendarAvailabilityToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        }
      },
      "UpdateGoHighLevelCalendarEventCreateToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        }
      },
      "UpdateGoHighLevelContactCreateToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        }
      },
      "UpdateGoHighLevelContactGetToolDTO": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        }
      },
      "CreateFileDTO": {
        "type": "object",
        "properties": {
          "file": {
            "type": "string",
            "description": "This is the File you want to upload for use with the Knowledge Base.",
            "format": "binary"
          }
        },
        "required": [
          "file"
        ]
      },
      "File": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "enum": [
              "file"
            ]
          },
          "status": {
            "enum": [
              "processing",
              "done",
              "failed"
            ],
            "type": "string"
          },
          "name": {
            "type": "string",
            "description": "This is the name of the file. This is just for your own reference.",
            "maxLength": 40
          },
          "originalName": {
            "type": "string"
          },
          "bytes": {
            "type": "number"
          },
          "purpose": {
            "type": "string"
          },
          "mimetype": {
            "type": "string"
          },
          "key": {
            "type": "string"
          },
          "path": {
            "type": "string"
          },
          "bucket": {
            "type": "string"
          },
          "url": {
            "type": "string"
          },
          "parsedTextUrl": {
            "type": "string"
          },
          "parsedTextBytes": {
            "type": "number"
          },
          "metadata": {
            "type": "object"
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the file."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this file belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the file was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the file was last updated."
          }
        },
        "required": [
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "UpdateFileDTO": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "This is the name of the file. This is just for your own reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "TrieveKnowledgeBaseSearchPlan": {
        "type": "object",
        "properties": {
          "topK": {
            "type": "number",
            "description": "Specifies the number of top chunks to return. This corresponds to the `page_size` parameter in Trieve."
          },
          "removeStopWords": {
            "type": "boolean",
            "description": "If true, stop words (specified in server/src/stop-words.txt in the git repo) will be removed. This will preserve queries that are entirely stop words."
          },
          "scoreThreshold": {
            "type": "number",
            "description": "This is the score threshold to filter out chunks with a score below the threshold for cosine distance metric. For Manhattan Distance, Euclidean Distance, and Dot Product, it will filter out scores above the threshold distance. This threshold applies before weight and bias modifications. If not specified, this defaults to no threshold. A threshold of 0 will default to no threshold."
          },
          "searchType": {
            "type": "string",
            "description": "This is the search method used when searching for relevant chunks from the vector store.",
            "enum": [
              "fulltext",
              "semantic",
              "hybrid",
              "bm25"
            ]
          }
        },
        "required": [
          "searchType"
        ]
      },
      "TrieveKnowledgeBase": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This knowledge base is provided by Trieve.\n\nTo learn more about Trieve, visit https://trieve.ai.",
            "enum": [
              "trieve"
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of the knowledge base."
          },
          "searchPlan": {
            "description": "This is the searching plan used when searching for relevant chunks from the vector store.\n\nYou should configure this if you're running into these issues:\n- Too much unnecessary context is being fed as knowledge base context.\n- Not enough relevant context is being fed as knowledge base context.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TrieveKnowledgeBaseSearchPlan"
              }
            ]
          },
          "createPlan": {
            "description": "This is the plan if you want us to create/import a new vector store using Trieve.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TrieveKnowledgeBaseImport",
                "title": "Import"
              }
            ]
          },
          "id": {
            "type": "string",
            "description": "This is the id of the knowledge base."
          },
          "orgId": {
            "type": "string",
            "description": "This is the org id of the knowledge base."
          }
        },
        "required": [
          "provider",
          "id",
          "orgId"
        ]
      },
      "CustomKnowledgeBase": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This knowledge base is bring your own knowledge base implementation.",
            "enum": [
              "custom-knowledge-base"
            ]
          },
          "server": {
            "description": "This is where the knowledge base request will be sent.\n\nRequest Example:\n\nPOST https://{server.url}\nContent-Type: application/json\n\n{\n  \"messsage\": {\n    \"type\": \"knowledge-base-request\",\n    \"messages\": [\n      {\n        \"role\": \"user\",\n        \"content\": \"Why is ocean blue?\"\n      }\n    ],\n    ...other metadata about the call...\n  }\n}\n\nResponse Expected:\n```\n{\n  \"message\": {\n     \"role\": \"assistant\",\n     \"content\": \"The ocean is blue because water absorbs everything but blue.\",\n  }, // YOU CAN RETURN THE EXACT RESPONSE TO SPEAK\n  \"documents\": [\n    {\n      \"content\": \"The ocean is blue primarily because water absorbs colors in the red part of the light spectrum and scatters the blue light, making it more visible to our eyes.\",\n      \"similarity\": 1\n    },\n    {\n      \"content\": \"Blue light is scattered more by the water molecules than other colors, enhancing the blue appearance of the ocean.\",\n      \"similarity\": .5\n    }\n  ] // OR, YOU CAN RETURN AN ARRAY OF DOCUMENTS THAT WILL BE SENT TO THE MODEL\n}\n```",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "id": {
            "type": "string",
            "description": "This is the id of the knowledge base."
          },
          "orgId": {
            "type": "string",
            "description": "This is the org id of the knowledge base."
          }
        },
        "required": [
          "provider",
          "server",
          "id",
          "orgId"
        ]
      },
      "CreateTrieveKnowledgeBaseDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This knowledge base is provided by Trieve.\n\nTo learn more about Trieve, visit https://trieve.ai.",
            "enum": [
              "trieve"
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of the knowledge base."
          },
          "searchPlan": {
            "description": "This is the searching plan used when searching for relevant chunks from the vector store.\n\nYou should configure this if you're running into these issues:\n- Too much unnecessary context is being fed as knowledge base context.\n- Not enough relevant context is being fed as knowledge base context.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TrieveKnowledgeBaseSearchPlan"
              }
            ]
          },
          "createPlan": {
            "description": "This is the plan if you want us to create/import a new vector store using Trieve.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TrieveKnowledgeBaseImport",
                "title": "Import"
              }
            ]
          }
        },
        "required": [
          "provider"
        ]
      },
      "UpdateTrieveKnowledgeBaseDTO": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "This is the name of the knowledge base."
          },
          "searchPlan": {
            "description": "This is the searching plan used when searching for relevant chunks from the vector store.\n\nYou should configure this if you're running into these issues:\n- Too much unnecessary context is being fed as knowledge base context.\n- Not enough relevant context is being fed as knowledge base context.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TrieveKnowledgeBaseSearchPlan"
              }
            ]
          },
          "createPlan": {
            "description": "This is the plan if you want us to create/import a new vector store using Trieve.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TrieveKnowledgeBaseImport",
                "title": "Import"
              }
            ]
          }
        }
      },
      "UpdateCustomKnowledgeBaseDTO": {
        "type": "object",
        "properties": {
          "server": {
            "description": "This is where the knowledge base request will be sent.\n\nRequest Example:\n\nPOST https://{server.url}\nContent-Type: application/json\n\n{\n  \"messsage\": {\n    \"type\": \"knowledge-base-request\",\n    \"messages\": [\n      {\n        \"role\": \"user\",\n        \"content\": \"Why is ocean blue?\"\n      }\n    ],\n    ...other metadata about the call...\n  }\n}\n\nResponse Expected:\n```\n{\n  \"message\": {\n     \"role\": \"assistant\",\n     \"content\": \"The ocean is blue because water absorbs everything but blue.\",\n  }, // YOU CAN RETURN THE EXACT RESPONSE TO SPEAK\n  \"documents\": [\n    {\n      \"content\": \"The ocean is blue primarily because water absorbs colors in the red part of the light spectrum and scatters the blue light, making it more visible to our eyes.\",\n      \"similarity\": 1\n    },\n    {\n      \"content\": \"Blue light is scattered more by the water molecules than other colors, enhancing the blue appearance of the ocean.\",\n      \"similarity\": .5\n    }\n  ] // OR, YOU CAN RETURN AN ARRAY OF DOCUMENTS THAT WILL BE SENT TO THE MODEL\n}\n```",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          }
        }
      },
      "TrieveKnowledgeBaseChunkPlan": {
        "type": "object",
        "properties": {
          "fileIds": {
            "description": "These are the file ids that will be used to create the vector store. To upload files, use the `POST /files` endpoint.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "websites": {
            "description": "These are the websites that will be used to create the vector store.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "targetSplitsPerChunk": {
            "type": "number",
            "description": "This is an optional field which allows you to specify the number of splits you want per chunk. If not specified, the default 20 is used. However, you may want to use a different number."
          },
          "splitDelimiters": {
            "description": "This is an optional field which allows you to specify the delimiters to use when splitting the file before chunking the text. If not specified, the default [.!?\\n] are used to split into sentences. However, you may want to use spaces or other delimiters.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "rebalanceChunks": {
            "type": "boolean",
            "description": "This is an optional field which allows you to specify whether or not to rebalance the chunks created from the file. If not specified, the default true is used. If true, Trieve will evenly distribute remainder splits across chunks such that 66 splits with a target_splits_per_chunk of 20 will result in 3 chunks with 22 splits each."
          }
        }
      },
      "TrieveKnowledgeBaseCreate": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is to create a new dataset on Trieve.",
            "enum": [
              "create"
            ]
          },
          "chunkPlans": {
            "description": "These are the chunk plans used to create the dataset.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TrieveKnowledgeBaseChunkPlan"
            }
          }
        },
        "required": [
          "type",
          "chunkPlans"
        ]
      },
      "TrieveKnowledgeBaseImport": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is to import an existing dataset from Trieve.",
            "enum": [
              "import"
            ]
          },
          "providerId": {
            "type": "string",
            "description": "This is the `datasetId` of the dataset on your Trieve account."
          }
        },
        "required": [
          "type",
          "providerId"
        ]
      },
      "Workflow": {
        "type": "object",
        "properties": {
          "nodes": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ConversationNode",
                  "title": "ConversationNode"
                },
                {
                  "$ref": "#/components/schemas/ToolNode",
                  "title": "ToolNode"
                }
              ]
            }
          },
          "model": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/WorkflowOpenAIModel",
                "title": "WorkflowOpenAIModel"
              },
              {
                "$ref": "#/components/schemas/WorkflowAnthropicModel",
                "title": "WorkflowAnthropicModel"
              }
            ]
          },
          "id": {
            "type": "string"
          },
          "orgId": {
            "type": "string"
          },
          "createdAt": {
            "format": "date-time",
            "type": "string"
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string"
          },
          "name": {
            "type": "string",
            "maxLength": 80
          },
          "edges": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Edge"
            }
          },
          "globalPrompt": {
            "type": "string",
            "maxLength": 5000
          }
        },
        "required": [
          "nodes",
          "id",
          "orgId",
          "createdAt",
          "updatedAt",
          "name",
          "edges"
        ]
      },
      "UpdateWorkflowDTO": {
        "type": "object",
        "properties": {
          "nodes": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ConversationNode",
                  "title": "ConversationNode"
                },
                {
                  "$ref": "#/components/schemas/ToolNode",
                  "title": "ToolNode"
                }
              ]
            }
          },
          "model": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/WorkflowOpenAIModel",
                "title": "WorkflowOpenAIModel"
              },
              {
                "$ref": "#/components/schemas/WorkflowAnthropicModel",
                "title": "WorkflowAnthropicModel"
              }
            ]
          },
          "name": {
            "type": "string",
            "maxLength": 80
          },
          "edges": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Edge"
            }
          },
          "globalPrompt": {
            "type": "string",
            "maxLength": 5000
          }
        }
      },
      "Squad": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "This is the name of the squad."
          },
          "members": {
            "description": "This is the list of assistants that make up the squad.\n\nThe call will start with the first assistant in the list.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SquadMemberDTO"
            }
          },
          "membersOverrides": {
            "description": "This can be used to override all the assistants' settings and provide values for their template variables.\n\nBoth `membersOverrides` and `members[n].assistantOverrides` can be used together. First, `members[n].assistantOverrides` is applied. Then, `membersOverrides` is applied as a global override.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AssistantOverrides"
              }
            ]
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the squad."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this squad belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the squad was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the squad was last updated."
          }
        },
        "required": [
          "members",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "UpdateSquadDTO": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "This is the name of the squad."
          },
          "members": {
            "description": "This is the list of assistants that make up the squad.\n\nThe call will start with the first assistant in the list.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SquadMemberDTO"
            }
          },
          "membersOverrides": {
            "description": "This can be used to override all the assistants' settings and provide values for their template variables.\n\nBoth `membersOverrides` and `members[n].assistantOverrides` can be used together. First, `members[n].assistantOverrides` is applied. Then, `membersOverrides` is applied as a global override.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AssistantOverrides"
              }
            ]
          }
        },
        "required": [
          "members"
        ]
      },
      "TesterPlan": {
        "type": "object",
        "properties": {
          "assistant": {
            "description": "Pass a transient assistant to use for the test assistant.\n\nMake sure to write a detailed system prompt for a test assistant, and use the {{test.script}} variable to access the test script.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "assistantId": {
            "type": "string",
            "description": "Pass an assistant id that can be access\n\nMake sure to write a detailed system prompt for the test assistant, and use the {{test.script}} variable to access the test script."
          },
          "assistantOverrides": {
            "description": "Add any assistant overrides to the test assistant.\n\nOne use case is if you want to pass custom variables into the test using variableValues, that you can then access in the script\nand rubric using {{varName}}.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AssistantOverrides"
              }
            ]
          }
        }
      },
      "TestSuitePhoneNumber": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the provider of the phone number.",
            "enum": [
              "test-suite"
            ]
          },
          "number": {
            "type": "string",
            "description": "This is the phone number that is being tested.",
            "maxLength": 50
          }
        },
        "required": [
          "provider",
          "number"
        ]
      },
      "TargetPlan": {
        "type": "object",
        "properties": {
          "phoneNumberId": {
            "type": "string",
            "description": "This is the phone number that is being tested.\nDuring the actual test, it'll be called and the assistant attached to it will pick up and be tested.\nTo test an assistant directly, send assistantId instead."
          },
          "phoneNumber": {
            "description": "This can be any phone number (even not on Vapi).\nDuring the actual test, it'll be called.\nTo test a Vapi number, send phoneNumberId. To test an assistant directly, send assistantId instead.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TestSuitePhoneNumber"
              }
            ]
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant being tested.\nDuring the actual test, it'll invoked directly.\nTo test the assistant over phone number, send phoneNumberId instead."
          },
          "assistantOverrides": {
            "description": "This is the assistant overrides applied to assistantId before it is tested.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AssistantOverrides"
              }
            ]
          }
        }
      },
      "TestSuite": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the test suite."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this test suite belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the test suite was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the test suite was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of the test suite.",
            "maxLength": 80
          },
          "phoneNumberId": {
            "type": "string",
            "description": "This is the phone number ID associated with this test suite.",
            "deprecated": true
          },
          "testerPlan": {
            "description": "Override the default tester plan by providing custom assistant configuration for the test agent.\n\nWe recommend only using this if you are confident, as we have already set sensible defaults on the tester plan.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TesterPlan"
              }
            ]
          },
          "targetPlan": {
            "description": "These are the configuration for the assistant / phone number that is being tested.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TargetPlan"
              }
            ]
          }
        },
        "required": [
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "TestSuitesPaginatedResponse": {
        "type": "object",
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TestSuite"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/PaginationMeta"
          }
        },
        "required": [
          "results",
          "metadata"
        ]
      },
      "CreateTestSuiteDto": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "This is the name of the test suite.",
            "maxLength": 80
          },
          "phoneNumberId": {
            "type": "string",
            "description": "This is the phone number ID associated with this test suite.",
            "deprecated": true
          },
          "testerPlan": {
            "description": "Override the default tester plan by providing custom assistant configuration for the test agent.\n\nWe recommend only using this if you are confident, as we have already set sensible defaults on the tester plan.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TesterPlan"
              }
            ]
          },
          "targetPlan": {
            "description": "These are the configuration for the assistant / phone number that is being tested.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TargetPlan"
              }
            ]
          }
        }
      },
      "UpdateTestSuiteDto": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "This is the name of the test suite.",
            "maxLength": 80
          },
          "phoneNumberId": {
            "type": "string",
            "description": "This is the phone number ID associated with this test suite.",
            "deprecated": true
          },
          "testerPlan": {
            "description": "Override the default tester plan by providing custom assistant configuration for the test agent.\n\nWe recommend only using this if you are confident, as we have already set sensible defaults on the tester plan.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TesterPlan"
              }
            ]
          },
          "targetPlan": {
            "description": "These are the configuration for the assistant / phone number that is being tested.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TargetPlan"
              }
            ]
          }
        }
      },
      "TestSuiteTestVoice": {
        "type": "object",
        "properties": {
          "scorers": {
            "type": "array",
            "description": "These are the scorers used to evaluate the test.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TestSuiteTestScorerAI",
                  "title": "AI"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "description": "This is the type of the test, which must be voice.",
            "enum": [
              "voice"
            ],
            "maxLength": 100
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the test."
          },
          "testSuiteId": {
            "type": "string",
            "description": "This is the unique identifier for the test suite this test belongs to."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization this test belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the test was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the test was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of the test.",
            "maxLength": 80
          },
          "script": {
            "type": "string",
            "description": "This is the script to be used for the voice test.",
            "maxLength": 10000
          },
          "numAttempts": {
            "type": "number",
            "description": "This is the number of attempts allowed for the test.",
            "minimum": 1,
            "maximum": 10
          }
        },
        "required": [
          "scorers",
          "type",
          "id",
          "testSuiteId",
          "orgId",
          "createdAt",
          "updatedAt",
          "script"
        ]
      },
      "TestSuiteTestChat": {
        "type": "object",
        "properties": {
          "scorers": {
            "type": "array",
            "description": "These are the scorers used to evaluate the test.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TestSuiteTestScorerAI",
                  "title": "AI"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "description": "This is the type of the test, which must be chat.",
            "enum": [
              "chat"
            ],
            "maxLength": 100
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the test."
          },
          "testSuiteId": {
            "type": "string",
            "description": "This is the unique identifier for the test suite this test belongs to."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization this test belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the test was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the test was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of the test.",
            "maxLength": 80
          },
          "script": {
            "type": "string",
            "description": "This is the script to be used for the chat test.",
            "maxLength": 10000
          },
          "numAttempts": {
            "type": "number",
            "description": "This is the number of attempts allowed for the test.",
            "minimum": 1,
            "maximum": 10
          }
        },
        "required": [
          "scorers",
          "type",
          "id",
          "testSuiteId",
          "orgId",
          "createdAt",
          "updatedAt",
          "script"
        ]
      },
      "CreateTestSuiteTestVoiceDto": {
        "type": "object",
        "properties": {
          "scorers": {
            "type": "array",
            "description": "These are the scorers used to evaluate the test.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TestSuiteTestScorerAI",
                  "title": "AI"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "description": "This is the type of the test, which must be voice.",
            "enum": [
              "voice"
            ],
            "maxLength": 100
          },
          "script": {
            "type": "string",
            "description": "This is the script to be used for the voice test.",
            "maxLength": 10000
          },
          "numAttempts": {
            "type": "number",
            "description": "This is the number of attempts allowed for the test.",
            "minimum": 1,
            "maximum": 10
          },
          "name": {
            "type": "string",
            "description": "This is the name of the test.",
            "maxLength": 80
          }
        },
        "required": [
          "scorers",
          "type",
          "script"
        ]
      },
      "CreateTestSuiteTestChatDto": {
        "type": "object",
        "properties": {
          "scorers": {
            "type": "array",
            "description": "These are the scorers used to evaluate the test.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TestSuiteTestScorerAI",
                  "title": "AI"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "description": "This is the type of the test, which must be chat.",
            "enum": [
              "chat"
            ],
            "maxLength": 100
          },
          "script": {
            "type": "string",
            "description": "This is the script to be used for the chat test.",
            "maxLength": 10000
          },
          "numAttempts": {
            "type": "number",
            "description": "This is the number of attempts allowed for the test.",
            "minimum": 1,
            "maximum": 10
          },
          "name": {
            "type": "string",
            "description": "This is the name of the test.",
            "maxLength": 80
          }
        },
        "required": [
          "scorers",
          "type",
          "script"
        ]
      },
      "UpdateTestSuiteTestVoiceDto": {
        "type": "object",
        "properties": {
          "scorers": {
            "type": "array",
            "description": "These are the scorers used to evaluate the test.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TestSuiteTestScorerAI",
                  "title": "AI"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "description": "This is the type of the test, which must be voice.",
            "enum": [
              "voice"
            ],
            "maxLength": 100
          },
          "name": {
            "type": "string",
            "description": "This is the name of the test.",
            "maxLength": 80
          },
          "script": {
            "type": "string",
            "description": "This is the script to be used for the voice test.",
            "maxLength": 10000
          },
          "numAttempts": {
            "type": "number",
            "description": "This is the number of attempts allowed for the test.",
            "minimum": 1,
            "maximum": 10
          }
        }
      },
      "UpdateTestSuiteTestChatDto": {
        "type": "object",
        "properties": {
          "scorers": {
            "type": "array",
            "description": "These are the scorers used to evaluate the test.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TestSuiteTestScorerAI",
                  "title": "AI"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "description": "This is the type of the test, which must be chat.",
            "enum": [
              "chat"
            ],
            "maxLength": 100
          },
          "name": {
            "type": "string",
            "description": "This is the name of the test.",
            "maxLength": 80
          },
          "script": {
            "type": "string",
            "description": "This is the script to be used for the chat test.",
            "maxLength": 10000
          },
          "numAttempts": {
            "type": "number",
            "description": "This is the number of attempts allowed for the test.",
            "minimum": 1,
            "maximum": 10
          }
        }
      },
      "TestSuiteTestScorerAI": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of the scorer, which must be AI.",
            "enum": [
              "ai"
            ],
            "maxLength": 100
          },
          "rubric": {
            "type": "string",
            "description": "This is the rubric used by the AI scorer.",
            "maxLength": 10000
          }
        },
        "required": [
          "type",
          "rubric"
        ]
      },
      "TestSuiteTestsPaginatedResponse": {
        "type": "object",
        "properties": {
          "results": {
            "type": "array",
            "description": "A list of test suite tests.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TestSuiteTestVoice"
                },
                {
                  "$ref": "#/components/schemas/TestSuiteTestChat"
                }
              ]
            }
          },
          "metadata": {
            "description": "Metadata about the pagination.",
            "allOf": [
              {
                "$ref": "#/components/schemas/PaginationMeta"
              }
            ]
          }
        },
        "required": [
          "results",
          "metadata"
        ]
      },
      "TestSuiteRunScorerAI": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of the scorer, which must be AI.",
            "enum": [
              "ai"
            ],
            "maxLength": 100
          },
          "result": {
            "type": "string",
            "description": "This is the result of the test suite.",
            "enum": [
              "pass",
              "fail"
            ],
            "maxLength": 100
          },
          "reasoning": {
            "type": "string",
            "description": "This is the reasoning provided by the AI scorer.",
            "maxLength": 10000
          },
          "rubric": {
            "type": "string",
            "description": "This is the rubric used by the AI scorer.",
            "maxLength": 10000
          }
        },
        "required": [
          "type",
          "result",
          "reasoning",
          "rubric"
        ]
      },
      "TestSuiteRunTestAttemptCall": {
        "type": "object",
        "properties": {
          "artifact": {
            "description": "This is the artifact of the call.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Artifact"
              }
            ]
          }
        },
        "required": [
          "artifact"
        ]
      },
      "TestSuiteRunTestAttemptMetadata": {
        "type": "object",
        "properties": {
          "sessionId": {
            "type": "string",
            "description": "This is the session ID for the test attempt."
          }
        },
        "required": [
          "sessionId"
        ]
      },
      "TestSuiteRunTestAttempt": {
        "type": "object",
        "properties": {
          "scorerResults": {
            "type": "array",
            "description": "These are the results of the scorers used to evaluate the test attempt.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TestSuiteRunScorerAI",
                  "title": "AI"
                }
              ]
            }
          },
          "call": {
            "description": "This is the call made during the test attempt.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TestSuiteRunTestAttemptCall"
              }
            ]
          },
          "callId": {
            "type": "string",
            "description": "This is the call ID for the test attempt."
          },
          "metadata": {
            "description": "This is the metadata for the test attempt.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TestSuiteRunTestAttemptMetadata"
              }
            ]
          }
        },
        "required": [
          "scorerResults"
        ]
      },
      "TestSuiteRunTestResult": {
        "type": "object",
        "properties": {
          "test": {
            "description": "This is the test that was run.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TestSuiteTestVoice",
                "title": "TestSuiteTestVoice"
              }
            ]
          },
          "attempts": {
            "description": "These are the attempts made for this test.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TestSuiteRunTestAttempt"
            }
          }
        },
        "required": [
          "test",
          "attempts"
        ]
      },
      "TestSuiteRun": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "description": "This is the current status of the test suite run.",
            "enum": [
              "queued",
              "in-progress",
              "completed",
              "failed"
            ]
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the test suite run."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the organization this run belongs to."
          },
          "testSuiteId": {
            "type": "string",
            "description": "This is the unique identifier for the test suite this run belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the test suite run was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the test suite run was last updated."
          },
          "testResults": {
            "description": "These are the results of the tests in this test suite run.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TestSuiteRunTestResult"
            }
          },
          "name": {
            "type": "string",
            "description": "This is the name of the test suite run.",
            "maxLength": 80
          }
        },
        "required": [
          "status",
          "id",
          "orgId",
          "testSuiteId",
          "createdAt",
          "updatedAt",
          "testResults"
        ]
      },
      "TestSuiteRunsPaginatedResponse": {
        "type": "object",
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TestSuiteRun"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/PaginationMeta"
          }
        },
        "required": [
          "results",
          "metadata"
        ]
      },
      "CreateTestSuiteRunDto": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "This is the name of the test suite run.",
            "maxLength": 80
          }
        }
      },
      "UpdateTestSuiteRunDto": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "This is the name of the test suite run.",
            "maxLength": 80
          }
        }
      },
      "TimeRange": {
        "type": "object",
        "properties": {
          "step": {
            "type": "string",
            "description": "This is the time step for aggregations.\n\nIf not provided, defaults to returning for the entire time range.",
            "enum": [
              "second",
              "minute",
              "hour",
              "day",
              "week",
              "month",
              "quarter",
              "year",
              "decade",
              "century",
              "millennium"
            ]
          },
          "start": {
            "format": "date-time",
            "type": "string",
            "description": "This is the start date for the time range.\n\nIf not provided, defaults to the 7 days ago."
          },
          "end": {
            "format": "date-time",
            "type": "string",
            "description": "This is the end date for the time range.\n\nIf not provided, defaults to now."
          },
          "timezone": {
            "type": "string",
            "description": "This is the timezone you want to set for the query.\n\nIf not provided, defaults to UTC."
          }
        }
      },
      "AnalyticsOperation": {
        "type": "object",
        "properties": {
          "operation": {
            "type": "string",
            "description": "This is the aggregation operation you want to perform.",
            "enum": [
              "sum",
              "avg",
              "count",
              "min",
              "max",
              "history"
            ]
          },
          "column": {
            "type": "string",
            "description": "This is the columns you want to perform the aggregation operation on.",
            "enum": [
              "id",
              "cost",
              "costBreakdown.llm",
              "costBreakdown.stt",
              "costBreakdown.tts",
              "costBreakdown.vapi",
              "costBreakdown.ttsCharacters",
              "costBreakdown.llmPromptTokens",
              "costBreakdown.llmCompletionTokens",
              "duration",
              "concurrency",
              "minutesUsed"
            ]
          },
          "alias": {
            "type": "string",
            "description": "This is the alias for column name returned. Defaults to `${operation}${column}`.",
            "maxLength": 40
          }
        },
        "required": [
          "operation",
          "column"
        ]
      },
      "AnalyticsQuery": {
        "type": "object",
        "properties": {
          "table": {
            "type": "string",
            "description": "This is the table you want to query.",
            "enum": [
              "call",
              "subscription"
            ]
          },
          "groupBy": {
            "type": "array",
            "description": "This is the list of columns you want to group by.",
            "enum": [
              "type",
              "assistantId",
              "endedReason",
              "analysis.successEvaluation",
              "status"
            ],
            "items": {
              "type": "string",
              "enum": [
                "type",
                "assistantId",
                "endedReason",
                "analysis.successEvaluation",
                "status"
              ]
            }
          },
          "name": {
            "type": "string",
            "description": "This is the name of the query. This will be used to identify the query in the response.",
            "maxLength": 40
          },
          "timeRange": {
            "description": "This is the time range for the query.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TimeRange"
              }
            ]
          },
          "operations": {
            "description": "This is the list of operations you want to perform.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AnalyticsOperation"
            }
          }
        },
        "required": [
          "table",
          "name",
          "operations"
        ]
      },
      "AnalyticsQueryDTO": {
        "type": "object",
        "properties": {
          "queries": {
            "description": "This is the list of metric queries you want to perform.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AnalyticsQuery"
            }
          }
        },
        "required": [
          "queries"
        ]
      },
      "AnalyticsQueryResult": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "This is the unique key for the query."
          },
          "timeRange": {
            "description": "This is the time range for the query.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TimeRange"
              }
            ]
          },
          "result": {
            "description": "This is the result of the query, a list of unique groups with result of their aggregations.\n\nExample:\n\"result\": [\n  { \"date\": \"2023-01-01\", \"assistantId\": \"123\", \"endedReason\": \"customer-ended-call\", \"sumDuration\": 120, \"avgCost\": 10.5 },\n  { \"date\": \"2023-01-02\", \"assistantId\": \"123\", \"endedReason\": \"customer-did-not-give-microphone-permission\", \"sumDuration\": 0, \"avgCost\": 0 },\n  // Additional results\n]",
            "type": "array",
            "items": {
              "type": "object"
            }
          }
        },
        "required": [
          "name",
          "timeRange",
          "result"
        ]
      },
      "CallLogPrivileged": {
        "type": "object",
        "properties": {
          "callId": {
            "type": "string",
            "description": "This is the unique identifier for the call."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this call log belongs to."
          },
          "log": {
            "type": "string",
            "description": "This is the log message associated with the call."
          },
          "level": {
            "type": "string",
            "description": "This is the level of the log message.",
            "enum": [
              "INFO",
              "LOG",
              "WARN",
              "ERROR",
              "CHECKPOINT"
            ]
          },
          "time": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the log was created."
          }
        },
        "required": [
          "callId",
          "orgId",
          "log",
          "level",
          "time"
        ]
      },
      "CallLogsPaginatedResponse": {
        "type": "object",
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CallLogPrivileged"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/PaginationMeta"
          }
        },
        "required": [
          "results",
          "metadata"
        ]
      },
      "Error": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string"
          }
        },
        "required": [
          "message"
        ]
      },
      "Log": {
        "type": "object",
        "properties": {
          "time": {
            "type": "string",
            "description": "This is the timestamp at which the log was written."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this log belongs to."
          },
          "type": {
            "type": "string",
            "description": "This is the type of the log.",
            "enum": [
              "API",
              "Webhook",
              "Call",
              "Provider"
            ]
          },
          "webhookType": {
            "type": "string",
            "description": "This is the type of the webhook, given the log is from a webhook."
          },
          "resource": {
            "type": "string",
            "description": "This is the specific resource, relevant only to API logs.",
            "enum": [
              "org",
              "assistant",
              "analytics",
              "credential",
              "phone-number",
              "block",
              "voice-library",
              "provider",
              "tool",
              "token",
              "template",
              "squad",
              "call",
              "file",
              "metric",
              "log"
            ]
          },
          "requestDurationSeconds": {
            "type": "number",
            "description": "'This is how long the request took.",
            "minimum": 0
          },
          "requestStartedAt": {
            "type": "string",
            "description": "This is the timestamp at which the request began."
          },
          "requestFinishedAt": {
            "type": "string",
            "description": "This is the timestamp at which the request finished."
          },
          "requestBody": {
            "type": "object",
            "description": "This is the body of the request."
          },
          "requestHttpMethod": {
            "type": "string",
            "description": "This is the request method.",
            "enum": [
              "POST",
              "GET",
              "PUT",
              "PATCH",
              "DELETE"
            ]
          },
          "requestUrl": {
            "type": "string",
            "description": "This is the request URL."
          },
          "requestPath": {
            "type": "string",
            "description": "This is the request path."
          },
          "requestQuery": {
            "type": "string",
            "description": "This is the request query."
          },
          "responseHttpCode": {
            "type": "number",
            "description": "This the HTTP status code of the response."
          },
          "requestIpAddress": {
            "type": "string",
            "description": "This is the request IP address."
          },
          "requestOrigin": {
            "type": "string",
            "description": "This is the origin of the request"
          },
          "responseBody": {
            "type": "object",
            "description": "This is the body of the response."
          },
          "requestHeaders": {
            "type": "object",
            "description": "These are the headers of the request."
          },
          "error": {
            "description": "This is the error, if one occurred.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Error"
              }
            ]
          },
          "assistantId": {
            "type": "string",
            "description": "This is the ID of the assistant."
          },
          "phoneNumberId": {
            "type": "string",
            "description": "This is the ID of the phone number."
          },
          "customerId": {
            "type": "string",
            "description": "This is the ID of the customer."
          },
          "squadId": {
            "type": "string",
            "description": "This is the ID of the squad."
          },
          "callId": {
            "type": "string",
            "description": "This is the ID of the call."
          }
        },
        "required": [
          "time",
          "orgId",
          "type"
        ]
      },
      "LogsPaginatedResponse": {
        "type": "object",
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Log"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/PaginationMeta"
          }
        },
        "required": [
          "results",
          "metadata"
        ]
      },
      "CreateOrgDTO": {
        "type": "object",
        "properties": {
          "hipaaEnabled": {
            "type": "boolean",
            "description": "When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.\nWhen HIPAA is enabled, only OpenAI/Custom LLM or Azure Providers will be available for LLM and Voice respectively.\nThis is due to the compliance requirements of HIPAA. Other providers may not meet these requirements.",
            "example": false
          },
          "subscriptionId": {
            "type": "string",
            "description": "This is the ID of the subscription the org belongs to."
          },
          "name": {
            "type": "string",
            "description": "This is the name of the org. This is just for your own reference.",
            "maxLength": 40
          },
          "channel": {
            "type": "string",
            "description": "This is the channel of the org. There is the cluster the API traffic for the org will be directed.",
            "enum": [
              "default",
              "weekly"
            ]
          },
          "billingLimit": {
            "type": "number",
            "description": "This is the monthly billing limit for the org. To go beyond $1000/mo, please contact us at support@vapi.ai.",
            "minimum": 0,
            "maximum": 1000
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server\n2. phoneNumber.server\n3. org.server",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "concurrencyLimit": {
            "type": "number",
            "description": "This is the concurrency limit for the org. This is the maximum number of calls that can be active at any given time. To go beyond 10, please contact us at support@vapi.ai.",
            "minimum": 1,
            "maximum": 10
          },
          "compliancePlan": {
            "description": "Stores the information about the compliance plan enforced at the organization level. Currently pciEnabled is supported through this field.\nWhen this is enabled, any logs, recordings, or transcriptions will be shipped to the customer endpoints if provided else lost.\nAt the end of the call, you will receive an end-of-call-report message to store on your server, if webhook is provided.\nDefaults to false.\nWhen PCI is enabled, only PCI-compliant Providers will be available for LLM, Voice and transcribers.\nThis is due to the compliance requirements of PCI. Other providers may not meet these requirements.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CompliancePlan"
              }
            ]
          }
        }
      },
      "AutoReloadPlan": {
        "type": "object",
        "properties": {
          "credits": {
            "type": "number",
            "description": "This the amount of credits to reload."
          },
          "threshold": {
            "type": "number",
            "description": "This is the limit at which the reload is triggered."
          }
        },
        "required": [
          "credits",
          "threshold"
        ]
      },
      "InvoicePlan": {
        "type": "object",
        "properties": {
          "companyName": {
            "type": "string",
            "description": "This is the name of the company."
          },
          "companyAddress": {
            "type": "string",
            "description": "This is the address of the company."
          },
          "companyTaxId": {
            "type": "string",
            "description": "This is the tax ID of the company."
          },
          "companyEmail": {
            "type": "string",
            "description": "This is the preferred invoicing email of the company. If not specified, defaults to the subscription's email."
          }
        }
      },
      "Subscription": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the subscription."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the timestamp when the subscription was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the timestamp when the subscription was last updated."
          },
          "type": {
            "type": "string",
            "description": "This is the type / tier of the subscription.",
            "enum": [
              "trial",
              "pay-as-you-go",
              "enterprise",
              "agency",
              "startup",
              "growth",
              "scale"
            ]
          },
          "status": {
            "type": "string",
            "description": "This is the status of the subscription. Past due subscriptions are subscriptions\nwith past due payments.",
            "enum": [
              "active",
              "frozen"
            ]
          },
          "credits": {
            "type": "string",
            "description": "This is the number of credits the subscription currently has.\n\nNote: This is a string to avoid floating point precision issues."
          },
          "concurrencyCounter": {
            "type": "number",
            "description": "This is the total number of active calls (concurrency) across all orgs under this subscription.",
            "minimum": 1
          },
          "concurrencyLimitIncluded": {
            "type": "number",
            "description": "This is the default concurrency limit for the subscription.",
            "minimum": 1
          },
          "phoneNumbersCounter": {
            "type": "number",
            "description": "This is the number of free phone numbers the subscription has",
            "minimum": 1
          },
          "phoneNumbersIncluded": {
            "type": "number",
            "description": "This is the maximum number of free phone numbers the subscription can have",
            "minimum": 1
          },
          "concurrencyLimitPurchased": {
            "type": "number",
            "description": "This is the purchased add-on concurrency limit for the subscription.",
            "minimum": 1
          },
          "monthlyChargeScheduleId": {
            "type": "number",
            "description": "This is the ID of the monthly job that charges for subscription add ons and phone numbers."
          },
          "monthlyCreditCheckScheduleId": {
            "type": "number",
            "description": "This is the ID of the monthly job that checks whether the credit balance of the subscription\nis sufficient for the monthly charge."
          },
          "stripeCustomerId": {
            "type": "string",
            "description": "This is the Stripe customer ID."
          },
          "stripePaymentMethodId": {
            "type": "string",
            "description": "This is the Stripe payment ID."
          },
          "slackSupportEnabled": {
            "type": "boolean",
            "description": "If this flag is true, then the user has purchased slack support."
          },
          "slackChannelId": {
            "type": "string",
            "description": "If this subscription has a slack support subscription, the slack channel's ID will be stored here."
          },
          "hipaaEnabled": {
            "type": "boolean",
            "description": "This is the HIPAA enabled flag for the subscription. It determines whether orgs under this\nsubscription have the option to enable HIPAA compliance."
          },
          "hipaaCommonPaperAgreementId": {
            "type": "string",
            "description": "This is the ID for the Common Paper agreement outlining the HIPAA contract."
          },
          "stripePaymentMethodFingerprint": {
            "type": "string",
            "description": "This is the Stripe fingerprint of the payment method (card). It allows us\nto detect users who try to abuse our system through multiple sign-ups."
          },
          "stripeCustomerEmail": {
            "type": "string",
            "description": "This is the customer's email on Stripe."
          },
          "referredByEmail": {
            "type": "string",
            "description": "This is the email of the referrer for the subscription."
          },
          "autoReloadPlan": {
            "description": "This is the auto reload plan configured for the subscription.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AutoReloadPlan"
              }
            ]
          },
          "minutesIncluded": {
            "type": "number",
            "description": "The number of minutes included in the subscription.",
            "minimum": 0
          },
          "minutesUsed": {
            "type": "number",
            "description": "The number of minutes used in the subscription.",
            "minimum": 0
          },
          "minutesUsedNextResetAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the timestamp at which the number of monthly free minutes is scheduled to reset at."
          },
          "minutesOverageCost": {
            "type": "number",
            "description": "The per minute charge on minutes that exceed the included minutes. Enterprise only."
          },
          "providersIncluded": {
            "description": "The list of providers included in the subscription. Enterprise only.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "outboundCallsDailyLimit": {
            "type": "number",
            "description": "The maximum number of outbound calls this subscription may make in a day. Resets every night.",
            "minimum": 1
          },
          "outboundCallsCounter": {
            "type": "number",
            "description": "The current number of outbound calls the subscription has made in the current day.",
            "minimum": 1
          },
          "outboundCallsCounterNextResetAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the timestamp at which the outbound calls counter is scheduled to reset at."
          },
          "couponIds": {
            "description": "This is the IDs of the coupons applicable to this subscription.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "couponUsageLeft": {
            "type": "string",
            "description": "This is the number of credits left obtained from a coupon."
          },
          "invoicePlan": {
            "description": "This is the invoice plan for the subscription.",
            "allOf": [
              {
                "$ref": "#/components/schemas/InvoicePlan"
              }
            ]
          },
          "pciEnabled": {
            "type": "boolean",
            "description": "This is the PCI enabled flag for the subscription. It determines whether orgs under this\nsubscription have the option to enable PCI compliance."
          },
          "pciCommonPaperAgreementId": {
            "type": "string",
            "description": "This is the ID for the Common Paper agreement outlining the PCI contract."
          }
        },
        "required": [
          "id",
          "createdAt",
          "updatedAt",
          "type",
          "status",
          "credits",
          "concurrencyCounter",
          "concurrencyLimitIncluded",
          "concurrencyLimitPurchased"
        ]
      },
      "OrgPlan": {
        "type": "object",
        "properties": {
          "includedProviders": {
            "type": "array",
            "items": {
              "type": "object"
            }
          },
          "includedMinutes": {
            "type": "number"
          },
          "costPerOverageMinute": {
            "type": "number"
          }
        }
      },
      "Org": {
        "type": "object",
        "properties": {
          "hipaaEnabled": {
            "type": "boolean",
            "description": "When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.\nWhen HIPAA is enabled, only OpenAI/Custom LLM or Azure Providers will be available for LLM and Voice respectively.\nThis is due to the compliance requirements of HIPAA. Other providers may not meet these requirements.",
            "example": false
          },
          "subscription": {
            "$ref": "#/components/schemas/Subscription"
          },
          "subscriptionId": {
            "type": "string",
            "description": "This is the ID of the subscription the org belongs to."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the org."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the org was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the org was last updated."
          },
          "stripeCustomerId": {
            "type": "string",
            "description": "This is the Stripe customer for the org."
          },
          "stripeSubscriptionId": {
            "type": "string",
            "description": "This is the subscription for the org."
          },
          "stripeSubscriptionItemId": {
            "type": "string",
            "description": "This is the subscription's subscription item."
          },
          "stripeSubscriptionCurrentPeriodStart": {
            "format": "date-time",
            "type": "string",
            "description": "This is the subscription's current period start."
          },
          "stripeSubscriptionStatus": {
            "type": "string",
            "description": "This is the subscription's status."
          },
          "plan": {
            "description": "This is the plan for the org.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OrgPlan"
              }
            ]
          },
          "jwtSecret": {
            "type": "string",
            "description": "This is the secret key used for signing JWT tokens for the org."
          },
          "minutesUsed": {
            "type": "number",
            "description": "This is the total number of call minutes used by this org across all time."
          },
          "name": {
            "type": "string",
            "description": "This is the name of the org. This is just for your own reference.",
            "maxLength": 40
          },
          "channel": {
            "type": "string",
            "description": "This is the channel of the org. There is the cluster the API traffic for the org will be directed.",
            "enum": [
              "default",
              "weekly"
            ]
          },
          "billingLimit": {
            "type": "number",
            "description": "This is the monthly billing limit for the org. To go beyond $1000/mo, please contact us at support@vapi.ai.",
            "minimum": 0,
            "maximum": 1000
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server\n2. phoneNumber.server\n3. org.server",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "concurrencyLimit": {
            "type": "number",
            "description": "This is the concurrency limit for the org. This is the maximum number of calls that can be active at any given time. To go beyond 10, please contact us at support@vapi.ai.",
            "minimum": 1,
            "maximum": 10
          },
          "compliancePlan": {
            "description": "Stores the information about the compliance plan enforced at the organization level. Currently pciEnabled is supported through this field.\nWhen this is enabled, any logs, recordings, or transcriptions will be shipped to the customer endpoints if provided else lost.\nAt the end of the call, you will receive an end-of-call-report message to store on your server, if webhook is provided.\nDefaults to false.\nWhen PCI is enabled, only PCI-compliant Providers will be available for LLM, Voice and transcribers.\nThis is due to the compliance requirements of PCI. Other providers may not meet these requirements.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CompliancePlan"
              }
            ]
          }
        },
        "required": [
          "id",
          "createdAt",
          "updatedAt"
        ]
      },
      "UpdateOrgDTO": {
        "type": "object",
        "properties": {
          "hipaaEnabled": {
            "type": "boolean",
            "description": "When this is enabled, no logs, recordings, or transcriptions will be stored. At the end of the call, you will still receive an end-of-call-report message to store on your server. Defaults to false.\nWhen HIPAA is enabled, only OpenAI/Custom LLM or Azure Providers will be available for LLM and Voice respectively.\nThis is due to the compliance requirements of HIPAA. Other providers may not meet these requirements.",
            "example": false
          },
          "subscriptionId": {
            "type": "string",
            "description": "This is the ID of the subscription the org belongs to."
          },
          "name": {
            "type": "string",
            "description": "This is the name of the org. This is just for your own reference.",
            "maxLength": 40
          },
          "channel": {
            "type": "string",
            "description": "This is the channel of the org. There is the cluster the API traffic for the org will be directed.",
            "enum": [
              "default",
              "weekly"
            ]
          },
          "billingLimit": {
            "type": "number",
            "description": "This is the monthly billing limit for the org. To go beyond $1000/mo, please contact us at support@vapi.ai.",
            "minimum": 0,
            "maximum": 1000
          },
          "server": {
            "description": "This is where Vapi will send webhooks. You can find all webhooks available along with their shape in ServerMessage schema.\n\nThe order of precedence is:\n\n1. assistant.server\n2. phoneNumber.server\n3. org.server",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "concurrencyLimit": {
            "type": "number",
            "description": "This is the concurrency limit for the org. This is the maximum number of calls that can be active at any given time. To go beyond 10, please contact us at support@vapi.ai.",
            "minimum": 1,
            "maximum": 10
          },
          "compliancePlan": {
            "description": "Stores the information about the compliance plan enforced at the organization level. Currently pciEnabled is supported through this field.\nWhen this is enabled, any logs, recordings, or transcriptions will be shipped to the customer endpoints if provided else lost.\nAt the end of the call, you will receive an end-of-call-report message to store on your server, if webhook is provided.\nDefaults to false.\nWhen PCI is enabled, only PCI-compliant Providers will be available for LLM, Voice and transcribers.\nThis is due to the compliance requirements of PCI. Other providers may not meet these requirements.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CompliancePlan"
              }
            ]
          }
        }
      },
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the profile or user."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the profile was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the profile was last updated."
          },
          "email": {
            "type": "string",
            "description": "This is the email of the user that is associated with the profile."
          },
          "fullName": {
            "type": "string",
            "description": "This is the full name of the user that is associated with the profile."
          }
        },
        "required": [
          "id",
          "createdAt",
          "updatedAt",
          "email"
        ]
      },
      "InviteUserDTO": {
        "type": "object",
        "properties": {
          "emails": {
            "maxItems": 100,
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "role": {
            "enum": [
              "admin",
              "editor",
              "viewer"
            ],
            "type": "string"
          },
          "redirectTo": {
            "type": "string"
          }
        },
        "required": [
          "emails",
          "role"
        ]
      },
      "UpdateUserRoleDTO": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "string"
          },
          "role": {
            "enum": [
              "admin",
              "editor",
              "viewer"
            ],
            "type": "string"
          }
        },
        "required": [
          "userId",
          "role"
        ]
      },
      "JwtResponse": {
        "type": "object",
        "properties": {
          "accessToken": {
            "type": "string"
          },
          "aud": {
            "type": "object"
          }
        },
        "required": [
          "accessToken",
          "aud"
        ]
      },
      "TokenRestrictions": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "This determines whether the token is enabled or disabled. Default is true, it's enabled."
          },
          "allowedOrigins": {
            "description": "This determines the allowed origins for this token. Validates the `Origin` header. Default is any origin.\n\nOnly relevant for `public` tokens.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "allowedAssistantIds": {
            "description": "This determines which assistantIds can be used when creating a call. Default is any assistantId.\n\nOnly relevant for `public` tokens.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "allowTransientAssistant": {
            "type": "boolean",
            "description": "This determines whether transient assistants can be used when creating a call. Default is true.\n\nIf `allowedAssistantIds` is provided, this is automatically false.\n\nOnly relevant for `public` tokens."
          }
        }
      },
      "CreateTokenDTO": {
        "type": "object",
        "properties": {
          "tag": {
            "type": "string",
            "description": "This is the tag for the token. It represents its scope.",
            "enum": [
              "private",
              "public"
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of the token. This is just for your own reference.",
            "maxLength": 40
          },
          "restrictions": {
            "description": "This are the restrictions for the token.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TokenRestrictions"
              }
            ]
          }
        }
      },
      "Token": {
        "type": "object",
        "properties": {
          "tag": {
            "type": "string",
            "description": "This is the tag for the token. It represents its scope.",
            "enum": [
              "private",
              "public"
            ]
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the token."
          },
          "orgId": {
            "type": "string",
            "description": "This is unique identifier for the org that this token belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the token was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the token was last updated."
          },
          "value": {
            "type": "string",
            "description": "This is the token key."
          },
          "name": {
            "type": "string",
            "description": "This is the name of the token. This is just for your own reference.",
            "maxLength": 40
          },
          "restrictions": {
            "description": "This are the restrictions for the token.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TokenRestrictions"
              }
            ]
          }
        },
        "required": [
          "id",
          "orgId",
          "createdAt",
          "updatedAt",
          "value"
        ]
      },
      "UpdateTokenDTO": {
        "type": "object",
        "properties": {
          "tag": {
            "type": "string",
            "description": "This is the tag for the token. It represents its scope.",
            "enum": [
              "private",
              "public"
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of the token. This is just for your own reference.",
            "maxLength": 40
          },
          "restrictions": {
            "description": "This are the restrictions for the token.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TokenRestrictions"
              }
            ]
          }
        }
      },
      "AnthropicCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "anthropic"
            ]
          },
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "AnyscaleCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "anyscale"
            ]
          },
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "AssemblyAICredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "assembly-ai"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "AzureCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "azure"
            ]
          },
          "service": {
            "type": "string",
            "description": "This is the service being used in Azure.",
            "enum": [
              "speech",
              "blob_storage"
            ],
            "default": "speech"
          },
          "region": {
            "type": "string",
            "description": "This is the region of the Azure resource.",
            "enum": [
              "australia",
              "canadaeast",
              "canadacentral",
              "eastus2",
              "eastus",
              "france",
              "india",
              "japaneast",
              "japanwest",
              "uaenorth",
              "northcentralus",
              "norway",
              "southcentralus",
              "swedencentral",
              "switzerland",
              "uk",
              "westus",
              "westus3"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API.",
            "maxLength": 10000
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          },
          "bucketPlan": {
            "description": "This is the bucket plan that can be provided to store call artifacts in Azure Blob Storage.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AzureBlobStorageBucketPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "service",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "AzureOpenAICredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "azure-openai"
            ]
          },
          "region": {
            "type": "string",
            "enum": [
              "australia",
              "canadaeast",
              "canadacentral",
              "eastus2",
              "eastus",
              "france",
              "india",
              "japaneast",
              "japanwest",
              "uaenorth",
              "northcentralus",
              "norway",
              "southcentralus",
              "swedencentral",
              "switzerland",
              "uk",
              "westus",
              "westus3"
            ]
          },
          "models": {
            "type": "array",
            "enum": [
              "gpt-4.1-2025-04-14",
              "gpt-4.1-mini-2025-04-14",
              "gpt-4.1-nano-2025-04-14",
              "gpt-4o-2024-11-20",
              "gpt-4o-2024-08-06",
              "gpt-4o-2024-05-13",
              "gpt-4o-mini-2024-07-18",
              "gpt-4-turbo-2024-04-09",
              "gpt-4-0125-preview",
              "gpt-4-1106-preview",
              "gpt-4-0613",
              "gpt-35-turbo-0125",
              "gpt-35-turbo-1106"
            ],
            "example": [
              "gpt-4-0125-preview",
              "gpt-4-0613"
            ],
            "items": {
              "type": "string",
              "enum": [
                "gpt-4.1-2025-04-14",
                "gpt-4.1-mini-2025-04-14",
                "gpt-4.1-nano-2025-04-14",
                "gpt-4o-2024-11-20",
                "gpt-4o-2024-08-06",
                "gpt-4o-2024-05-13",
                "gpt-4o-mini-2024-07-18",
                "gpt-4-turbo-2024-04-09",
                "gpt-4-0125-preview",
                "gpt-4-1106-preview",
                "gpt-4-0613",
                "gpt-35-turbo-0125",
                "gpt-35-turbo-1106"
              ]
            }
          },
          "openAIKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "ocpApimSubscriptionKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          },
          "openAIEndpoint": {
            "type": "string",
            "maxLength": 10000
          }
        },
        "required": [
          "provider",
          "region",
          "models",
          "openAIKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt",
          "openAIEndpoint"
        ]
      },
      "ByoSipTrunkCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This can be used to bring your own SIP trunks or to connect to a Carrier.",
            "enum": [
              "byo-sip-trunk"
            ]
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          },
          "gateways": {
            "description": "This is the list of SIP trunk's gateways.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SipTrunkGateway"
            }
          },
          "outboundAuthenticationPlan": {
            "description": "This can be used to configure the outbound authentication if required by the SIP trunk.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SipTrunkOutboundAuthenticationPlan"
              }
            ]
          },
          "outboundLeadingPlusEnabled": {
            "type": "boolean",
            "description": "This ensures the outbound origination attempts have a leading plus. Defaults to false to match conventional telecom behavior.\n\nUsage:\n- Vonage/Twilio requires leading plus for all outbound calls. Set this to true.\n\n@default false"
          },
          "techPrefix": {
            "type": "string",
            "description": "This can be used to configure the tech prefix on outbound calls. This is an advanced property.",
            "maxLength": 10000
          },
          "sipDiversionHeader": {
            "type": "string",
            "description": "This can be used to enable the SIP diversion header for authenticating the calling number if the SIP trunk supports it. This is an advanced property.",
            "maxLength": 10000
          },
          "sbcConfiguration": {
            "description": "This is an advanced configuration for enterprise deployments. This uses the onprem SBC to trunk into the SIP trunk's `gateways`, rather than the managed SBC provided by Vapi.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SbcConfiguration"
              }
            ]
          }
        },
        "required": [
          "id",
          "orgId",
          "createdAt",
          "updatedAt",
          "gateways"
        ]
      },
      "CartesiaCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "cartesia"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "CerebrasCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "cerebras"
            ]
          },
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "CloudflareCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "cloudflare"
            ],
            "description": "Credential provider. Only allowed value is cloudflare"
          },
          "accountId": {
            "type": "string",
            "description": "Cloudflare Account Id."
          },
          "apiKey": {
            "type": "string",
            "description": "Cloudflare API Key / Token."
          },
          "accountEmail": {
            "type": "string",
            "description": "Cloudflare Account Email."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          },
          "bucketPlan": {
            "description": "This is the bucket plan that can be provided to store call artifacts in R2",
            "allOf": [
              {
                "$ref": "#/components/schemas/CloudflareR2BucketPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "Oauth2AuthenticationSession": {
        "type": "object",
        "properties": {
          "accessToken": {
            "type": "string",
            "description": "This is the OAuth2 access token."
          },
          "expiresAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the OAuth2 access token expiration."
          },
          "refreshToken": {
            "type": "string",
            "description": "This is the OAuth2 refresh token."
          }
        }
      },
      "CustomLLMCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "custom-llm"
            ]
          },
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "authenticationPlan": {
            "description": "This is the authentication plan. Currently supports OAuth2 RFC 6749. To use Bearer authentication, use apiKey",
            "allOf": [
              {
                "$ref": "#/components/schemas/OAuth2AuthenticationPlan"
              }
            ]
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "authenticationSession": {
            "description": "This is the authentication session for the credential. Available for credentials that have an authentication plan.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Oauth2AuthenticationSession"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "DeepgramCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "deepgram"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          },
          "apiUrl": {
            "type": "string",
            "description": "This can be used to point to an onprem Deepgram instance. Defaults to api.deepgram.com."
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "DeepInfraCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "deepinfra"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "DeepSeekCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "deep-seek"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "ElevenLabsCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "11labs"
            ]
          },
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "GcpCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "gcp"
            ]
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          },
          "gcpKey": {
            "description": "This is the GCP key. This is the JSON that can be generated in the Google Cloud Console at https://console.cloud.google.com/iam-admin/serviceaccounts/details/<service-account-id>/keys.\n\nThe schema is identical to the JSON that GCP outputs.",
            "allOf": [
              {
                "$ref": "#/components/schemas/GcpKey"
              }
            ]
          },
          "bucketPlan": {
            "description": "This is the bucket plan that can be provided to store call artifacts in GCP.",
            "allOf": [
              {
                "$ref": "#/components/schemas/BucketPlan"
              }
            ]
          }
        },
        "required": [
          "provider",
          "id",
          "orgId",
          "createdAt",
          "updatedAt",
          "gcpKey"
        ]
      },
      "GladiaCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "gladia"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "GoHighLevelCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "gohighlevel"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "GoogleCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the key for Gemini in Google AI Studio. Get it from here: https://aistudio.google.com/app/apikey",
            "enum": [
              "google"
            ]
          },
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "GroqCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "groq"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "HumeCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "hume"
            ]
          },
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "InflectionAICredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the api key for Pi in InflectionAI's console. Get it from here: https://developers.inflection.ai/keys, billing will need to be setup",
            "enum": [
              "inflection-ai"
            ]
          },
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "LangfuseCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "langfuse"
            ]
          },
          "publicKey": {
            "type": "string",
            "description": "The public key for Langfuse project. Eg: pk-lf-..."
          },
          "apiKey": {
            "type": "string",
            "description": "The secret key for Langfuse project. Eg: sk-lf-... .This is not returned in the API."
          },
          "apiUrl": {
            "type": "string",
            "description": "The host URL for Langfuse project. Eg: https://cloud.langfuse.com"
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "publicKey",
          "apiKey",
          "apiUrl",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "LmntCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "lmnt"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "MakeCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "make"
            ]
          },
          "teamId": {
            "type": "string",
            "description": "Team ID"
          },
          "region": {
            "type": "string",
            "description": "Region of your application. For example: eu1, eu2, us1, us2"
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "teamId",
          "region",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "MistralCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "mistral"
            ]
          },
          "apiKey": {
            "type": "string",
            "maxLength": 100,
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "NeuphonicCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "neuphonic"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "OpenAICredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "openai"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "OpenRouterCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "openrouter"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "PerplexityAICredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "perplexity-ai"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "PlayHTCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "playht"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          },
          "userId": {
            "type": "string"
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt",
          "userId"
        ]
      },
      "RimeAICredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "rime-ai"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "RunpodCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "runpod"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "S3Credential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "s3"
            ],
            "description": "Credential provider. Only allowed value is s3"
          },
          "awsAccessKeyId": {
            "type": "string",
            "description": "AWS access key ID."
          },
          "awsSecretAccessKey": {
            "type": "string",
            "description": "AWS access key secret. This is not returned in the API."
          },
          "region": {
            "type": "string",
            "description": "AWS region in which the S3 bucket is located."
          },
          "s3BucketName": {
            "type": "string",
            "description": "AWS S3 bucket name."
          },
          "s3PathPrefix": {
            "type": "string",
            "description": "The path prefix for the uploaded recording. Ex. \"recordings/\""
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "awsAccessKeyId",
          "awsSecretAccessKey",
          "region",
          "s3BucketName",
          "s3PathPrefix",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "SmallestAICredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "smallest-ai"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "SpeechmaticsCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "speechmatics"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "SupabaseCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "supabase"
            ],
            "description": "This is for supabase storage."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          },
          "bucketPlan": {
            "$ref": "#/components/schemas/SupabaseBucketPlan"
          }
        },
        "required": [
          "provider",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "TavusCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "tavus"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "TogetherAICredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "together-ai"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "TrieveCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "trieve"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "TwilioCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "twilio"
            ]
          },
          "authToken": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "apiSecret": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          },
          "accountSid": {
            "type": "string"
          }
        },
        "required": [
          "provider",
          "id",
          "orgId",
          "createdAt",
          "updatedAt",
          "accountSid"
        ]
      },
      "VonageCredential": {
        "type": "object",
        "properties": {
          "vonageApplicationPrivateKey": {
            "type": "string",
            "description": "This is not returned in the API.",
            "maxLength": 10000
          },
          "provider": {
            "type": "string",
            "enum": [
              "vonage"
            ]
          },
          "apiSecret": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "vonageApplicationId": {
            "type": "string",
            "description": "This is the Vonage Application ID for the credential.\n\nOnly relevant for Vonage credentials.",
            "maxLength": 10000
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          },
          "apiKey": {
            "type": "string"
          }
        },
        "required": [
          "vonageApplicationPrivateKey",
          "provider",
          "apiSecret",
          "id",
          "orgId",
          "createdAt",
          "updatedAt",
          "vonageApplicationId",
          "apiKey"
        ]
      },
      "WebhookCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "webhook"
            ]
          },
          "authenticationPlan": {
            "description": "This is the authentication plan. Currently supports OAuth2 RFC 6749.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OAuth2AuthenticationPlan"
              }
            ]
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "authenticationSession": {
            "description": "This is the authentication session for the credential. Available for credentials that have an authentication plan.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Oauth2AuthenticationSession"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "authenticationPlan",
          "id",
          "orgId",
          "createdAt",
          "updatedAt",
          "authenticationSession"
        ]
      },
      "XAiCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the api key for Grok in XAi's console. Get it from here: https://console.x.ai",
            "enum": [
              "xai"
            ]
          },
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "GoogleCalendarOAuth2ClientCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "google.calendar.oauth2-client"
            ]
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "GoogleCalendarOAuth2AuthorizationCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "google.calendar.oauth2-authorization"
            ]
          },
          "authorizationId": {
            "type": "string",
            "description": "The authorization ID for the OAuth2 authorization"
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "authorizationId",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "GoogleSheetsOAuth2AuthorizationCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "google.sheets.oauth2-authorization"
            ]
          },
          "authorizationId": {
            "type": "string",
            "description": "The authorization ID for the OAuth2 authorization"
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "authorizationId",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "SlackOAuth2AuthorizationCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "slack.oauth2-authorization"
            ]
          },
          "authorizationId": {
            "type": "string",
            "description": "The authorization ID for the OAuth2 authorization"
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "authorizationId",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "GoHighLevelMCPCredential": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "ghl.oauth2-authorization"
            ]
          },
          "authenticationSession": {
            "description": "This is the authentication session for the credential.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Oauth2AuthenticationSession"
              }
            ]
          },
          "id": {
            "type": "string",
            "description": "This is the unique identifier for the credential."
          },
          "orgId": {
            "type": "string",
            "description": "This is the unique identifier for the org that this credential belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the credential was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the assistant was last updated."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "authenticationSession",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "CreateCerebrasCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "cerebras"
            ]
          },
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateGoogleCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the key for Gemini in Google AI Studio. Get it from here: https://aistudio.google.com/app/apikey",
            "enum": [
              "google"
            ]
          },
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateHumeCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "hume"
            ]
          },
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateInflectionAICredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "description": "This is the api key for Pi in InflectionAI's console. Get it from here: https://developers.inflection.ai/keys, billing will need to be setup",
            "enum": [
              "inflection-ai"
            ]
          },
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateMistralCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "mistral"
            ]
          },
          "apiKey": {
            "type": "string",
            "maxLength": 100,
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateNeuphonicCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "neuphonic"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateSpeechmaticsCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "speechmatics"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateTrieveCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "trieve"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "apiKey"
        ]
      },
      "CreateGoHighLevelMCPCredentialDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "ghl.oauth2-authorization"
            ]
          },
          "authenticationSession": {
            "description": "This is the authentication session for the credential.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Oauth2AuthenticationSession"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        },
        "required": [
          "provider",
          "authenticationSession"
        ]
      },
      "UpdateAnthropicCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateAnyscaleCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateAssemblyAICredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateAzureCredentialDTO": {
        "type": "object",
        "properties": {
          "service": {
            "type": "string",
            "description": "This is the service being used in Azure.",
            "enum": [
              "speech",
              "blob_storage"
            ],
            "default": "speech"
          },
          "region": {
            "type": "string",
            "description": "This is the region of the Azure resource.",
            "enum": [
              "australia",
              "canadaeast",
              "canadacentral",
              "eastus2",
              "eastus",
              "france",
              "india",
              "japaneast",
              "japanwest",
              "uaenorth",
              "northcentralus",
              "norway",
              "southcentralus",
              "swedencentral",
              "switzerland",
              "uk",
              "westus",
              "westus3"
            ]
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API.",
            "maxLength": 10000
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          },
          "bucketPlan": {
            "description": "This is the bucket plan that can be provided to store call artifacts in Azure Blob Storage.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AzureBlobStorageBucketPlan"
              }
            ]
          }
        }
      },
      "UpdateAzureOpenAICredentialDTO": {
        "type": "object",
        "properties": {
          "region": {
            "type": "string",
            "enum": [
              "australia",
              "canadaeast",
              "canadacentral",
              "eastus2",
              "eastus",
              "france",
              "india",
              "japaneast",
              "japanwest",
              "uaenorth",
              "northcentralus",
              "norway",
              "southcentralus",
              "swedencentral",
              "switzerland",
              "uk",
              "westus",
              "westus3"
            ]
          },
          "models": {
            "type": "array",
            "enum": [
              "gpt-4.1-2025-04-14",
              "gpt-4.1-mini-2025-04-14",
              "gpt-4.1-nano-2025-04-14",
              "gpt-4o-2024-11-20",
              "gpt-4o-2024-08-06",
              "gpt-4o-2024-05-13",
              "gpt-4o-mini-2024-07-18",
              "gpt-4-turbo-2024-04-09",
              "gpt-4-0125-preview",
              "gpt-4-1106-preview",
              "gpt-4-0613",
              "gpt-35-turbo-0125",
              "gpt-35-turbo-1106"
            ],
            "example": [
              "gpt-4-0125-preview",
              "gpt-4-0613"
            ],
            "items": {
              "type": "string",
              "enum": [
                "gpt-4.1-2025-04-14",
                "gpt-4.1-mini-2025-04-14",
                "gpt-4.1-nano-2025-04-14",
                "gpt-4o-2024-11-20",
                "gpt-4o-2024-08-06",
                "gpt-4o-2024-05-13",
                "gpt-4o-mini-2024-07-18",
                "gpt-4-turbo-2024-04-09",
                "gpt-4-0125-preview",
                "gpt-4-1106-preview",
                "gpt-4-0613",
                "gpt-35-turbo-0125",
                "gpt-35-turbo-1106"
              ]
            }
          },
          "openAIKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "ocpApimSubscriptionKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          },
          "openAIEndpoint": {
            "type": "string",
            "maxLength": 10000
          }
        }
      },
      "UpdateByoSipTrunkCredentialDTO": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          },
          "gateways": {
            "description": "This is the list of SIP trunk's gateways.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SipTrunkGateway"
            }
          },
          "outboundAuthenticationPlan": {
            "description": "This can be used to configure the outbound authentication if required by the SIP trunk.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SipTrunkOutboundAuthenticationPlan"
              }
            ]
          },
          "outboundLeadingPlusEnabled": {
            "type": "boolean",
            "description": "This ensures the outbound origination attempts have a leading plus. Defaults to false to match conventional telecom behavior.\n\nUsage:\n- Vonage/Twilio requires leading plus for all outbound calls. Set this to true.\n\n@default false"
          },
          "techPrefix": {
            "type": "string",
            "description": "This can be used to configure the tech prefix on outbound calls. This is an advanced property.",
            "maxLength": 10000
          },
          "sipDiversionHeader": {
            "type": "string",
            "description": "This can be used to enable the SIP diversion header for authenticating the calling number if the SIP trunk supports it. This is an advanced property.",
            "maxLength": 10000
          },
          "sbcConfiguration": {
            "description": "This is an advanced configuration for enterprise deployments. This uses the onprem SBC to trunk into the SIP trunk's `gateways`, rather than the managed SBC provided by Vapi.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SbcConfiguration"
              }
            ]
          }
        }
      },
      "UpdateCartesiaCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateCerebrasCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateCloudflareCredentialDTO": {
        "type": "object",
        "properties": {
          "accountId": {
            "type": "string",
            "description": "Cloudflare Account Id."
          },
          "apiKey": {
            "type": "string",
            "description": "Cloudflare API Key / Token."
          },
          "accountEmail": {
            "type": "string",
            "description": "Cloudflare Account Email."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          },
          "bucketPlan": {
            "description": "This is the bucket plan that can be provided to store call artifacts in R2",
            "allOf": [
              {
                "$ref": "#/components/schemas/CloudflareR2BucketPlan"
              }
            ]
          }
        }
      },
      "UpdateCustomLLMCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "authenticationPlan": {
            "description": "This is the authentication plan. Currently supports OAuth2 RFC 6749. To use Bearer authentication, use apiKey",
            "allOf": [
              {
                "$ref": "#/components/schemas/OAuth2AuthenticationPlan"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateDeepgramCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          },
          "apiUrl": {
            "type": "string",
            "description": "This can be used to point to an onprem Deepgram instance. Defaults to api.deepgram.com."
          }
        }
      },
      "UpdateDeepInfraCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateDeepSeekCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateElevenLabsCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateGcpCredentialDTO": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          },
          "gcpKey": {
            "description": "This is the GCP key. This is the JSON that can be generated in the Google Cloud Console at https://console.cloud.google.com/iam-admin/serviceaccounts/details/<service-account-id>/keys.\n\nThe schema is identical to the JSON that GCP outputs.",
            "allOf": [
              {
                "$ref": "#/components/schemas/GcpKey"
              }
            ]
          },
          "bucketPlan": {
            "description": "This is the bucket plan that can be provided to store call artifacts in GCP.",
            "allOf": [
              {
                "$ref": "#/components/schemas/BucketPlan"
              }
            ]
          }
        }
      },
      "UpdateGladiaCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateGoHighLevelCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateGoogleCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateGroqCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateHumeCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateInflectionAICredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateLangfuseCredentialDTO": {
        "type": "object",
        "properties": {
          "publicKey": {
            "type": "string",
            "description": "The public key for Langfuse project. Eg: pk-lf-..."
          },
          "apiKey": {
            "type": "string",
            "description": "The secret key for Langfuse project. Eg: sk-lf-... .This is not returned in the API."
          },
          "apiUrl": {
            "type": "string",
            "description": "The host URL for Langfuse project. Eg: https://cloud.langfuse.com"
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateLmntCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateMakeCredentialDTO": {
        "type": "object",
        "properties": {
          "teamId": {
            "type": "string",
            "description": "Team ID"
          },
          "region": {
            "type": "string",
            "description": "Region of your application. For example: eu1, eu2, us1, us2"
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateMistralCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "maxLength": 100,
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateNeuphonicCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateOpenAICredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateOpenRouterCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdatePerplexityAICredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdatePlayHTCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          },
          "userId": {
            "type": "string"
          }
        }
      },
      "UpdateRimeAICredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateRunpodCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateS3CredentialDTO": {
        "type": "object",
        "properties": {
          "awsAccessKeyId": {
            "type": "string",
            "description": "AWS access key ID."
          },
          "awsSecretAccessKey": {
            "type": "string",
            "description": "AWS access key secret. This is not returned in the API."
          },
          "region": {
            "type": "string",
            "description": "AWS region in which the S3 bucket is located."
          },
          "s3BucketName": {
            "type": "string",
            "description": "AWS S3 bucket name."
          },
          "s3PathPrefix": {
            "type": "string",
            "description": "The path prefix for the uploaded recording. Ex. \"recordings/\""
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateSmallestAICredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateSpeechmaticsCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateSupabaseCredentialDTO": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          },
          "bucketPlan": {
            "$ref": "#/components/schemas/SupabaseBucketPlan"
          }
        }
      },
      "UpdateTavusCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateTogetherAICredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateTrieveCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateTwilioCredentialDTO": {
        "type": "object",
        "properties": {
          "authToken": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "apiKey": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "apiSecret": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          },
          "accountSid": {
            "type": "string"
          }
        }
      },
      "UpdateVonageCredentialDTO": {
        "type": "object",
        "properties": {
          "apiSecret": {
            "type": "string",
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          },
          "apiKey": {
            "type": "string"
          }
        }
      },
      "UpdateWebhookCredentialDTO": {
        "type": "object",
        "properties": {
          "authenticationPlan": {
            "description": "This is the authentication plan. Currently supports OAuth2 RFC 6749.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OAuth2AuthenticationPlan"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateXAiCredentialDTO": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string",
            "maxLength": 10000,
            "description": "This is not returned in the API."
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateGoogleCalendarOAuth2ClientCredentialDTO": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateGoogleCalendarOAuth2AuthorizationCredentialDTO": {
        "type": "object",
        "properties": {
          "authorizationId": {
            "type": "string",
            "description": "The authorization ID for the OAuth2 authorization"
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateGoogleSheetsOAuth2AuthorizationCredentialDTO": {
        "type": "object",
        "properties": {
          "authorizationId": {
            "type": "string",
            "description": "The authorization ID for the OAuth2 authorization"
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateSlackOAuth2AuthorizationCredentialDTO": {
        "type": "object",
        "properties": {
          "authorizationId": {
            "type": "string",
            "description": "The authorization ID for the OAuth2 authorization"
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "UpdateGoHighLevelMCPCredentialDTO": {
        "type": "object",
        "properties": {
          "authenticationSession": {
            "description": "This is the authentication session for the credential.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Oauth2AuthenticationSession"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of credential. This is just for your reference.",
            "minLength": 1,
            "maxLength": 40
          }
        }
      },
      "CredentialSessionResponse": {
        "type": "object",
        "properties": {
          "sessionToken": {
            "type": "string"
          }
        },
        "required": [
          "sessionToken"
        ]
      },
      "CredentialEndUser": {
        "type": "object",
        "properties": {
          "endUserId": {
            "type": "string"
          },
          "organizationId": {
            "type": "string"
          }
        },
        "required": [
          "endUserId",
          "organizationId"
        ]
      },
      "CredentialSessionError": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          },
          "description": {
            "type": "string"
          }
        },
        "required": [
          "type",
          "description"
        ]
      },
      "CredentialWebhookDTO": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "auth",
              "sync",
              "forward"
            ]
          },
          "operation": {
            "type": "string",
            "enum": [
              "creation",
              "override",
              "refresh"
            ]
          },
          "from": {
            "type": "string"
          },
          "connectionId": {
            "type": "string"
          },
          "authMode": {
            "type": "string",
            "enum": [
              "OAUTH2",
              "API_KEY",
              "BASIC"
            ]
          },
          "providerConfigKey": {
            "type": "string"
          },
          "provider": {
            "type": "string"
          },
          "environment": {
            "type": "string"
          },
          "success": {
            "type": "boolean"
          },
          "endUser": {
            "$ref": "#/components/schemas/CredentialEndUser"
          },
          "error": {
            "$ref": "#/components/schemas/CredentialSessionError"
          }
        },
        "required": [
          "type",
          "operation",
          "from",
          "connectionId",
          "authMode",
          "providerConfigKey",
          "provider",
          "environment",
          "success",
          "endUser"
        ]
      },
      "CredentialActionRequest": {
        "type": "object",
        "properties": {
          "action_name": {
            "type": "string"
          },
          "input": {
            "type": "object"
          }
        },
        "required": [
          "action_name",
          "input"
        ]
      },
      "CredentialSessionDTO": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "enum": [
              "google.calendar.oauth2-client",
              "google.calendar.oauth2-authorization",
              "google.sheets.oauth2-authorization",
              "slack.oauth2-authorization"
            ],
            "description": "The type of credential to generate a session for. Only Nango user-facing providers are supported."
          }
        },
        "required": [
          "provider"
        ]
      },
      "ToolTemplateSetup": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "videoUrl": {
            "type": "string"
          },
          "docsUrl": {
            "type": "string"
          }
        },
        "required": [
          "title"
        ]
      },
      "MakeToolProviderDetails": {
        "type": "object",
        "properties": {
          "templateUrl": {
            "type": "string",
            "description": "This is the Template URL or the Snapshot URL corresponding to the Template."
          },
          "setupInstructions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ToolTemplateSetup"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "make"
            ],
            "description": "The type of tool. \"make\" for Make tool."
          },
          "scenarioId": {
            "type": "number"
          },
          "scenarioName": {
            "type": "string"
          },
          "triggerHookId": {
            "type": "number"
          },
          "triggerHookName": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "GhlToolProviderDetails": {
        "type": "object",
        "properties": {
          "templateUrl": {
            "type": "string",
            "description": "This is the Template URL or the Snapshot URL corresponding to the Template."
          },
          "setupInstructions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ToolTemplateSetup"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "ghl"
            ],
            "description": "The type of tool. \"ghl\" for GHL tool."
          },
          "workflowId": {
            "type": "string"
          },
          "workflowName": {
            "type": "string"
          },
          "webhookHookId": {
            "type": "string"
          },
          "webhookHookName": {
            "type": "string"
          },
          "locationId": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "FunctionToolProviderDetails": {
        "type": "object",
        "properties": {
          "templateUrl": {
            "type": "string",
            "description": "This is the Template URL or the Snapshot URL corresponding to the Template."
          },
          "setupInstructions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ToolTemplateSetup"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "function"
            ],
            "description": "The type of tool. \"function\" for Function tool."
          }
        },
        "required": [
          "type"
        ]
      },
      "GoogleCalendarCreateEventToolProviderDetails": {
        "type": "object",
        "properties": {
          "templateUrl": {
            "type": "string",
            "description": "This is the Template URL or the Snapshot URL corresponding to the Template."
          },
          "setupInstructions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ToolTemplateSetup"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "google.calendar.event.create"
            ],
            "description": "The type of tool. \"google.calendar.event.create\" for Google Calendar tool."
          }
        },
        "required": [
          "type"
        ]
      },
      "GoogleSheetsRowAppendToolProviderDetails": {
        "type": "object",
        "properties": {
          "templateUrl": {
            "type": "string",
            "description": "This is the Template URL or the Snapshot URL corresponding to the Template."
          },
          "setupInstructions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ToolTemplateSetup"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "google.sheets.row.append"
            ],
            "description": "The type of tool. \"google.sheets.row.append\" for Google Sheets tool."
          }
        },
        "required": [
          "type"
        ]
      },
      "GoHighLevelCalendarAvailabilityToolProviderDetails": {
        "type": "object",
        "properties": {
          "templateUrl": {
            "type": "string",
            "description": "This is the Template URL or the Snapshot URL corresponding to the Template."
          },
          "setupInstructions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ToolTemplateSetup"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "gohighlevel.calendar.availability.check"
            ],
            "description": "The type of tool. \"gohighlevel.calendar.availability.check\" for GoHighLevel Calendar availability check tool."
          }
        },
        "required": [
          "type"
        ]
      },
      "GoHighLevelCalendarEventCreateToolProviderDetails": {
        "type": "object",
        "properties": {
          "templateUrl": {
            "type": "string",
            "description": "This is the Template URL or the Snapshot URL corresponding to the Template."
          },
          "setupInstructions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ToolTemplateSetup"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "gohighlevel.calendar.event.create"
            ],
            "description": "The type of tool. \"gohighlevel.calendar.event.create\" for GoHighLevel Calendar event create tool."
          }
        },
        "required": [
          "type"
        ]
      },
      "GoHighLevelContactCreateToolProviderDetails": {
        "type": "object",
        "properties": {
          "templateUrl": {
            "type": "string",
            "description": "This is the Template URL or the Snapshot URL corresponding to the Template."
          },
          "setupInstructions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ToolTemplateSetup"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "gohighlevel.contact.create"
            ],
            "description": "The type of tool. \"gohighlevel.contact.create\" for GoHighLevel contact create tool."
          }
        },
        "required": [
          "type"
        ]
      },
      "GoHighLevelContactGetToolProviderDetails": {
        "type": "object",
        "properties": {
          "templateUrl": {
            "type": "string",
            "description": "This is the Template URL or the Snapshot URL corresponding to the Template."
          },
          "setupInstructions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ToolTemplateSetup"
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "gohighlevel.contact.get"
            ],
            "description": "The type of tool. \"gohighlevel.contact.get\" for GoHighLevel contact get tool."
          }
        },
        "required": [
          "type"
        ]
      },
      "ToolTemplateMetadata": {
        "type": "object",
        "properties": {
          "collectionType": {
            "type": "string"
          },
          "collectionId": {
            "type": "string"
          },
          "collectionName": {
            "type": "string"
          }
        }
      },
      "CreateToolTemplateDTO": {
        "type": "object",
        "properties": {
          "details": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateApiRequestToolDTO",
                "title": "ApiRequestTool"
              },
              {
                "$ref": "#/components/schemas/CreateBashToolDTO",
                "title": "BashTool"
              },
              {
                "$ref": "#/components/schemas/CreateComputerToolDTO",
                "title": "ComputerTool"
              },
              {
                "$ref": "#/components/schemas/CreateDtmfToolDTO",
                "title": "DtmfTool"
              },
              {
                "$ref": "#/components/schemas/CreateEndCallToolDTO",
                "title": "EndCallTool"
              },
              {
                "$ref": "#/components/schemas/CreateFunctionToolDTO",
                "title": "FunctionTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                "title": "GoHighLevelCalendarAvailabilityTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                "title": "GoHighLevelCalendarEventCreateTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                "title": "GoHighLevelContactCreateTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoHighLevelContactGetToolDTO",
                "title": "GoHighLevelContactGetTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                "title": "GoogleCalendarCheckAvailabilityTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                "title": "GoogleCalendarCreateEventTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                "title": "GoogleSheetsRowAppendTool"
              },
              {
                "$ref": "#/components/schemas/CreateMcpToolDTO",
                "title": "McpTool"
              },
              {
                "$ref": "#/components/schemas/CreateQueryToolDTO",
                "title": "QueryTool"
              },
              {
                "$ref": "#/components/schemas/CreateSlackSendMessageToolDTO",
                "title": "SlackSendMessageTool"
              },
              {
                "$ref": "#/components/schemas/CreateSmsToolDTO",
                "title": "SmsTool"
              },
              {
                "$ref": "#/components/schemas/CreateTextEditorToolDTO",
                "title": "TextEditorTool"
              },
              {
                "$ref": "#/components/schemas/CreateTransferCallToolDTO",
                "title": "TransferCallTool"
              }
            ]
          },
          "providerDetails": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/MakeToolProviderDetails",
                "title": "MakeToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GhlToolProviderDetails",
                "title": "GhlToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/FunctionToolProviderDetails",
                "title": "FunctionToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GoogleCalendarCreateEventToolProviderDetails",
                "title": "GoogleCalendarCreateEventToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GoogleSheetsRowAppendToolProviderDetails",
                "title": "GoogleSheetsRowAppendToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GoHighLevelCalendarAvailabilityToolProviderDetails",
                "title": "GoHighLevelCalendarAvailabilityToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GoHighLevelCalendarEventCreateToolProviderDetails",
                "title": "GoHighLevelCalendarEventCreateToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GoHighLevelContactCreateToolProviderDetails",
                "title": "GoHighLevelContactCreateToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GoHighLevelContactGetToolProviderDetails",
                "title": "GoHighLevelContactGetToolProviderDetails"
              }
            ]
          },
          "metadata": {
            "$ref": "#/components/schemas/ToolTemplateMetadata"
          },
          "visibility": {
            "type": "string",
            "default": "private",
            "enum": [
              "public",
              "private"
            ]
          },
          "type": {
            "type": "string",
            "default": "tool",
            "enum": [
              "tool"
            ]
          },
          "name": {
            "type": "string",
            "description": "The name of the template. This is just for your own reference.",
            "maxLength": 40
          },
          "provider": {
            "type": "string",
            "enum": [
              "make",
              "gohighlevel",
              "function"
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "Template": {
        "type": "object",
        "properties": {
          "details": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateApiRequestToolDTO",
                "title": "ApiRequestTool"
              },
              {
                "$ref": "#/components/schemas/CreateBashToolDTO",
                "title": "BashTool"
              },
              {
                "$ref": "#/components/schemas/CreateComputerToolDTO",
                "title": "ComputerTool"
              },
              {
                "$ref": "#/components/schemas/CreateDtmfToolDTO",
                "title": "DtmfTool"
              },
              {
                "$ref": "#/components/schemas/CreateEndCallToolDTO",
                "title": "EndCallTool"
              },
              {
                "$ref": "#/components/schemas/CreateFunctionToolDTO",
                "title": "FunctionTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                "title": "GoHighLevelCalendarAvailabilityTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                "title": "GoHighLevelCalendarEventCreateTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                "title": "GoHighLevelContactCreateTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoHighLevelContactGetToolDTO",
                "title": "GoHighLevelContactGetTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                "title": "GoogleCalendarCheckAvailabilityTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                "title": "GoogleCalendarCreateEventTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                "title": "GoogleSheetsRowAppendTool"
              },
              {
                "$ref": "#/components/schemas/CreateMcpToolDTO",
                "title": "McpTool"
              },
              {
                "$ref": "#/components/schemas/CreateQueryToolDTO",
                "title": "QueryTool"
              },
              {
                "$ref": "#/components/schemas/CreateSlackSendMessageToolDTO",
                "title": "SlackSendMessageTool"
              },
              {
                "$ref": "#/components/schemas/CreateSmsToolDTO",
                "title": "SmsTool"
              },
              {
                "$ref": "#/components/schemas/CreateTextEditorToolDTO",
                "title": "TextEditorTool"
              },
              {
                "$ref": "#/components/schemas/CreateTransferCallToolDTO",
                "title": "TransferCallTool"
              }
            ]
          },
          "providerDetails": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/MakeToolProviderDetails",
                "title": "MakeToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GhlToolProviderDetails",
                "title": "GhlToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/FunctionToolProviderDetails",
                "title": "FunctionToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GoogleCalendarCreateEventToolProviderDetails",
                "title": "GoogleCalendarCreateEventToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GoogleSheetsRowAppendToolProviderDetails",
                "title": "GoogleSheetsRowAppendToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GoHighLevelCalendarAvailabilityToolProviderDetails",
                "title": "GoHighLevelCalendarAvailabilityToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GoHighLevelCalendarEventCreateToolProviderDetails",
                "title": "GoHighLevelCalendarEventCreateToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GoHighLevelContactCreateToolProviderDetails",
                "title": "GoHighLevelContactCreateToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GoHighLevelContactGetToolProviderDetails",
                "title": "GoHighLevelContactGetToolProviderDetails"
              }
            ]
          },
          "metadata": {
            "$ref": "#/components/schemas/ToolTemplateMetadata"
          },
          "visibility": {
            "default": "private",
            "enum": [
              "public",
              "private"
            ],
            "type": "string"
          },
          "type": {
            "type": "string",
            "default": "tool",
            "enum": [
              "tool"
            ]
          },
          "name": {
            "type": "string",
            "description": "The name of the template. This is just for your own reference.",
            "maxLength": 40
          },
          "provider": {
            "enum": [
              "make",
              "gohighlevel",
              "function"
            ],
            "type": "string"
          },
          "id": {
            "type": "string",
            "description": "The unique identifier for the template."
          },
          "orgId": {
            "type": "string",
            "description": "The unique identifier for the organization that this template belongs to."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "The ISO 8601 date-time string of when the template was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "The ISO 8601 date-time string of when the template was last updated."
          }
        },
        "required": [
          "type",
          "id",
          "orgId",
          "createdAt",
          "updatedAt"
        ]
      },
      "UpdateToolTemplateDTO": {
        "type": "object",
        "properties": {
          "details": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateApiRequestToolDTO",
                "title": "ApiRequestTool"
              },
              {
                "$ref": "#/components/schemas/CreateBashToolDTO",
                "title": "BashTool"
              },
              {
                "$ref": "#/components/schemas/CreateComputerToolDTO",
                "title": "ComputerTool"
              },
              {
                "$ref": "#/components/schemas/CreateDtmfToolDTO",
                "title": "DtmfTool"
              },
              {
                "$ref": "#/components/schemas/CreateEndCallToolDTO",
                "title": "EndCallTool"
              },
              {
                "$ref": "#/components/schemas/CreateFunctionToolDTO",
                "title": "FunctionTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoHighLevelCalendarAvailabilityToolDTO",
                "title": "GoHighLevelCalendarAvailabilityTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoHighLevelCalendarEventCreateToolDTO",
                "title": "GoHighLevelCalendarEventCreateTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoHighLevelContactCreateToolDTO",
                "title": "GoHighLevelContactCreateTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoHighLevelContactGetToolDTO",
                "title": "GoHighLevelContactGetTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoogleCalendarCheckAvailabilityToolDTO",
                "title": "GoogleCalendarCheckAvailabilityTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoogleCalendarCreateEventToolDTO",
                "title": "GoogleCalendarCreateEventTool"
              },
              {
                "$ref": "#/components/schemas/CreateGoogleSheetsRowAppendToolDTO",
                "title": "GoogleSheetsRowAppendTool"
              },
              {
                "$ref": "#/components/schemas/CreateMcpToolDTO",
                "title": "McpTool"
              },
              {
                "$ref": "#/components/schemas/CreateQueryToolDTO",
                "title": "QueryTool"
              },
              {
                "$ref": "#/components/schemas/CreateSlackSendMessageToolDTO",
                "title": "SlackSendMessageTool"
              },
              {
                "$ref": "#/components/schemas/CreateSmsToolDTO",
                "title": "SmsTool"
              },
              {
                "$ref": "#/components/schemas/CreateTextEditorToolDTO",
                "title": "TextEditorTool"
              },
              {
                "$ref": "#/components/schemas/CreateTransferCallToolDTO",
                "title": "TransferCallTool"
              }
            ]
          },
          "providerDetails": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/MakeToolProviderDetails",
                "title": "MakeToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GhlToolProviderDetails",
                "title": "GhlToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/FunctionToolProviderDetails",
                "title": "FunctionToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GoogleCalendarCreateEventToolProviderDetails",
                "title": "GoogleCalendarCreateEventToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GoogleSheetsRowAppendToolProviderDetails",
                "title": "GoogleSheetsRowAppendToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GoHighLevelCalendarAvailabilityToolProviderDetails",
                "title": "GoHighLevelCalendarAvailabilityToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GoHighLevelCalendarEventCreateToolProviderDetails",
                "title": "GoHighLevelCalendarEventCreateToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GoHighLevelContactCreateToolProviderDetails",
                "title": "GoHighLevelContactCreateToolProviderDetails"
              },
              {
                "$ref": "#/components/schemas/GoHighLevelContactGetToolProviderDetails",
                "title": "GoHighLevelContactGetToolProviderDetails"
              }
            ]
          },
          "metadata": {
            "$ref": "#/components/schemas/ToolTemplateMetadata"
          },
          "visibility": {
            "type": "string",
            "default": "private",
            "enum": [
              "public",
              "private"
            ]
          },
          "type": {
            "type": "string",
            "default": "tool",
            "enum": [
              "tool"
            ]
          },
          "name": {
            "type": "string",
            "description": "The name of the template. This is just for your own reference.",
            "maxLength": 40
          },
          "provider": {
            "type": "string",
            "enum": [
              "make",
              "gohighlevel",
              "function"
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "VoiceLibrary": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "object",
            "description": "This is the voice provider that will be used.",
            "enum": [
              "vapi",
              "11labs",
              "azure",
              "cartesia",
              "custom-voice",
              "deepgram",
              "hume",
              "lmnt",
              "neuphonic",
              "openai",
              "playht",
              "rime-ai",
              "smallest-ai",
              "tavus",
              "sesame"
            ]
          },
          "providerId": {
            "type": "string",
            "description": "The ID of the voice provided by the provider."
          },
          "slug": {
            "type": "string",
            "description": "The unique slug of the voice."
          },
          "name": {
            "type": "string",
            "description": "The name of the voice."
          },
          "language": {
            "type": "string",
            "description": "The language of the voice."
          },
          "languageCode": {
            "type": "string",
            "description": "The language code of the voice."
          },
          "model": {
            "type": "string",
            "description": "The model of the voice."
          },
          "supportedModels": {
            "type": "string",
            "description": "The supported models of the voice."
          },
          "gender": {
            "type": "string",
            "description": "The gender of the voice.",
            "enum": [
              "male",
              "female"
            ]
          },
          "accent": {
            "type": "string",
            "description": "The accent of the voice."
          },
          "previewUrl": {
            "type": "string",
            "description": "The preview URL of the voice."
          },
          "description": {
            "type": "string",
            "description": "The description of the voice."
          },
          "credentialId": {
            "type": "string",
            "description": "The credential ID of the voice."
          },
          "id": {
            "type": "string",
            "description": "The unique identifier for the voice library."
          },
          "orgId": {
            "type": "string",
            "description": "The unique identifier for the organization that this voice library belongs to."
          },
          "isPublic": {
            "type": "boolean",
            "description": "The Public voice is shared accross all the organizations."
          },
          "isDeleted": {
            "type": "boolean",
            "description": "The deletion status of the voice."
          },
          "createdAt": {
            "format": "date-time",
            "type": "string",
            "description": "The ISO 8601 date-time string of when the voice library was created."
          },
          "updatedAt": {
            "format": "date-time",
            "type": "string",
            "description": "The ISO 8601 date-time string of when the voice library was last updated."
          }
        },
        "required": [
          "id",
          "orgId",
          "isPublic",
          "isDeleted",
          "createdAt",
          "updatedAt"
        ]
      },
      "SyncVoiceLibraryDTO": {
        "type": "object",
        "properties": {
          "providers": {
            "type": "array",
            "description": "List of providers you want to sync.",
            "enum": [
              "vapi",
              "11labs",
              "azure",
              "cartesia",
              "custom-voice",
              "deepgram",
              "hume",
              "lmnt",
              "neuphonic",
              "openai",
              "playht",
              "rime-ai",
              "smallest-ai",
              "tavus",
              "sesame"
            ],
            "items": {
              "type": "string",
              "enum": [
                "vapi",
                "11labs",
                "azure",
                "cartesia",
                "custom-voice",
                "deepgram",
                "hume",
                "lmnt",
                "neuphonic",
                "openai",
                "playht",
                "rime-ai",
                "smallest-ai",
                "tavus",
                "sesame"
              ]
            }
          }
        }
      },
      "CreateSesameVoiceDTO": {
        "type": "object",
        "properties": {
          "voiceName": {
            "type": "string",
            "description": "The name of the voice."
          },
          "transcription": {
            "type": "string",
            "description": "The transcript of the utterance."
          }
        }
      },
      "VoiceLibraryVoiceResponse": {
        "type": "object",
        "properties": {
          "voiceId": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "publicOwnerId": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "gender": {
            "type": "string"
          },
          "age": {
            "type": "object"
          },
          "accent": {
            "type": "string"
          }
        },
        "required": [
          "voiceId",
          "name"
        ]
      },
      "AddVoiceToProviderDTO": {
        "type": "object",
        "properties": {
          "ownerId": {
            "type": "string",
            "description": "This is the owner_id of your shared voice which you want to add to your provider Account from Provider Voice Library"
          },
          "voiceId": {
            "type": "string",
            "description": "This is the voice_id of the shared voice which you want to add to your provider Account from Provider Voice Library"
          },
          "name": {
            "type": "string",
            "description": "This is the new name of the voice which you want to have once you have added voice to your provider Account from Provider Voice Library"
          }
        },
        "required": [
          "ownerId",
          "voiceId",
          "name"
        ]
      },
      "CloneVoiceDTO": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "This is the name of the cloned voice in the provider account."
          },
          "description": {
            "type": "string",
            "description": "This is the description of your cloned voice."
          },
          "labels": {
            "type": "string",
            "description": "Serialized labels dictionary for the voice."
          },
          "files": {
            "description": "These are the files you want to use to clone your voice. Only Audio files are supported.",
            "type": "array",
            "items": {
              "type": "string",
              "format": "binary"
            }
          }
        },
        "required": [
          "name",
          "files"
        ]
      },
      "ClientMessageWorkflowNodeStarted": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"workflow.node.started\" is sent when the active node changes.",
            "enum": [
              "workflow.node.started"
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "node": {
            "type": "object",
            "description": "This is the active node."
          }
        },
        "required": [
          "type",
          "node"
        ]
      },
      "ClientMessageConversationUpdate": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"conversation-update\" is sent when an update is committed to the conversation history.",
            "enum": [
              "conversation-update"
            ]
          },
          "messages": {
            "type": "array",
            "description": "This is the most up-to-date conversation history at the time the message is sent.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/UserMessage",
                  "title": "UserMessage"
                },
                {
                  "$ref": "#/components/schemas/SystemMessage",
                  "title": "SystemMessage"
                },
                {
                  "$ref": "#/components/schemas/BotMessage",
                  "title": "BotMessage"
                },
                {
                  "$ref": "#/components/schemas/ToolCallMessage",
                  "title": "ToolCallMessage"
                },
                {
                  "$ref": "#/components/schemas/ToolCallResultMessage",
                  "title": "ToolCallResultMessage"
                }
              ]
            }
          },
          "messagesOpenAIFormatted": {
            "description": "This is the most up-to-date conversation history at the time the message is sent, formatted for OpenAI.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            }
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          }
        },
        "required": [
          "type",
          "messagesOpenAIFormatted"
        ]
      },
      "ClientMessageHang": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"hang\" is sent when the assistant is hanging due to a delay. The delay can be caused by many factors, such as:\n- the model is too slow to respond\n- the voice is too slow to respond\n- the tool call is still waiting for a response from your server\n- etc.",
            "enum": [
              "hang"
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "ClientMessageMetadata": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"metadata\" is sent to forward metadata to the client.",
            "enum": [
              "metadata"
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "metadata": {
            "type": "string",
            "description": "This is the metadata content"
          }
        },
        "required": [
          "type",
          "metadata"
        ]
      },
      "ClientMessageModelOutput": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"model-output\" is sent as the model outputs tokens.",
            "enum": [
              "model-output"
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "output": {
            "type": "object",
            "description": "This is the output of the model. It can be a token or tool call."
          }
        },
        "required": [
          "type",
          "output"
        ]
      },
      "ClientMessageSpeechUpdate": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"speech-update\" is sent whenever assistant or user start or stop speaking.",
            "enum": [
              "speech-update"
            ]
          },
          "status": {
            "type": "string",
            "description": "This is the status of the speech update.",
            "enum": [
              "started",
              "stopped"
            ]
          },
          "role": {
            "type": "string",
            "description": "This is the role which the speech update is for.",
            "enum": [
              "assistant",
              "user"
            ]
          },
          "turn": {
            "type": "number",
            "description": "This is the turn number of the speech update (0-indexed)."
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          }
        },
        "required": [
          "type",
          "status",
          "role"
        ]
      },
      "ClientMessageTranscript": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"transcript\" is sent as transcriber outputs partial or final transcript.",
            "enum": [
              "transcript",
              "transcript[transcriptType=\"final\"]"
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "role": {
            "type": "string",
            "description": "This is the role for which the transcript is for.",
            "enum": [
              "assistant",
              "user"
            ]
          },
          "transcriptType": {
            "type": "string",
            "description": "This is the type of the transcript.",
            "enum": [
              "partial",
              "final"
            ]
          },
          "transcript": {
            "type": "string",
            "description": "This is the transcript content."
          }
        },
        "required": [
          "type",
          "role",
          "transcriptType",
          "transcript"
        ]
      },
      "ClientMessageToolCalls": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"tool-calls\" is sent to call a tool.",
            "enum": [
              "tool-calls"
            ]
          },
          "toolWithToolCallList": {
            "type": "array",
            "description": "This is the list of tools calls that the model is requesting along with the original tool configuration.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/FunctionToolWithToolCall",
                  "title": "FunctionToolWithToolCall"
                },
                {
                  "$ref": "#/components/schemas/GhlToolWithToolCall",
                  "title": "GhlToolWithToolCall"
                },
                {
                  "$ref": "#/components/schemas/MakeToolWithToolCall",
                  "title": "MakeToolWithToolCall"
                },
                {
                  "$ref": "#/components/schemas/BashToolWithToolCall",
                  "title": "BashToolWithToolCall"
                },
                {
                  "$ref": "#/components/schemas/ComputerToolWithToolCall",
                  "title": "ComputerToolWithToolCall"
                },
                {
                  "$ref": "#/components/schemas/TextEditorToolWithToolCall",
                  "title": "TextEditorToolWithToolCall"
                },
                {
                  "$ref": "#/components/schemas/GoogleCalendarCreateEventToolWithToolCall",
                  "title": "GoogleCalendarCreateEventToolWithToolCall"
                }
              ]
            }
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "toolCallList": {
            "description": "This is the list of tool calls that the model is requesting.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ToolCall"
            }
          }
        },
        "required": [
          "toolWithToolCallList",
          "toolCallList"
        ]
      },
      "ClientMessageToolCallsResult": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"tool-calls-result\" is sent to forward the result of a tool call to the client.",
            "enum": [
              "tool-calls-result"
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "toolCallResult": {
            "type": "object",
            "description": "This is the result of the tool call."
          }
        },
        "required": [
          "type",
          "toolCallResult"
        ]
      },
      "ClientMessageTransferUpdate": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"transfer-update\" is sent whenever a transfer happens.",
            "enum": [
              "transfer-update"
            ]
          },
          "destination": {
            "description": "This is the destination of the transfer.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationAssistant",
                "title": "Assistant"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "Number"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "Sip"
              }
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "toAssistant": {
            "description": "This is the assistant that the call is being transferred to. This is only sent if `destination.type` is \"assistant\".",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "fromAssistant": {
            "description": "This is the assistant that the call is being transferred from. This is only sent if `destination.type` is \"assistant\".",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "toStepRecord": {
            "type": "object",
            "description": "This is the step that the conversation moved to."
          },
          "fromStepRecord": {
            "type": "object",
            "description": "This is the step that the conversation moved from. ="
          }
        },
        "required": [
          "type"
        ]
      },
      "ClientMessageUserInterrupted": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"user-interrupted\" is sent when the user interrupts the assistant.",
            "enum": [
              "user-interrupted"
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "ClientMessageLanguageChangeDetected": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"language-change-detected\" is sent when the transcriber is automatically switched based on the detected language.",
            "enum": [
              "language-change-detected"
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "language": {
            "type": "string",
            "description": "This is the language the transcriber is switched to."
          }
        },
        "required": [
          "type",
          "language"
        ]
      },
      "ClientMessageVoiceInput": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"voice-input\" is sent when a generation is requested from voice provider.",
            "enum": [
              "voice-input"
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "input": {
            "type": "string",
            "description": "This is the voice input content"
          }
        },
        "required": [
          "type",
          "input"
        ]
      },
      "ClientMessage": {
        "type": "object",
        "properties": {
          "message": {
            "description": "These are all the messages that can be sent to the client-side SDKs during the call. Configure the messages you'd like to receive in `assistant.clientMessages`.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/ClientMessageWorkflowNodeStarted",
                "title": "WorkflowNodeStarted"
              },
              {
                "$ref": "#/components/schemas/ClientMessageConversationUpdate",
                "title": "ConversationUpdate"
              },
              {
                "$ref": "#/components/schemas/ClientMessageHang",
                "title": "Hang"
              },
              {
                "$ref": "#/components/schemas/ClientMessageMetadata",
                "title": "Metadata"
              },
              {
                "$ref": "#/components/schemas/ClientMessageModelOutput",
                "title": "ModelOutput"
              },
              {
                "$ref": "#/components/schemas/ClientMessageSpeechUpdate",
                "title": "SpeechUpdate"
              },
              {
                "$ref": "#/components/schemas/ClientMessageTranscript",
                "title": "Transcript"
              },
              {
                "$ref": "#/components/schemas/ClientMessageToolCalls",
                "title": "ToolCalls"
              },
              {
                "$ref": "#/components/schemas/ClientMessageToolCallsResult",
                "title": "ToolCallsResult"
              },
              {
                "$ref": "#/components/schemas/ClientMessageTransferUpdate",
                "title": "TransferUpdate"
              },
              {
                "$ref": "#/components/schemas/ClientMessageUserInterrupted",
                "title": "UserInterrupted"
              },
              {
                "$ref": "#/components/schemas/ClientMessageLanguageChangeDetected",
                "title": "LanguageChangeDetected"
              },
              {
                "$ref": "#/components/schemas/ClientMessageVoiceInput",
                "title": "VoiceInput"
              }
            ]
          }
        },
        "required": [
          "message"
        ]
      },
      "ServerMessageAssistantRequest": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"assistant-request\" is sent to fetch assistant configuration for an incoming call.",
            "enum": [
              "assistant-request"
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "artifact": {
            "description": "This is a live version of the `call.artifact`.\n\nThis matches what is stored on `call.artifact` after the call.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Artifact"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "ServerMessageConversationUpdate": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"conversation-update\" is sent when an update is committed to the conversation history.",
            "enum": [
              "conversation-update"
            ]
          },
          "messages": {
            "type": "array",
            "description": "This is the most up-to-date conversation history at the time the message is sent.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/UserMessage",
                  "title": "UserMessage"
                },
                {
                  "$ref": "#/components/schemas/SystemMessage",
                  "title": "SystemMessage"
                },
                {
                  "$ref": "#/components/schemas/BotMessage",
                  "title": "BotMessage"
                },
                {
                  "$ref": "#/components/schemas/ToolCallMessage",
                  "title": "ToolCallMessage"
                },
                {
                  "$ref": "#/components/schemas/ToolCallResultMessage",
                  "title": "ToolCallResultMessage"
                }
              ]
            }
          },
          "messagesOpenAIFormatted": {
            "description": "This is the most up-to-date conversation history at the time the message is sent, formatted for OpenAI.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            }
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "artifact": {
            "description": "This is a live version of the `call.artifact`.\n\nThis matches what is stored on `call.artifact` after the call.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Artifact"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          }
        },
        "required": [
          "type",
          "messagesOpenAIFormatted"
        ]
      },
      "ServerMessageEndOfCallReport": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"end-of-call-report\" is sent when the call ends and post-processing is complete.",
            "enum": [
              "end-of-call-report"
            ]
          },
          "endedReason": {
            "type": "string",
            "description": "This is the reason the call ended. This can also be found at `call.endedReason` on GET /call/:id.",
            "enum": [
              "call-start-error-neither-assistant-nor-server-set",
              "assistant-request-failed",
              "assistant-request-returned-error",
              "assistant-request-returned-unspeakable-error",
              "assistant-request-returned-invalid-assistant",
              "assistant-request-returned-no-assistant",
              "assistant-request-returned-forwarding-phone-number",
              "call.start.error-get-org",
              "call.start.error-get-subscription",
              "call.start.error-get-assistant",
              "call.start.error-get-phone-number",
              "call.start.error-get-customer",
              "call.start.error-get-resources-validation",
              "call.start.error-vapi-number-international",
              "call.start.error-vapi-number-outbound-daily-limit",
              "call.start.error-get-transport",
              "assistant-not-valid",
              "database-error",
              "assistant-not-found",
              "pipeline-error-openai-voice-failed",
              "pipeline-error-cartesia-voice-failed",
              "pipeline-error-deepgram-voice-failed",
              "pipeline-error-eleven-labs-voice-failed",
              "pipeline-error-playht-voice-failed",
              "pipeline-error-lmnt-voice-failed",
              "pipeline-error-azure-voice-failed",
              "pipeline-error-rime-ai-voice-failed",
              "pipeline-error-smallest-ai-voice-failed",
              "pipeline-error-neuphonic-voice-failed",
              "pipeline-error-hume-voice-failed",
              "pipeline-error-sesame-voice-failed",
              "pipeline-error-tavus-video-failed",
              "call.in-progress.error-vapifault-openai-voice-failed",
              "call.in-progress.error-vapifault-cartesia-voice-failed",
              "call.in-progress.error-vapifault-deepgram-voice-failed",
              "call.in-progress.error-vapifault-eleven-labs-voice-failed",
              "call.in-progress.error-vapifault-playht-voice-failed",
              "call.in-progress.error-vapifault-lmnt-voice-failed",
              "call.in-progress.error-vapifault-azure-voice-failed",
              "call.in-progress.error-vapifault-rime-ai-voice-failed",
              "call.in-progress.error-vapifault-smallest-ai-voice-failed",
              "call.in-progress.error-vapifault-neuphonic-voice-failed",
              "call.in-progress.error-vapifault-hume-voice-failed",
              "call.in-progress.error-vapifault-sesame-voice-failed",
              "call.in-progress.error-vapifault-tavus-video-failed",
              "pipeline-error-vapi-llm-failed",
              "pipeline-error-vapi-400-bad-request-validation-failed",
              "pipeline-error-vapi-401-unauthorized",
              "pipeline-error-vapi-403-model-access-denied",
              "pipeline-error-vapi-429-exceeded-quota",
              "pipeline-error-vapi-500-server-error",
              "pipeline-error-vapi-503-server-overloaded-error",
              "call.in-progress.error-vapifault-vapi-llm-failed",
              "call.in-progress.error-vapifault-vapi-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-vapi-401-unauthorized",
              "call.in-progress.error-vapifault-vapi-403-model-access-denied",
              "call.in-progress.error-vapifault-vapi-429-exceeded-quota",
              "call.in-progress.error-providerfault-vapi-500-server-error",
              "call.in-progress.error-providerfault-vapi-503-server-overloaded-error",
              "pipeline-error-deepgram-transcriber-failed",
              "call.in-progress.error-vapifault-deepgram-transcriber-failed",
              "pipeline-error-gladia-transcriber-failed",
              "call.in-progress.error-vapifault-gladia-transcriber-failed",
              "pipeline-error-speechmatics-transcriber-failed",
              "call.in-progress.error-vapifault-speechmatics-transcriber-failed",
              "pipeline-error-assembly-ai-transcriber-failed",
              "pipeline-error-assembly-ai-returning-400-insufficent-funds",
              "pipeline-error-assembly-ai-returning-400-paid-only-feature",
              "pipeline-error-assembly-ai-returning-401-invalid-credentials",
              "pipeline-error-assembly-ai-returning-500-invalid-schema",
              "pipeline-error-assembly-ai-returning-500-word-boost-parsing-failed",
              "call.in-progress.error-vapifault-assembly-ai-transcriber-failed",
              "call.in-progress.error-vapifault-assembly-ai-returning-400-insufficent-funds",
              "call.in-progress.error-vapifault-assembly-ai-returning-400-paid-only-feature",
              "call.in-progress.error-vapifault-assembly-ai-returning-401-invalid-credentials",
              "call.in-progress.error-vapifault-assembly-ai-returning-500-invalid-schema",
              "call.in-progress.error-vapifault-assembly-ai-returning-500-word-boost-parsing-failed",
              "pipeline-error-talkscriber-transcriber-failed",
              "call.in-progress.error-vapifault-talkscriber-transcriber-failed",
              "pipeline-error-azure-speech-transcriber-failed",
              "call.in-progress.error-vapifault-azure-speech-transcriber-failed",
              "call.in-progress.error-pipeline-no-available-llm-model",
              "worker-shutdown",
              "unknown-error",
              "vonage-disconnected",
              "vonage-failed-to-connect-call",
              "vonage-completed",
              "phone-call-provider-bypass-enabled-but-no-call-received",
              "call.in-progress.error-providerfault-transport-never-connected",
              "call.in-progress.error-vapifault-worker-not-available",
              "call.in-progress.error-vapifault-transport-never-connected",
              "call.in-progress.error-vapifault-transport-connected-but-call-not-active",
              "call.in-progress.error-vapifault-call-started-but-connection-to-transport-missing",
              "call.in-progress.error-vapifault-worker-died",
              "call.in-progress.error-vapifault-openai-llm-failed",
              "call.in-progress.error-vapifault-azure-openai-llm-failed",
              "call.in-progress.error-vapifault-groq-llm-failed",
              "call.in-progress.error-vapifault-google-llm-failed",
              "call.in-progress.error-vapifault-xai-llm-failed",
              "call.in-progress.error-vapifault-mistral-llm-failed",
              "call.in-progress.error-vapifault-inflection-ai-llm-failed",
              "call.in-progress.error-vapifault-cerebras-llm-failed",
              "call.in-progress.error-vapifault-deep-seek-llm-failed",
              "pipeline-error-openai-400-bad-request-validation-failed",
              "pipeline-error-openai-401-unauthorized",
              "pipeline-error-openai-401-incorrect-api-key",
              "pipeline-error-openai-401-account-not-in-organization",
              "pipeline-error-openai-403-model-access-denied",
              "pipeline-error-openai-429-exceeded-quota",
              "pipeline-error-openai-429-rate-limit-reached",
              "pipeline-error-openai-500-server-error",
              "pipeline-error-openai-503-server-overloaded-error",
              "pipeline-error-openai-llm-failed",
              "call.in-progress.error-vapifault-openai-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-openai-401-unauthorized",
              "call.in-progress.error-vapifault-openai-401-incorrect-api-key",
              "call.in-progress.error-vapifault-openai-401-account-not-in-organization",
              "call.in-progress.error-vapifault-openai-403-model-access-denied",
              "call.in-progress.error-vapifault-openai-429-exceeded-quota",
              "call.in-progress.error-vapifault-openai-429-rate-limit-reached",
              "call.in-progress.error-providerfault-openai-500-server-error",
              "call.in-progress.error-providerfault-openai-503-server-overloaded-error",
              "pipeline-error-azure-openai-400-bad-request-validation-failed",
              "pipeline-error-azure-openai-401-unauthorized",
              "pipeline-error-azure-openai-403-model-access-denied",
              "pipeline-error-azure-openai-429-exceeded-quota",
              "pipeline-error-azure-openai-500-server-error",
              "pipeline-error-azure-openai-503-server-overloaded-error",
              "pipeline-error-azure-openai-llm-failed",
              "call.in-progress.error-vapifault-azure-openai-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-azure-openai-401-unauthorized",
              "call.in-progress.error-vapifault-azure-openai-403-model-access-denied",
              "call.in-progress.error-vapifault-azure-openai-429-exceeded-quota",
              "call.in-progress.error-providerfault-azure-openai-500-server-error",
              "call.in-progress.error-providerfault-azure-openai-503-server-overloaded-error",
              "pipeline-error-google-400-bad-request-validation-failed",
              "pipeline-error-google-401-unauthorized",
              "pipeline-error-google-403-model-access-denied",
              "pipeline-error-google-429-exceeded-quota",
              "pipeline-error-google-500-server-error",
              "pipeline-error-google-503-server-overloaded-error",
              "pipeline-error-google-llm-failed",
              "call.in-progress.error-vapifault-google-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-google-401-unauthorized",
              "call.in-progress.error-vapifault-google-403-model-access-denied",
              "call.in-progress.error-vapifault-google-429-exceeded-quota",
              "call.in-progress.error-providerfault-google-500-server-error",
              "call.in-progress.error-providerfault-google-503-server-overloaded-error",
              "pipeline-error-xai-400-bad-request-validation-failed",
              "pipeline-error-xai-401-unauthorized",
              "pipeline-error-xai-403-model-access-denied",
              "pipeline-error-xai-429-exceeded-quota",
              "pipeline-error-xai-500-server-error",
              "pipeline-error-xai-503-server-overloaded-error",
              "pipeline-error-xai-llm-failed",
              "call.in-progress.error-vapifault-xai-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-xai-401-unauthorized",
              "call.in-progress.error-vapifault-xai-403-model-access-denied",
              "call.in-progress.error-vapifault-xai-429-exceeded-quota",
              "call.in-progress.error-providerfault-xai-500-server-error",
              "call.in-progress.error-providerfault-xai-503-server-overloaded-error",
              "pipeline-error-mistral-400-bad-request-validation-failed",
              "pipeline-error-mistral-401-unauthorized",
              "pipeline-error-mistral-403-model-access-denied",
              "pipeline-error-mistral-429-exceeded-quota",
              "pipeline-error-mistral-500-server-error",
              "pipeline-error-mistral-503-server-overloaded-error",
              "pipeline-error-mistral-llm-failed",
              "call.in-progress.error-vapifault-mistral-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-mistral-401-unauthorized",
              "call.in-progress.error-vapifault-mistral-403-model-access-denied",
              "call.in-progress.error-vapifault-mistral-429-exceeded-quota",
              "call.in-progress.error-providerfault-mistral-500-server-error",
              "call.in-progress.error-providerfault-mistral-503-server-overloaded-error",
              "pipeline-error-inflection-ai-400-bad-request-validation-failed",
              "pipeline-error-inflection-ai-401-unauthorized",
              "pipeline-error-inflection-ai-403-model-access-denied",
              "pipeline-error-inflection-ai-429-exceeded-quota",
              "pipeline-error-inflection-ai-500-server-error",
              "pipeline-error-inflection-ai-503-server-overloaded-error",
              "pipeline-error-inflection-ai-llm-failed",
              "call.in-progress.error-vapifault-inflection-ai-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-inflection-ai-401-unauthorized",
              "call.in-progress.error-vapifault-inflection-ai-403-model-access-denied",
              "call.in-progress.error-vapifault-inflection-ai-429-exceeded-quota",
              "call.in-progress.error-providerfault-inflection-ai-500-server-error",
              "call.in-progress.error-providerfault-inflection-ai-503-server-overloaded-error",
              "pipeline-error-deep-seek-400-bad-request-validation-failed",
              "pipeline-error-deep-seek-401-unauthorized",
              "pipeline-error-deep-seek-403-model-access-denied",
              "pipeline-error-deep-seek-429-exceeded-quota",
              "pipeline-error-deep-seek-500-server-error",
              "pipeline-error-deep-seek-503-server-overloaded-error",
              "pipeline-error-deep-seek-llm-failed",
              "call.in-progress.error-vapifault-deep-seek-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-deep-seek-401-unauthorized",
              "call.in-progress.error-vapifault-deep-seek-403-model-access-denied",
              "call.in-progress.error-vapifault-deep-seek-429-exceeded-quota",
              "call.in-progress.error-providerfault-deep-seek-500-server-error",
              "call.in-progress.error-providerfault-deep-seek-503-server-overloaded-error",
              "pipeline-error-groq-400-bad-request-validation-failed",
              "pipeline-error-groq-401-unauthorized",
              "pipeline-error-groq-403-model-access-denied",
              "pipeline-error-groq-429-exceeded-quota",
              "pipeline-error-groq-500-server-error",
              "pipeline-error-groq-503-server-overloaded-error",
              "pipeline-error-groq-llm-failed",
              "call.in-progress.error-vapifault-groq-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-groq-401-unauthorized",
              "call.in-progress.error-vapifault-groq-403-model-access-denied",
              "call.in-progress.error-vapifault-groq-429-exceeded-quota",
              "call.in-progress.error-providerfault-groq-500-server-error",
              "call.in-progress.error-providerfault-groq-503-server-overloaded-error",
              "pipeline-error-cerebras-400-bad-request-validation-failed",
              "pipeline-error-cerebras-401-unauthorized",
              "pipeline-error-cerebras-403-model-access-denied",
              "pipeline-error-cerebras-429-exceeded-quota",
              "pipeline-error-cerebras-500-server-error",
              "pipeline-error-cerebras-503-server-overloaded-error",
              "pipeline-error-cerebras-llm-failed",
              "call.in-progress.error-vapifault-cerebras-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-cerebras-401-unauthorized",
              "call.in-progress.error-vapifault-cerebras-403-model-access-denied",
              "call.in-progress.error-vapifault-cerebras-429-exceeded-quota",
              "call.in-progress.error-providerfault-cerebras-500-server-error",
              "call.in-progress.error-providerfault-cerebras-503-server-overloaded-error",
              "pipeline-error-anthropic-400-bad-request-validation-failed",
              "pipeline-error-anthropic-401-unauthorized",
              "pipeline-error-anthropic-403-model-access-denied",
              "pipeline-error-anthropic-429-exceeded-quota",
              "pipeline-error-anthropic-500-server-error",
              "pipeline-error-anthropic-503-server-overloaded-error",
              "pipeline-error-anthropic-llm-failed",
              "call.in-progress.error-vapifault-anthropic-llm-failed",
              "call.in-progress.error-vapifault-anthropic-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-anthropic-401-unauthorized",
              "call.in-progress.error-vapifault-anthropic-403-model-access-denied",
              "call.in-progress.error-vapifault-anthropic-429-exceeded-quota",
              "call.in-progress.error-providerfault-anthropic-500-server-error",
              "call.in-progress.error-providerfault-anthropic-503-server-overloaded-error",
              "pipeline-error-anthropic-bedrock-400-bad-request-validation-failed",
              "pipeline-error-anthropic-bedrock-401-unauthorized",
              "pipeline-error-anthropic-bedrock-403-model-access-denied",
              "pipeline-error-anthropic-bedrock-429-exceeded-quota",
              "pipeline-error-anthropic-bedrock-500-server-error",
              "pipeline-error-anthropic-bedrock-503-server-overloaded-error",
              "pipeline-error-anthropic-bedrock-llm-failed",
              "call.in-progress.error-vapifault-anthropic-bedrock-llm-failed",
              "call.in-progress.error-vapifault-anthropic-bedrock-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-anthropic-bedrock-401-unauthorized",
              "call.in-progress.error-vapifault-anthropic-bedrock-403-model-access-denied",
              "call.in-progress.error-vapifault-anthropic-bedrock-429-exceeded-quota",
              "call.in-progress.error-providerfault-anthropic-bedrock-500-server-error",
              "call.in-progress.error-providerfault-anthropic-bedrock-503-server-overloaded-error",
              "pipeline-error-anthropic-vertex-400-bad-request-validation-failed",
              "pipeline-error-anthropic-vertex-401-unauthorized",
              "pipeline-error-anthropic-vertex-403-model-access-denied",
              "pipeline-error-anthropic-vertex-429-exceeded-quota",
              "pipeline-error-anthropic-vertex-500-server-error",
              "pipeline-error-anthropic-vertex-503-server-overloaded-error",
              "pipeline-error-anthropic-vertex-llm-failed",
              "call.in-progress.error-vapifault-anthropic-vertex-llm-failed",
              "call.in-progress.error-vapifault-anthropic-vertex-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-anthropic-vertex-401-unauthorized",
              "call.in-progress.error-vapifault-anthropic-vertex-403-model-access-denied",
              "call.in-progress.error-vapifault-anthropic-vertex-429-exceeded-quota",
              "call.in-progress.error-providerfault-anthropic-vertex-500-server-error",
              "call.in-progress.error-providerfault-anthropic-vertex-503-server-overloaded-error",
              "pipeline-error-together-ai-400-bad-request-validation-failed",
              "pipeline-error-together-ai-401-unauthorized",
              "pipeline-error-together-ai-403-model-access-denied",
              "pipeline-error-together-ai-429-exceeded-quota",
              "pipeline-error-together-ai-500-server-error",
              "pipeline-error-together-ai-503-server-overloaded-error",
              "pipeline-error-together-ai-llm-failed",
              "call.in-progress.error-vapifault-together-ai-llm-failed",
              "call.in-progress.error-vapifault-together-ai-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-together-ai-401-unauthorized",
              "call.in-progress.error-vapifault-together-ai-403-model-access-denied",
              "call.in-progress.error-vapifault-together-ai-429-exceeded-quota",
              "call.in-progress.error-providerfault-together-ai-500-server-error",
              "call.in-progress.error-providerfault-together-ai-503-server-overloaded-error",
              "pipeline-error-anyscale-400-bad-request-validation-failed",
              "pipeline-error-anyscale-401-unauthorized",
              "pipeline-error-anyscale-403-model-access-denied",
              "pipeline-error-anyscale-429-exceeded-quota",
              "pipeline-error-anyscale-500-server-error",
              "pipeline-error-anyscale-503-server-overloaded-error",
              "pipeline-error-anyscale-llm-failed",
              "call.in-progress.error-vapifault-anyscale-llm-failed",
              "call.in-progress.error-vapifault-anyscale-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-anyscale-401-unauthorized",
              "call.in-progress.error-vapifault-anyscale-403-model-access-denied",
              "call.in-progress.error-vapifault-anyscale-429-exceeded-quota",
              "call.in-progress.error-providerfault-anyscale-500-server-error",
              "call.in-progress.error-providerfault-anyscale-503-server-overloaded-error",
              "pipeline-error-openrouter-400-bad-request-validation-failed",
              "pipeline-error-openrouter-401-unauthorized",
              "pipeline-error-openrouter-403-model-access-denied",
              "pipeline-error-openrouter-429-exceeded-quota",
              "pipeline-error-openrouter-500-server-error",
              "pipeline-error-openrouter-503-server-overloaded-error",
              "pipeline-error-openrouter-llm-failed",
              "call.in-progress.error-vapifault-openrouter-llm-failed",
              "call.in-progress.error-vapifault-openrouter-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-openrouter-401-unauthorized",
              "call.in-progress.error-vapifault-openrouter-403-model-access-denied",
              "call.in-progress.error-vapifault-openrouter-429-exceeded-quota",
              "call.in-progress.error-providerfault-openrouter-500-server-error",
              "call.in-progress.error-providerfault-openrouter-503-server-overloaded-error",
              "pipeline-error-perplexity-ai-400-bad-request-validation-failed",
              "pipeline-error-perplexity-ai-401-unauthorized",
              "pipeline-error-perplexity-ai-403-model-access-denied",
              "pipeline-error-perplexity-ai-429-exceeded-quota",
              "pipeline-error-perplexity-ai-500-server-error",
              "pipeline-error-perplexity-ai-503-server-overloaded-error",
              "pipeline-error-perplexity-ai-llm-failed",
              "call.in-progress.error-vapifault-perplexity-ai-llm-failed",
              "call.in-progress.error-vapifault-perplexity-ai-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-perplexity-ai-401-unauthorized",
              "call.in-progress.error-vapifault-perplexity-ai-403-model-access-denied",
              "call.in-progress.error-vapifault-perplexity-ai-429-exceeded-quota",
              "call.in-progress.error-providerfault-perplexity-ai-500-server-error",
              "call.in-progress.error-providerfault-perplexity-ai-503-server-overloaded-error",
              "pipeline-error-deepinfra-400-bad-request-validation-failed",
              "pipeline-error-deepinfra-401-unauthorized",
              "pipeline-error-deepinfra-403-model-access-denied",
              "pipeline-error-deepinfra-429-exceeded-quota",
              "pipeline-error-deepinfra-500-server-error",
              "pipeline-error-deepinfra-503-server-overloaded-error",
              "pipeline-error-deepinfra-llm-failed",
              "call.in-progress.error-vapifault-deepinfra-llm-failed",
              "call.in-progress.error-vapifault-deepinfra-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-deepinfra-401-unauthorized",
              "call.in-progress.error-vapifault-deepinfra-403-model-access-denied",
              "call.in-progress.error-vapifault-deepinfra-429-exceeded-quota",
              "call.in-progress.error-providerfault-deepinfra-500-server-error",
              "call.in-progress.error-providerfault-deepinfra-503-server-overloaded-error",
              "pipeline-error-runpod-400-bad-request-validation-failed",
              "pipeline-error-runpod-401-unauthorized",
              "pipeline-error-runpod-403-model-access-denied",
              "pipeline-error-runpod-429-exceeded-quota",
              "pipeline-error-runpod-500-server-error",
              "pipeline-error-runpod-503-server-overloaded-error",
              "pipeline-error-runpod-llm-failed",
              "call.in-progress.error-vapifault-runpod-llm-failed",
              "call.in-progress.error-vapifault-runpod-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-runpod-401-unauthorized",
              "call.in-progress.error-vapifault-runpod-403-model-access-denied",
              "call.in-progress.error-vapifault-runpod-429-exceeded-quota",
              "call.in-progress.error-providerfault-runpod-500-server-error",
              "call.in-progress.error-providerfault-runpod-503-server-overloaded-error",
              "pipeline-error-custom-llm-400-bad-request-validation-failed",
              "pipeline-error-custom-llm-401-unauthorized",
              "pipeline-error-custom-llm-403-model-access-denied",
              "pipeline-error-custom-llm-429-exceeded-quota",
              "pipeline-error-custom-llm-500-server-error",
              "pipeline-error-custom-llm-503-server-overloaded-error",
              "pipeline-error-custom-llm-llm-failed",
              "call.in-progress.error-vapifault-custom-llm-llm-failed",
              "call.in-progress.error-vapifault-custom-llm-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-custom-llm-401-unauthorized",
              "call.in-progress.error-vapifault-custom-llm-403-model-access-denied",
              "call.in-progress.error-vapifault-custom-llm-429-exceeded-quota",
              "call.in-progress.error-providerfault-custom-llm-500-server-error",
              "call.in-progress.error-providerfault-custom-llm-503-server-overloaded-error",
              "pipeline-error-custom-voice-failed",
              "pipeline-error-cartesia-socket-hang-up",
              "pipeline-error-cartesia-requested-payment",
              "pipeline-error-cartesia-500-server-error",
              "pipeline-error-cartesia-503-server-error",
              "pipeline-error-cartesia-522-server-error",
              "call.in-progress.error-vapifault-cartesia-socket-hang-up",
              "call.in-progress.error-vapifault-cartesia-requested-payment",
              "call.in-progress.error-providerfault-cartesia-500-server-error",
              "call.in-progress.error-providerfault-cartesia-503-server-error",
              "call.in-progress.error-providerfault-cartesia-522-server-error",
              "pipeline-error-eleven-labs-voice-not-found",
              "pipeline-error-eleven-labs-quota-exceeded",
              "pipeline-error-eleven-labs-unauthorized-access",
              "pipeline-error-eleven-labs-unauthorized-to-access-model",
              "pipeline-error-eleven-labs-professional-voices-only-for-creator-plus",
              "pipeline-error-eleven-labs-blocked-free-plan-and-requested-upgrade",
              "pipeline-error-eleven-labs-blocked-concurrent-requests-and-requested-upgrade",
              "pipeline-error-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade",
              "pipeline-error-eleven-labs-system-busy-and-requested-upgrade",
              "pipeline-error-eleven-labs-voice-not-fine-tuned",
              "pipeline-error-eleven-labs-invalid-api-key",
              "pipeline-error-eleven-labs-invalid-voice-samples",
              "pipeline-error-eleven-labs-voice-disabled-by-owner",
              "pipeline-error-eleven-labs-blocked-account-in-probation",
              "pipeline-error-eleven-labs-blocked-content-against-their-policy",
              "pipeline-error-eleven-labs-missing-samples-for-voice-clone",
              "pipeline-error-eleven-labs-voice-not-fine-tuned-and-cannot-be-used",
              "pipeline-error-eleven-labs-voice-not-allowed-for-free-users",
              "pipeline-error-eleven-labs-max-character-limit-exceeded",
              "pipeline-error-eleven-labs-blocked-voice-potentially-against-terms-of-service-and-awaiting-verification",
              "pipeline-error-eleven-labs-500-server-error",
              "call.in-progress.error-vapifault-eleven-labs-voice-not-found",
              "call.in-progress.error-vapifault-eleven-labs-quota-exceeded",
              "call.in-progress.error-vapifault-eleven-labs-unauthorized-access",
              "call.in-progress.error-vapifault-eleven-labs-unauthorized-to-access-model",
              "call.in-progress.error-vapifault-eleven-labs-professional-voices-only-for-creator-plus",
              "call.in-progress.error-vapifault-eleven-labs-blocked-free-plan-and-requested-upgrade",
              "call.in-progress.error-vapifault-eleven-labs-blocked-concurrent-requests-and-requested-upgrade",
              "call.in-progress.error-vapifault-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade",
              "call.in-progress.error-vapifault-eleven-labs-system-busy-and-requested-upgrade",
              "call.in-progress.error-vapifault-eleven-labs-voice-not-fine-tuned",
              "call.in-progress.error-vapifault-eleven-labs-invalid-api-key",
              "call.in-progress.error-vapifault-eleven-labs-invalid-voice-samples",
              "call.in-progress.error-vapifault-eleven-labs-voice-disabled-by-owner",
              "call.in-progress.error-vapifault-eleven-labs-blocked-account-in-probation",
              "call.in-progress.error-vapifault-eleven-labs-blocked-content-against-their-policy",
              "call.in-progress.error-vapifault-eleven-labs-missing-samples-for-voice-clone",
              "call.in-progress.error-vapifault-eleven-labs-voice-not-fine-tuned-and-cannot-be-used",
              "call.in-progress.error-vapifault-eleven-labs-voice-not-allowed-for-free-users",
              "call.in-progress.error-vapifault-eleven-labs-max-character-limit-exceeded",
              "call.in-progress.error-vapifault-eleven-labs-blocked-voice-potentially-against-terms-of-service-and-awaiting-verification",
              "call.in-progress.error-providerfault-eleven-labs-500-server-error",
              "pipeline-error-playht-request-timed-out",
              "pipeline-error-playht-invalid-voice",
              "pipeline-error-playht-unexpected-error",
              "pipeline-error-playht-out-of-credits",
              "pipeline-error-playht-invalid-emotion",
              "pipeline-error-playht-voice-must-be-a-valid-voice-manifest-uri",
              "pipeline-error-playht-401-unauthorized",
              "pipeline-error-playht-403-forbidden-out-of-characters",
              "pipeline-error-playht-403-forbidden-api-access-not-available",
              "pipeline-error-playht-429-exceeded-quota",
              "pipeline-error-playht-502-gateway-error",
              "pipeline-error-playht-504-gateway-error",
              "call.in-progress.error-vapifault-playht-request-timed-out",
              "call.in-progress.error-vapifault-playht-invalid-voice",
              "call.in-progress.error-vapifault-playht-unexpected-error",
              "call.in-progress.error-vapifault-playht-out-of-credits",
              "call.in-progress.error-vapifault-playht-invalid-emotion",
              "call.in-progress.error-vapifault-playht-voice-must-be-a-valid-voice-manifest-uri",
              "call.in-progress.error-vapifault-playht-401-unauthorized",
              "call.in-progress.error-vapifault-playht-403-forbidden-out-of-characters",
              "call.in-progress.error-vapifault-playht-403-forbidden-api-access-not-available",
              "call.in-progress.error-vapifault-playht-429-exceeded-quota",
              "call.in-progress.error-providerfault-playht-502-gateway-error",
              "call.in-progress.error-providerfault-playht-504-gateway-error",
              "pipeline-error-custom-transcriber-failed",
              "call.in-progress.error-vapifault-custom-transcriber-failed",
              "pipeline-error-eleven-labs-transcriber-failed",
              "call.in-progress.error-vapifault-eleven-labs-transcriber-failed",
              "pipeline-error-deepgram-returning-400-no-such-model-language-tier-combination",
              "pipeline-error-deepgram-returning-401-invalid-credentials",
              "pipeline-error-deepgram-returning-403-model-access-denied",
              "pipeline-error-deepgram-returning-404-not-found",
              "pipeline-error-deepgram-returning-500-invalid-json",
              "pipeline-error-deepgram-returning-502-network-error",
              "pipeline-error-deepgram-returning-502-bad-gateway-ehostunreach",
              "call.in-progress.error-vapifault-deepgram-returning-400-no-such-model-language-tier-combination",
              "call.in-progress.error-vapifault-deepgram-returning-401-invalid-credentials",
              "call.in-progress.error-vapifault-deepgram-returning-404-not-found",
              "call.in-progress.error-vapifault-deepgram-returning-403-model-access-denied",
              "call.in-progress.error-providerfault-deepgram-returning-500-invalid-json",
              "call.in-progress.error-providerfault-deepgram-returning-502-network-error",
              "call.in-progress.error-providerfault-deepgram-returning-502-bad-gateway-ehostunreach",
              "pipeline-error-google-transcriber-failed",
              "call.in-progress.error-vapifault-google-transcriber-failed",
              "pipeline-error-openai-transcriber-failed",
              "call.in-progress.error-vapifault-openai-transcriber-failed",
              "assistant-ended-call",
              "assistant-said-end-call-phrase",
              "assistant-ended-call-with-hangup-task",
              "assistant-ended-call-after-message-spoken",
              "assistant-forwarded-call",
              "assistant-join-timed-out",
              "call.in-progress.error-assistant-did-not-receive-customer-audio",
              "customer-busy",
              "customer-ended-call",
              "customer-did-not-answer",
              "customer-did-not-give-microphone-permission",
              "exceeded-max-duration",
              "manually-canceled",
              "phone-call-provider-closed-websocket",
              "call.forwarding.operator-busy",
              "silence-timed-out",
              "call.in-progress.error-sip-inbound-call-failed-to-connect",
              "call.in-progress.error-providerfault-outbound-sip-403-forbidden",
              "call.in-progress.error-providerfault-outbound-sip-407-proxy-authentication-required",
              "call.in-progress.error-providerfault-outbound-sip-503-service-unavailable",
              "call.in-progress.error-providerfault-outbound-sip-480-temporarily-unavailable",
              "call.in-progress.error-sip-outbound-call-failed-to-connect",
              "call.ringing.hook-executed-say",
              "call.ringing.hook-executed-transfer",
              "twilio-failed-to-connect-call",
              "twilio-reported-customer-misdialed",
              "vonage-rejected",
              "voicemail"
            ]
          },
          "cost": {
            "type": "number",
            "description": "This is the cost of the call in USD. This can also be found at `call.cost` on GET /call/:id."
          },
          "costs": {
            "type": "array",
            "description": "These are the costs of individual components of the call in USD. This can also be found at `call.costs` on GET /call/:id.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TransportCost",
                  "title": "TransportCost"
                },
                {
                  "$ref": "#/components/schemas/TranscriberCost",
                  "title": "TranscriberCost"
                },
                {
                  "$ref": "#/components/schemas/ModelCost",
                  "title": "ModelCost"
                },
                {
                  "$ref": "#/components/schemas/VoiceCost",
                  "title": "VoiceCost"
                },
                {
                  "$ref": "#/components/schemas/VapiCost",
                  "title": "VapiCost"
                },
                {
                  "$ref": "#/components/schemas/VoicemailDetectionCost",
                  "title": "VoicemailDetectionCost"
                },
                {
                  "$ref": "#/components/schemas/AnalysisCost",
                  "title": "AnalysisCost"
                },
                {
                  "$ref": "#/components/schemas/KnowledgeBaseCost",
                  "title": "KnowledgeBaseCost"
                }
              ]
            }
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "artifact": {
            "description": "These are the artifacts from the call. This can also be found at `call.artifact` on GET /call/:id.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Artifact"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "analysis": {
            "description": "This is the analysis of the call. This can also be found at `call.analysis` on GET /call/:id.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Analysis"
              }
            ]
          },
          "startedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the call started. This can also be found at `call.startedAt` on GET /call/:id."
          },
          "endedAt": {
            "format": "date-time",
            "type": "string",
            "description": "This is the ISO 8601 date-time string of when the call ended. This can also be found at `call.endedAt` on GET /call/:id."
          }
        },
        "required": [
          "type",
          "endedReason",
          "artifact",
          "analysis"
        ]
      },
      "ServerMessageHang": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"hang\" is sent when the assistant is hanging due to a delay. The delay can be caused by many factors, such as:\n- the model is too slow to respond\n- the voice is too slow to respond\n- the tool call is still waiting for a response from your server\n- etc.",
            "enum": [
              "hang"
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "artifact": {
            "description": "This is a live version of the `call.artifact`.\n\nThis matches what is stored on `call.artifact` after the call.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Artifact"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "ServerMessageKnowledgeBaseRequest": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"knowledge-base-request\" is sent to request knowledge base documents. To enable, use `assistant.knowledgeBase.provider=custom-knowledge-base`.",
            "enum": [
              "knowledge-base-request"
            ]
          },
          "messages": {
            "type": "array",
            "description": "These are the messages that are going to be sent to the `model` right after the `knowledge-base-request` webhook completes.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/UserMessage",
                  "title": "UserMessage"
                },
                {
                  "$ref": "#/components/schemas/SystemMessage",
                  "title": "SystemMessage"
                },
                {
                  "$ref": "#/components/schemas/BotMessage",
                  "title": "BotMessage"
                },
                {
                  "$ref": "#/components/schemas/ToolCallMessage",
                  "title": "ToolCallMessage"
                },
                {
                  "$ref": "#/components/schemas/ToolCallResultMessage",
                  "title": "ToolCallResultMessage"
                }
              ]
            }
          },
          "messagesOpenAIFormatted": {
            "description": "This is just `messages` formatted for OpenAI.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            }
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "artifact": {
            "description": "This is a live version of the `call.artifact`.\n\nThis matches what is stored on `call.artifact` after the call.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Artifact"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          }
        },
        "required": [
          "type",
          "messagesOpenAIFormatted"
        ]
      },
      "ServerMessageModelOutput": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"model-output\" is sent as the model outputs tokens.",
            "enum": [
              "model-output"
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "artifact": {
            "description": "This is a live version of the `call.artifact`.\n\nThis matches what is stored on `call.artifact` after the call.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Artifact"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "output": {
            "type": "object",
            "description": "This is the output of the model. It can be a token or tool call."
          }
        },
        "required": [
          "type",
          "output"
        ]
      },
      "ServerMessagePhoneCallControl": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"phone-call-control\" is an advanced type of message.\n\nWhen it is requested in `assistant.serverMessages`, the hangup and forwarding responsibilities are delegated to your server. Vapi will no longer do the actual transfer and hangup.",
            "enum": [
              "phone-call-control"
            ]
          },
          "request": {
            "type": "string",
            "description": "This is the request to control the phone call.",
            "enum": [
              "forward",
              "hang-up"
            ]
          },
          "destination": {
            "description": "This is the destination to forward the call to if the request is \"forward\".",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "artifact": {
            "description": "This is a live version of the `call.artifact`.\n\nThis matches what is stored on `call.artifact` after the call.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Artifact"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          }
        },
        "required": [
          "type",
          "request"
        ]
      },
      "ServerMessageSpeechUpdate": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"speech-update\" is sent whenever assistant or user start or stop speaking.",
            "enum": [
              "speech-update"
            ]
          },
          "status": {
            "type": "string",
            "description": "This is the status of the speech update.",
            "enum": [
              "started",
              "stopped"
            ]
          },
          "role": {
            "type": "string",
            "description": "This is the role which the speech update is for.",
            "enum": [
              "assistant",
              "user"
            ]
          },
          "turn": {
            "type": "number",
            "description": "This is the turn number of the speech update (0-indexed)."
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "artifact": {
            "description": "This is a live version of the `call.artifact`.\n\nThis matches what is stored on `call.artifact` after the call.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Artifact"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          }
        },
        "required": [
          "type",
          "status",
          "role"
        ]
      },
      "ServerMessageStatusUpdate": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"status-update\" is sent whenever the `call.status` changes.",
            "enum": [
              "status-update"
            ]
          },
          "status": {
            "type": "string",
            "description": "This is the status of the call.",
            "enum": [
              "scheduled",
              "queued",
              "ringing",
              "in-progress",
              "forwarding",
              "ended"
            ]
          },
          "endedReason": {
            "type": "string",
            "description": "This is the reason the call ended. This is only sent if the status is \"ended\".",
            "enum": [
              "call-start-error-neither-assistant-nor-server-set",
              "assistant-request-failed",
              "assistant-request-returned-error",
              "assistant-request-returned-unspeakable-error",
              "assistant-request-returned-invalid-assistant",
              "assistant-request-returned-no-assistant",
              "assistant-request-returned-forwarding-phone-number",
              "call.start.error-get-org",
              "call.start.error-get-subscription",
              "call.start.error-get-assistant",
              "call.start.error-get-phone-number",
              "call.start.error-get-customer",
              "call.start.error-get-resources-validation",
              "call.start.error-vapi-number-international",
              "call.start.error-vapi-number-outbound-daily-limit",
              "call.start.error-get-transport",
              "assistant-not-valid",
              "database-error",
              "assistant-not-found",
              "pipeline-error-openai-voice-failed",
              "pipeline-error-cartesia-voice-failed",
              "pipeline-error-deepgram-voice-failed",
              "pipeline-error-eleven-labs-voice-failed",
              "pipeline-error-playht-voice-failed",
              "pipeline-error-lmnt-voice-failed",
              "pipeline-error-azure-voice-failed",
              "pipeline-error-rime-ai-voice-failed",
              "pipeline-error-smallest-ai-voice-failed",
              "pipeline-error-neuphonic-voice-failed",
              "pipeline-error-hume-voice-failed",
              "pipeline-error-sesame-voice-failed",
              "pipeline-error-tavus-video-failed",
              "call.in-progress.error-vapifault-openai-voice-failed",
              "call.in-progress.error-vapifault-cartesia-voice-failed",
              "call.in-progress.error-vapifault-deepgram-voice-failed",
              "call.in-progress.error-vapifault-eleven-labs-voice-failed",
              "call.in-progress.error-vapifault-playht-voice-failed",
              "call.in-progress.error-vapifault-lmnt-voice-failed",
              "call.in-progress.error-vapifault-azure-voice-failed",
              "call.in-progress.error-vapifault-rime-ai-voice-failed",
              "call.in-progress.error-vapifault-smallest-ai-voice-failed",
              "call.in-progress.error-vapifault-neuphonic-voice-failed",
              "call.in-progress.error-vapifault-hume-voice-failed",
              "call.in-progress.error-vapifault-sesame-voice-failed",
              "call.in-progress.error-vapifault-tavus-video-failed",
              "pipeline-error-vapi-llm-failed",
              "pipeline-error-vapi-400-bad-request-validation-failed",
              "pipeline-error-vapi-401-unauthorized",
              "pipeline-error-vapi-403-model-access-denied",
              "pipeline-error-vapi-429-exceeded-quota",
              "pipeline-error-vapi-500-server-error",
              "pipeline-error-vapi-503-server-overloaded-error",
              "call.in-progress.error-vapifault-vapi-llm-failed",
              "call.in-progress.error-vapifault-vapi-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-vapi-401-unauthorized",
              "call.in-progress.error-vapifault-vapi-403-model-access-denied",
              "call.in-progress.error-vapifault-vapi-429-exceeded-quota",
              "call.in-progress.error-providerfault-vapi-500-server-error",
              "call.in-progress.error-providerfault-vapi-503-server-overloaded-error",
              "pipeline-error-deepgram-transcriber-failed",
              "call.in-progress.error-vapifault-deepgram-transcriber-failed",
              "pipeline-error-gladia-transcriber-failed",
              "call.in-progress.error-vapifault-gladia-transcriber-failed",
              "pipeline-error-speechmatics-transcriber-failed",
              "call.in-progress.error-vapifault-speechmatics-transcriber-failed",
              "pipeline-error-assembly-ai-transcriber-failed",
              "pipeline-error-assembly-ai-returning-400-insufficent-funds",
              "pipeline-error-assembly-ai-returning-400-paid-only-feature",
              "pipeline-error-assembly-ai-returning-401-invalid-credentials",
              "pipeline-error-assembly-ai-returning-500-invalid-schema",
              "pipeline-error-assembly-ai-returning-500-word-boost-parsing-failed",
              "call.in-progress.error-vapifault-assembly-ai-transcriber-failed",
              "call.in-progress.error-vapifault-assembly-ai-returning-400-insufficent-funds",
              "call.in-progress.error-vapifault-assembly-ai-returning-400-paid-only-feature",
              "call.in-progress.error-vapifault-assembly-ai-returning-401-invalid-credentials",
              "call.in-progress.error-vapifault-assembly-ai-returning-500-invalid-schema",
              "call.in-progress.error-vapifault-assembly-ai-returning-500-word-boost-parsing-failed",
              "pipeline-error-talkscriber-transcriber-failed",
              "call.in-progress.error-vapifault-talkscriber-transcriber-failed",
              "pipeline-error-azure-speech-transcriber-failed",
              "call.in-progress.error-vapifault-azure-speech-transcriber-failed",
              "call.in-progress.error-pipeline-no-available-llm-model",
              "worker-shutdown",
              "unknown-error",
              "vonage-disconnected",
              "vonage-failed-to-connect-call",
              "vonage-completed",
              "phone-call-provider-bypass-enabled-but-no-call-received",
              "call.in-progress.error-providerfault-transport-never-connected",
              "call.in-progress.error-vapifault-worker-not-available",
              "call.in-progress.error-vapifault-transport-never-connected",
              "call.in-progress.error-vapifault-transport-connected-but-call-not-active",
              "call.in-progress.error-vapifault-call-started-but-connection-to-transport-missing",
              "call.in-progress.error-vapifault-worker-died",
              "call.in-progress.error-vapifault-openai-llm-failed",
              "call.in-progress.error-vapifault-azure-openai-llm-failed",
              "call.in-progress.error-vapifault-groq-llm-failed",
              "call.in-progress.error-vapifault-google-llm-failed",
              "call.in-progress.error-vapifault-xai-llm-failed",
              "call.in-progress.error-vapifault-mistral-llm-failed",
              "call.in-progress.error-vapifault-inflection-ai-llm-failed",
              "call.in-progress.error-vapifault-cerebras-llm-failed",
              "call.in-progress.error-vapifault-deep-seek-llm-failed",
              "pipeline-error-openai-400-bad-request-validation-failed",
              "pipeline-error-openai-401-unauthorized",
              "pipeline-error-openai-401-incorrect-api-key",
              "pipeline-error-openai-401-account-not-in-organization",
              "pipeline-error-openai-403-model-access-denied",
              "pipeline-error-openai-429-exceeded-quota",
              "pipeline-error-openai-429-rate-limit-reached",
              "pipeline-error-openai-500-server-error",
              "pipeline-error-openai-503-server-overloaded-error",
              "pipeline-error-openai-llm-failed",
              "call.in-progress.error-vapifault-openai-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-openai-401-unauthorized",
              "call.in-progress.error-vapifault-openai-401-incorrect-api-key",
              "call.in-progress.error-vapifault-openai-401-account-not-in-organization",
              "call.in-progress.error-vapifault-openai-403-model-access-denied",
              "call.in-progress.error-vapifault-openai-429-exceeded-quota",
              "call.in-progress.error-vapifault-openai-429-rate-limit-reached",
              "call.in-progress.error-providerfault-openai-500-server-error",
              "call.in-progress.error-providerfault-openai-503-server-overloaded-error",
              "pipeline-error-azure-openai-400-bad-request-validation-failed",
              "pipeline-error-azure-openai-401-unauthorized",
              "pipeline-error-azure-openai-403-model-access-denied",
              "pipeline-error-azure-openai-429-exceeded-quota",
              "pipeline-error-azure-openai-500-server-error",
              "pipeline-error-azure-openai-503-server-overloaded-error",
              "pipeline-error-azure-openai-llm-failed",
              "call.in-progress.error-vapifault-azure-openai-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-azure-openai-401-unauthorized",
              "call.in-progress.error-vapifault-azure-openai-403-model-access-denied",
              "call.in-progress.error-vapifault-azure-openai-429-exceeded-quota",
              "call.in-progress.error-providerfault-azure-openai-500-server-error",
              "call.in-progress.error-providerfault-azure-openai-503-server-overloaded-error",
              "pipeline-error-google-400-bad-request-validation-failed",
              "pipeline-error-google-401-unauthorized",
              "pipeline-error-google-403-model-access-denied",
              "pipeline-error-google-429-exceeded-quota",
              "pipeline-error-google-500-server-error",
              "pipeline-error-google-503-server-overloaded-error",
              "pipeline-error-google-llm-failed",
              "call.in-progress.error-vapifault-google-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-google-401-unauthorized",
              "call.in-progress.error-vapifault-google-403-model-access-denied",
              "call.in-progress.error-vapifault-google-429-exceeded-quota",
              "call.in-progress.error-providerfault-google-500-server-error",
              "call.in-progress.error-providerfault-google-503-server-overloaded-error",
              "pipeline-error-xai-400-bad-request-validation-failed",
              "pipeline-error-xai-401-unauthorized",
              "pipeline-error-xai-403-model-access-denied",
              "pipeline-error-xai-429-exceeded-quota",
              "pipeline-error-xai-500-server-error",
              "pipeline-error-xai-503-server-overloaded-error",
              "pipeline-error-xai-llm-failed",
              "call.in-progress.error-vapifault-xai-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-xai-401-unauthorized",
              "call.in-progress.error-vapifault-xai-403-model-access-denied",
              "call.in-progress.error-vapifault-xai-429-exceeded-quota",
              "call.in-progress.error-providerfault-xai-500-server-error",
              "call.in-progress.error-providerfault-xai-503-server-overloaded-error",
              "pipeline-error-mistral-400-bad-request-validation-failed",
              "pipeline-error-mistral-401-unauthorized",
              "pipeline-error-mistral-403-model-access-denied",
              "pipeline-error-mistral-429-exceeded-quota",
              "pipeline-error-mistral-500-server-error",
              "pipeline-error-mistral-503-server-overloaded-error",
              "pipeline-error-mistral-llm-failed",
              "call.in-progress.error-vapifault-mistral-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-mistral-401-unauthorized",
              "call.in-progress.error-vapifault-mistral-403-model-access-denied",
              "call.in-progress.error-vapifault-mistral-429-exceeded-quota",
              "call.in-progress.error-providerfault-mistral-500-server-error",
              "call.in-progress.error-providerfault-mistral-503-server-overloaded-error",
              "pipeline-error-inflection-ai-400-bad-request-validation-failed",
              "pipeline-error-inflection-ai-401-unauthorized",
              "pipeline-error-inflection-ai-403-model-access-denied",
              "pipeline-error-inflection-ai-429-exceeded-quota",
              "pipeline-error-inflection-ai-500-server-error",
              "pipeline-error-inflection-ai-503-server-overloaded-error",
              "pipeline-error-inflection-ai-llm-failed",
              "call.in-progress.error-vapifault-inflection-ai-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-inflection-ai-401-unauthorized",
              "call.in-progress.error-vapifault-inflection-ai-403-model-access-denied",
              "call.in-progress.error-vapifault-inflection-ai-429-exceeded-quota",
              "call.in-progress.error-providerfault-inflection-ai-500-server-error",
              "call.in-progress.error-providerfault-inflection-ai-503-server-overloaded-error",
              "pipeline-error-deep-seek-400-bad-request-validation-failed",
              "pipeline-error-deep-seek-401-unauthorized",
              "pipeline-error-deep-seek-403-model-access-denied",
              "pipeline-error-deep-seek-429-exceeded-quota",
              "pipeline-error-deep-seek-500-server-error",
              "pipeline-error-deep-seek-503-server-overloaded-error",
              "pipeline-error-deep-seek-llm-failed",
              "call.in-progress.error-vapifault-deep-seek-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-deep-seek-401-unauthorized",
              "call.in-progress.error-vapifault-deep-seek-403-model-access-denied",
              "call.in-progress.error-vapifault-deep-seek-429-exceeded-quota",
              "call.in-progress.error-providerfault-deep-seek-500-server-error",
              "call.in-progress.error-providerfault-deep-seek-503-server-overloaded-error",
              "pipeline-error-groq-400-bad-request-validation-failed",
              "pipeline-error-groq-401-unauthorized",
              "pipeline-error-groq-403-model-access-denied",
              "pipeline-error-groq-429-exceeded-quota",
              "pipeline-error-groq-500-server-error",
              "pipeline-error-groq-503-server-overloaded-error",
              "pipeline-error-groq-llm-failed",
              "call.in-progress.error-vapifault-groq-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-groq-401-unauthorized",
              "call.in-progress.error-vapifault-groq-403-model-access-denied",
              "call.in-progress.error-vapifault-groq-429-exceeded-quota",
              "call.in-progress.error-providerfault-groq-500-server-error",
              "call.in-progress.error-providerfault-groq-503-server-overloaded-error",
              "pipeline-error-cerebras-400-bad-request-validation-failed",
              "pipeline-error-cerebras-401-unauthorized",
              "pipeline-error-cerebras-403-model-access-denied",
              "pipeline-error-cerebras-429-exceeded-quota",
              "pipeline-error-cerebras-500-server-error",
              "pipeline-error-cerebras-503-server-overloaded-error",
              "pipeline-error-cerebras-llm-failed",
              "call.in-progress.error-vapifault-cerebras-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-cerebras-401-unauthorized",
              "call.in-progress.error-vapifault-cerebras-403-model-access-denied",
              "call.in-progress.error-vapifault-cerebras-429-exceeded-quota",
              "call.in-progress.error-providerfault-cerebras-500-server-error",
              "call.in-progress.error-providerfault-cerebras-503-server-overloaded-error",
              "pipeline-error-anthropic-400-bad-request-validation-failed",
              "pipeline-error-anthropic-401-unauthorized",
              "pipeline-error-anthropic-403-model-access-denied",
              "pipeline-error-anthropic-429-exceeded-quota",
              "pipeline-error-anthropic-500-server-error",
              "pipeline-error-anthropic-503-server-overloaded-error",
              "pipeline-error-anthropic-llm-failed",
              "call.in-progress.error-vapifault-anthropic-llm-failed",
              "call.in-progress.error-vapifault-anthropic-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-anthropic-401-unauthorized",
              "call.in-progress.error-vapifault-anthropic-403-model-access-denied",
              "call.in-progress.error-vapifault-anthropic-429-exceeded-quota",
              "call.in-progress.error-providerfault-anthropic-500-server-error",
              "call.in-progress.error-providerfault-anthropic-503-server-overloaded-error",
              "pipeline-error-anthropic-bedrock-400-bad-request-validation-failed",
              "pipeline-error-anthropic-bedrock-401-unauthorized",
              "pipeline-error-anthropic-bedrock-403-model-access-denied",
              "pipeline-error-anthropic-bedrock-429-exceeded-quota",
              "pipeline-error-anthropic-bedrock-500-server-error",
              "pipeline-error-anthropic-bedrock-503-server-overloaded-error",
              "pipeline-error-anthropic-bedrock-llm-failed",
              "call.in-progress.error-vapifault-anthropic-bedrock-llm-failed",
              "call.in-progress.error-vapifault-anthropic-bedrock-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-anthropic-bedrock-401-unauthorized",
              "call.in-progress.error-vapifault-anthropic-bedrock-403-model-access-denied",
              "call.in-progress.error-vapifault-anthropic-bedrock-429-exceeded-quota",
              "call.in-progress.error-providerfault-anthropic-bedrock-500-server-error",
              "call.in-progress.error-providerfault-anthropic-bedrock-503-server-overloaded-error",
              "pipeline-error-anthropic-vertex-400-bad-request-validation-failed",
              "pipeline-error-anthropic-vertex-401-unauthorized",
              "pipeline-error-anthropic-vertex-403-model-access-denied",
              "pipeline-error-anthropic-vertex-429-exceeded-quota",
              "pipeline-error-anthropic-vertex-500-server-error",
              "pipeline-error-anthropic-vertex-503-server-overloaded-error",
              "pipeline-error-anthropic-vertex-llm-failed",
              "call.in-progress.error-vapifault-anthropic-vertex-llm-failed",
              "call.in-progress.error-vapifault-anthropic-vertex-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-anthropic-vertex-401-unauthorized",
              "call.in-progress.error-vapifault-anthropic-vertex-403-model-access-denied",
              "call.in-progress.error-vapifault-anthropic-vertex-429-exceeded-quota",
              "call.in-progress.error-providerfault-anthropic-vertex-500-server-error",
              "call.in-progress.error-providerfault-anthropic-vertex-503-server-overloaded-error",
              "pipeline-error-together-ai-400-bad-request-validation-failed",
              "pipeline-error-together-ai-401-unauthorized",
              "pipeline-error-together-ai-403-model-access-denied",
              "pipeline-error-together-ai-429-exceeded-quota",
              "pipeline-error-together-ai-500-server-error",
              "pipeline-error-together-ai-503-server-overloaded-error",
              "pipeline-error-together-ai-llm-failed",
              "call.in-progress.error-vapifault-together-ai-llm-failed",
              "call.in-progress.error-vapifault-together-ai-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-together-ai-401-unauthorized",
              "call.in-progress.error-vapifault-together-ai-403-model-access-denied",
              "call.in-progress.error-vapifault-together-ai-429-exceeded-quota",
              "call.in-progress.error-providerfault-together-ai-500-server-error",
              "call.in-progress.error-providerfault-together-ai-503-server-overloaded-error",
              "pipeline-error-anyscale-400-bad-request-validation-failed",
              "pipeline-error-anyscale-401-unauthorized",
              "pipeline-error-anyscale-403-model-access-denied",
              "pipeline-error-anyscale-429-exceeded-quota",
              "pipeline-error-anyscale-500-server-error",
              "pipeline-error-anyscale-503-server-overloaded-error",
              "pipeline-error-anyscale-llm-failed",
              "call.in-progress.error-vapifault-anyscale-llm-failed",
              "call.in-progress.error-vapifault-anyscale-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-anyscale-401-unauthorized",
              "call.in-progress.error-vapifault-anyscale-403-model-access-denied",
              "call.in-progress.error-vapifault-anyscale-429-exceeded-quota",
              "call.in-progress.error-providerfault-anyscale-500-server-error",
              "call.in-progress.error-providerfault-anyscale-503-server-overloaded-error",
              "pipeline-error-openrouter-400-bad-request-validation-failed",
              "pipeline-error-openrouter-401-unauthorized",
              "pipeline-error-openrouter-403-model-access-denied",
              "pipeline-error-openrouter-429-exceeded-quota",
              "pipeline-error-openrouter-500-server-error",
              "pipeline-error-openrouter-503-server-overloaded-error",
              "pipeline-error-openrouter-llm-failed",
              "call.in-progress.error-vapifault-openrouter-llm-failed",
              "call.in-progress.error-vapifault-openrouter-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-openrouter-401-unauthorized",
              "call.in-progress.error-vapifault-openrouter-403-model-access-denied",
              "call.in-progress.error-vapifault-openrouter-429-exceeded-quota",
              "call.in-progress.error-providerfault-openrouter-500-server-error",
              "call.in-progress.error-providerfault-openrouter-503-server-overloaded-error",
              "pipeline-error-perplexity-ai-400-bad-request-validation-failed",
              "pipeline-error-perplexity-ai-401-unauthorized",
              "pipeline-error-perplexity-ai-403-model-access-denied",
              "pipeline-error-perplexity-ai-429-exceeded-quota",
              "pipeline-error-perplexity-ai-500-server-error",
              "pipeline-error-perplexity-ai-503-server-overloaded-error",
              "pipeline-error-perplexity-ai-llm-failed",
              "call.in-progress.error-vapifault-perplexity-ai-llm-failed",
              "call.in-progress.error-vapifault-perplexity-ai-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-perplexity-ai-401-unauthorized",
              "call.in-progress.error-vapifault-perplexity-ai-403-model-access-denied",
              "call.in-progress.error-vapifault-perplexity-ai-429-exceeded-quota",
              "call.in-progress.error-providerfault-perplexity-ai-500-server-error",
              "call.in-progress.error-providerfault-perplexity-ai-503-server-overloaded-error",
              "pipeline-error-deepinfra-400-bad-request-validation-failed",
              "pipeline-error-deepinfra-401-unauthorized",
              "pipeline-error-deepinfra-403-model-access-denied",
              "pipeline-error-deepinfra-429-exceeded-quota",
              "pipeline-error-deepinfra-500-server-error",
              "pipeline-error-deepinfra-503-server-overloaded-error",
              "pipeline-error-deepinfra-llm-failed",
              "call.in-progress.error-vapifault-deepinfra-llm-failed",
              "call.in-progress.error-vapifault-deepinfra-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-deepinfra-401-unauthorized",
              "call.in-progress.error-vapifault-deepinfra-403-model-access-denied",
              "call.in-progress.error-vapifault-deepinfra-429-exceeded-quota",
              "call.in-progress.error-providerfault-deepinfra-500-server-error",
              "call.in-progress.error-providerfault-deepinfra-503-server-overloaded-error",
              "pipeline-error-runpod-400-bad-request-validation-failed",
              "pipeline-error-runpod-401-unauthorized",
              "pipeline-error-runpod-403-model-access-denied",
              "pipeline-error-runpod-429-exceeded-quota",
              "pipeline-error-runpod-500-server-error",
              "pipeline-error-runpod-503-server-overloaded-error",
              "pipeline-error-runpod-llm-failed",
              "call.in-progress.error-vapifault-runpod-llm-failed",
              "call.in-progress.error-vapifault-runpod-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-runpod-401-unauthorized",
              "call.in-progress.error-vapifault-runpod-403-model-access-denied",
              "call.in-progress.error-vapifault-runpod-429-exceeded-quota",
              "call.in-progress.error-providerfault-runpod-500-server-error",
              "call.in-progress.error-providerfault-runpod-503-server-overloaded-error",
              "pipeline-error-custom-llm-400-bad-request-validation-failed",
              "pipeline-error-custom-llm-401-unauthorized",
              "pipeline-error-custom-llm-403-model-access-denied",
              "pipeline-error-custom-llm-429-exceeded-quota",
              "pipeline-error-custom-llm-500-server-error",
              "pipeline-error-custom-llm-503-server-overloaded-error",
              "pipeline-error-custom-llm-llm-failed",
              "call.in-progress.error-vapifault-custom-llm-llm-failed",
              "call.in-progress.error-vapifault-custom-llm-400-bad-request-validation-failed",
              "call.in-progress.error-vapifault-custom-llm-401-unauthorized",
              "call.in-progress.error-vapifault-custom-llm-403-model-access-denied",
              "call.in-progress.error-vapifault-custom-llm-429-exceeded-quota",
              "call.in-progress.error-providerfault-custom-llm-500-server-error",
              "call.in-progress.error-providerfault-custom-llm-503-server-overloaded-error",
              "pipeline-error-custom-voice-failed",
              "pipeline-error-cartesia-socket-hang-up",
              "pipeline-error-cartesia-requested-payment",
              "pipeline-error-cartesia-500-server-error",
              "pipeline-error-cartesia-503-server-error",
              "pipeline-error-cartesia-522-server-error",
              "call.in-progress.error-vapifault-cartesia-socket-hang-up",
              "call.in-progress.error-vapifault-cartesia-requested-payment",
              "call.in-progress.error-providerfault-cartesia-500-server-error",
              "call.in-progress.error-providerfault-cartesia-503-server-error",
              "call.in-progress.error-providerfault-cartesia-522-server-error",
              "pipeline-error-eleven-labs-voice-not-found",
              "pipeline-error-eleven-labs-quota-exceeded",
              "pipeline-error-eleven-labs-unauthorized-access",
              "pipeline-error-eleven-labs-unauthorized-to-access-model",
              "pipeline-error-eleven-labs-professional-voices-only-for-creator-plus",
              "pipeline-error-eleven-labs-blocked-free-plan-and-requested-upgrade",
              "pipeline-error-eleven-labs-blocked-concurrent-requests-and-requested-upgrade",
              "pipeline-error-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade",
              "pipeline-error-eleven-labs-system-busy-and-requested-upgrade",
              "pipeline-error-eleven-labs-voice-not-fine-tuned",
              "pipeline-error-eleven-labs-invalid-api-key",
              "pipeline-error-eleven-labs-invalid-voice-samples",
              "pipeline-error-eleven-labs-voice-disabled-by-owner",
              "pipeline-error-eleven-labs-blocked-account-in-probation",
              "pipeline-error-eleven-labs-blocked-content-against-their-policy",
              "pipeline-error-eleven-labs-missing-samples-for-voice-clone",
              "pipeline-error-eleven-labs-voice-not-fine-tuned-and-cannot-be-used",
              "pipeline-error-eleven-labs-voice-not-allowed-for-free-users",
              "pipeline-error-eleven-labs-max-character-limit-exceeded",
              "pipeline-error-eleven-labs-blocked-voice-potentially-against-terms-of-service-and-awaiting-verification",
              "pipeline-error-eleven-labs-500-server-error",
              "call.in-progress.error-vapifault-eleven-labs-voice-not-found",
              "call.in-progress.error-vapifault-eleven-labs-quota-exceeded",
              "call.in-progress.error-vapifault-eleven-labs-unauthorized-access",
              "call.in-progress.error-vapifault-eleven-labs-unauthorized-to-access-model",
              "call.in-progress.error-vapifault-eleven-labs-professional-voices-only-for-creator-plus",
              "call.in-progress.error-vapifault-eleven-labs-blocked-free-plan-and-requested-upgrade",
              "call.in-progress.error-vapifault-eleven-labs-blocked-concurrent-requests-and-requested-upgrade",
              "call.in-progress.error-vapifault-eleven-labs-blocked-using-instant-voice-clone-and-requested-upgrade",
              "call.in-progress.error-vapifault-eleven-labs-system-busy-and-requested-upgrade",
              "call.in-progress.error-vapifault-eleven-labs-voice-not-fine-tuned",
              "call.in-progress.error-vapifault-eleven-labs-invalid-api-key",
              "call.in-progress.error-vapifault-eleven-labs-invalid-voice-samples",
              "call.in-progress.error-vapifault-eleven-labs-voice-disabled-by-owner",
              "call.in-progress.error-vapifault-eleven-labs-blocked-account-in-probation",
              "call.in-progress.error-vapifault-eleven-labs-blocked-content-against-their-policy",
              "call.in-progress.error-vapifault-eleven-labs-missing-samples-for-voice-clone",
              "call.in-progress.error-vapifault-eleven-labs-voice-not-fine-tuned-and-cannot-be-used",
              "call.in-progress.error-vapifault-eleven-labs-voice-not-allowed-for-free-users",
              "call.in-progress.error-vapifault-eleven-labs-max-character-limit-exceeded",
              "call.in-progress.error-vapifault-eleven-labs-blocked-voice-potentially-against-terms-of-service-and-awaiting-verification",
              "call.in-progress.error-providerfault-eleven-labs-500-server-error",
              "pipeline-error-playht-request-timed-out",
              "pipeline-error-playht-invalid-voice",
              "pipeline-error-playht-unexpected-error",
              "pipeline-error-playht-out-of-credits",
              "pipeline-error-playht-invalid-emotion",
              "pipeline-error-playht-voice-must-be-a-valid-voice-manifest-uri",
              "pipeline-error-playht-401-unauthorized",
              "pipeline-error-playht-403-forbidden-out-of-characters",
              "pipeline-error-playht-403-forbidden-api-access-not-available",
              "pipeline-error-playht-429-exceeded-quota",
              "pipeline-error-playht-502-gateway-error",
              "pipeline-error-playht-504-gateway-error",
              "call.in-progress.error-vapifault-playht-request-timed-out",
              "call.in-progress.error-vapifault-playht-invalid-voice",
              "call.in-progress.error-vapifault-playht-unexpected-error",
              "call.in-progress.error-vapifault-playht-out-of-credits",
              "call.in-progress.error-vapifault-playht-invalid-emotion",
              "call.in-progress.error-vapifault-playht-voice-must-be-a-valid-voice-manifest-uri",
              "call.in-progress.error-vapifault-playht-401-unauthorized",
              "call.in-progress.error-vapifault-playht-403-forbidden-out-of-characters",
              "call.in-progress.error-vapifault-playht-403-forbidden-api-access-not-available",
              "call.in-progress.error-vapifault-playht-429-exceeded-quota",
              "call.in-progress.error-providerfault-playht-502-gateway-error",
              "call.in-progress.error-providerfault-playht-504-gateway-error",
              "pipeline-error-custom-transcriber-failed",
              "call.in-progress.error-vapifault-custom-transcriber-failed",
              "pipeline-error-eleven-labs-transcriber-failed",
              "call.in-progress.error-vapifault-eleven-labs-transcriber-failed",
              "pipeline-error-deepgram-returning-400-no-such-model-language-tier-combination",
              "pipeline-error-deepgram-returning-401-invalid-credentials",
              "pipeline-error-deepgram-returning-403-model-access-denied",
              "pipeline-error-deepgram-returning-404-not-found",
              "pipeline-error-deepgram-returning-500-invalid-json",
              "pipeline-error-deepgram-returning-502-network-error",
              "pipeline-error-deepgram-returning-502-bad-gateway-ehostunreach",
              "call.in-progress.error-vapifault-deepgram-returning-400-no-such-model-language-tier-combination",
              "call.in-progress.error-vapifault-deepgram-returning-401-invalid-credentials",
              "call.in-progress.error-vapifault-deepgram-returning-404-not-found",
              "call.in-progress.error-vapifault-deepgram-returning-403-model-access-denied",
              "call.in-progress.error-providerfault-deepgram-returning-500-invalid-json",
              "call.in-progress.error-providerfault-deepgram-returning-502-network-error",
              "call.in-progress.error-providerfault-deepgram-returning-502-bad-gateway-ehostunreach",
              "pipeline-error-google-transcriber-failed",
              "call.in-progress.error-vapifault-google-transcriber-failed",
              "pipeline-error-openai-transcriber-failed",
              "call.in-progress.error-vapifault-openai-transcriber-failed",
              "assistant-ended-call",
              "assistant-said-end-call-phrase",
              "assistant-ended-call-with-hangup-task",
              "assistant-ended-call-after-message-spoken",
              "assistant-forwarded-call",
              "assistant-join-timed-out",
              "call.in-progress.error-assistant-did-not-receive-customer-audio",
              "customer-busy",
              "customer-ended-call",
              "customer-did-not-answer",
              "customer-did-not-give-microphone-permission",
              "exceeded-max-duration",
              "manually-canceled",
              "phone-call-provider-closed-websocket",
              "call.forwarding.operator-busy",
              "silence-timed-out",
              "call.in-progress.error-sip-inbound-call-failed-to-connect",
              "call.in-progress.error-providerfault-outbound-sip-403-forbidden",
              "call.in-progress.error-providerfault-outbound-sip-407-proxy-authentication-required",
              "call.in-progress.error-providerfault-outbound-sip-503-service-unavailable",
              "call.in-progress.error-providerfault-outbound-sip-480-temporarily-unavailable",
              "call.in-progress.error-sip-outbound-call-failed-to-connect",
              "call.ringing.hook-executed-say",
              "call.ringing.hook-executed-transfer",
              "twilio-failed-to-connect-call",
              "twilio-reported-customer-misdialed",
              "vonage-rejected",
              "voicemail"
            ]
          },
          "messages": {
            "type": "array",
            "description": "These are the conversation messages of the call. This is only sent if the status is \"forwarding\".",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/UserMessage",
                  "title": "UserMessage"
                },
                {
                  "$ref": "#/components/schemas/SystemMessage",
                  "title": "SystemMessage"
                },
                {
                  "$ref": "#/components/schemas/BotMessage",
                  "title": "BotMessage"
                },
                {
                  "$ref": "#/components/schemas/ToolCallMessage",
                  "title": "ToolCallMessage"
                },
                {
                  "$ref": "#/components/schemas/ToolCallResultMessage",
                  "title": "ToolCallResultMessage"
                }
              ]
            }
          },
          "messagesOpenAIFormatted": {
            "description": "These are the conversation messages of the call. This is only sent if the status is \"forwarding\".",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OpenAIMessage"
            }
          },
          "destination": {
            "description": "This is the destination the call is being transferred to. This is only sent if the status is \"forwarding\".",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "artifact": {
            "description": "This is a live version of the `call.artifact`.\n\nThis matches what is stored on `call.artifact` after the call.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Artifact"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "transcript": {
            "type": "string",
            "description": "This is the transcript of the call. This is only sent if the status is \"forwarding\"."
          },
          "summary": {
            "type": "string",
            "description": "This is the summary of the call. This is only sent if the status is \"forwarding\"."
          },
          "inboundPhoneCallDebuggingArtifacts": {
            "type": "object",
            "description": "This is the inbound phone call debugging artifacts. This is only sent if the status is \"ended\" and there was an error accepting the inbound phone call.\n\nThis will include any errors related to the \"assistant-request\" if one was made."
          }
        },
        "required": [
          "type",
          "status"
        ]
      },
      "ServerMessageToolCalls": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"tool-calls\" is sent to call a tool.",
            "enum": [
              "tool-calls"
            ]
          },
          "toolWithToolCallList": {
            "type": "array",
            "description": "This is the list of tools calls that the model is requesting along with the original tool configuration.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/FunctionToolWithToolCall",
                  "title": "FunctionToolWithToolCall"
                },
                {
                  "$ref": "#/components/schemas/GhlToolWithToolCall",
                  "title": "GhlToolWithToolCall"
                },
                {
                  "$ref": "#/components/schemas/MakeToolWithToolCall",
                  "title": "MakeToolWithToolCall"
                },
                {
                  "$ref": "#/components/schemas/BashToolWithToolCall",
                  "title": "BashToolWithToolCall"
                },
                {
                  "$ref": "#/components/schemas/ComputerToolWithToolCall",
                  "title": "ComputerToolWithToolCall"
                },
                {
                  "$ref": "#/components/schemas/TextEditorToolWithToolCall",
                  "title": "TextEditorToolWithToolCall"
                },
                {
                  "$ref": "#/components/schemas/GoogleCalendarCreateEventToolWithToolCall",
                  "title": "GoogleCalendarCreateEventToolWithToolCall"
                }
              ]
            }
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "artifact": {
            "description": "This is a live version of the `call.artifact`.\n\nThis matches what is stored on `call.artifact` after the call.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Artifact"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "toolCallList": {
            "description": "This is the list of tool calls that the model is requesting.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ToolCall"
            }
          }
        },
        "required": [
          "toolWithToolCallList",
          "toolCallList"
        ]
      },
      "ServerMessageTransferDestinationRequest": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"transfer-destination-request\" is sent when the model is requesting transfer but destination is unknown.",
            "enum": [
              "transfer-destination-request"
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "artifact": {
            "description": "This is a live version of the `call.artifact`.\n\nThis matches what is stored on `call.artifact` after the call.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Artifact"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "ServerMessageTransferUpdate": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"transfer-update\" is sent whenever a transfer happens.",
            "enum": [
              "transfer-update"
            ]
          },
          "destination": {
            "description": "This is the destination of the transfer.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationAssistant",
                "title": "Assistant"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "Number"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "Sip"
              }
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "artifact": {
            "description": "This is a live version of the `call.artifact`.\n\nThis matches what is stored on `call.artifact` after the call.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Artifact"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "toAssistant": {
            "description": "This is the assistant that the call is being transferred to. This is only sent if `destination.type` is \"assistant\".",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "fromAssistant": {
            "description": "This is the assistant that the call is being transferred from. This is only sent if `destination.type` is \"assistant\".",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "toStepRecord": {
            "type": "object",
            "description": "This is the step that the conversation moved to."
          },
          "fromStepRecord": {
            "type": "object",
            "description": "This is the step that the conversation moved from. ="
          }
        },
        "required": [
          "type"
        ]
      },
      "ServerMessageTranscript": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"transcript\" is sent as transcriber outputs partial or final transcript.",
            "enum": [
              "transcript",
              "transcript[transcriptType=\"final\"]"
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "artifact": {
            "description": "This is a live version of the `call.artifact`.\n\nThis matches what is stored on `call.artifact` after the call.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Artifact"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "role": {
            "type": "string",
            "description": "This is the role for which the transcript is for.",
            "enum": [
              "assistant",
              "user"
            ]
          },
          "transcriptType": {
            "type": "string",
            "description": "This is the type of the transcript.",
            "enum": [
              "partial",
              "final"
            ]
          },
          "transcript": {
            "type": "string",
            "description": "This is the transcript content."
          }
        },
        "required": [
          "type",
          "role",
          "transcriptType",
          "transcript"
        ]
      },
      "ServerMessageUserInterrupted": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"user-interrupted\" is sent when the user interrupts the assistant.",
            "enum": [
              "user-interrupted"
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "artifact": {
            "description": "This is a live version of the `call.artifact`.\n\nThis matches what is stored on `call.artifact` after the call.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Artifact"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "ServerMessageLanguageChangeDetected": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"language-change-detected\" is sent when the transcriber is automatically switched based on the detected language.",
            "enum": [
              "language-change-detected"
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "artifact": {
            "description": "This is a live version of the `call.artifact`.\n\nThis matches what is stored on `call.artifact` after the call.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Artifact"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "language": {
            "type": "string",
            "description": "This is the language the transcriber is switched to."
          }
        },
        "required": [
          "type",
          "language"
        ]
      },
      "ServerMessageVoiceInput": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"voice-input\" is sent when a generation is requested from voice provider.",
            "enum": [
              "voice-input"
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "artifact": {
            "description": "This is a live version of the `call.artifact`.\n\nThis matches what is stored on `call.artifact` after the call.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Artifact"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "input": {
            "type": "string",
            "description": "This is the voice input content"
          }
        },
        "required": [
          "type",
          "input"
        ]
      },
      "ServerMessageVoiceRequest": {
        "type": "object",
        "properties": {
          "phoneNumber": {
            "description": "This is the phone number that the message is associated with.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateByoPhoneNumberDTO",
                "title": "ByoPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTwilioPhoneNumberDTO",
                "title": "TwilioPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVonagePhoneNumberDTO",
                "title": "VonagePhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateVapiPhoneNumberDTO",
                "title": "VapiPhoneNumber"
              },
              {
                "$ref": "#/components/schemas/CreateTelnyxPhoneNumberDTO",
                "title": "TelnyxPhoneNumber"
              }
            ]
          },
          "type": {
            "type": "string",
            "description": "This is the type of the message. \"voice-request\" is sent when using `assistant.voice={ \"type\": \"custom-voice\" }`.\n\nHere is what the request will look like:\n\nPOST https://{assistant.voice.server.url}\nContent-Type: application/json\n\n{\n  \"messsage\": {\n    \"type\": \"voice-request\",\n    \"text\": \"Hello, world!\",\n    \"sampleRate\": 24000,\n    ...other metadata about the call...\n  }\n}\n\nThe expected response is 1-channel 16-bit raw PCM audio at the sample rate specified in the request. Here is how the response will be piped to the transport:\n```\nresponse.on('data', (chunk: Buffer) => {\n  outputStream.write(chunk);\n});\n```",
            "enum": [
              "voice-request"
            ]
          },
          "timestamp": {
            "type": "number",
            "description": "This is the timestamp of the message."
          },
          "artifact": {
            "description": "This is a live version of the `call.artifact`.\n\nThis matches what is stored on `call.artifact` after the call.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Artifact"
              }
            ]
          },
          "assistant": {
            "description": "This is the assistant that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "customer": {
            "description": "This is the customer that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateCustomerDTO"
              }
            ]
          },
          "call": {
            "description": "This is the call that the message is associated with.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Call"
              }
            ]
          },
          "text": {
            "type": "string",
            "description": "This is the text to be synthesized."
          },
          "sampleRate": {
            "type": "number",
            "description": "This is the sample rate to be synthesized."
          }
        },
        "required": [
          "type",
          "text",
          "sampleRate"
        ]
      },
      "ServerMessage": {
        "type": "object",
        "properties": {
          "message": {
            "description": "These are all the messages that can be sent to your server before, after and during the call. Configure the messages you'd like to receive in `assistant.serverMessages`.\n\nThe server where the message is sent is determined by the following precedence order:\n\n1. `tool.server.url` (if configured, and only for \"tool-calls\" message)\n2. `assistant.serverUrl` (if configure)\n3. `phoneNumber.serverUrl` (if configured)\n4. `org.serverUrl` (if configured)",
            "oneOf": [
              {
                "$ref": "#/components/schemas/ServerMessageAssistantRequest",
                "title": "AssistantRequest"
              },
              {
                "$ref": "#/components/schemas/ServerMessageConversationUpdate",
                "title": "ConversationUpdate"
              },
              {
                "$ref": "#/components/schemas/ServerMessageEndOfCallReport",
                "title": "EndOfCallReport"
              },
              {
                "$ref": "#/components/schemas/ServerMessageHang",
                "title": "Hang"
              },
              {
                "$ref": "#/components/schemas/ServerMessageKnowledgeBaseRequest",
                "title": "KnowledgeBaseRequest"
              },
              {
                "$ref": "#/components/schemas/ServerMessageModelOutput",
                "title": "ModelOutput"
              },
              {
                "$ref": "#/components/schemas/ServerMessagePhoneCallControl",
                "title": "PhoneCallControl"
              },
              {
                "$ref": "#/components/schemas/ServerMessageSpeechUpdate",
                "title": "SpeechUpdate"
              },
              {
                "$ref": "#/components/schemas/ServerMessageStatusUpdate",
                "title": "StatusUpdate"
              },
              {
                "$ref": "#/components/schemas/ServerMessageToolCalls",
                "title": "ToolCalls"
              },
              {
                "$ref": "#/components/schemas/ServerMessageTransferDestinationRequest",
                "title": "TransferDestinationRequest"
              },
              {
                "$ref": "#/components/schemas/ServerMessageTransferUpdate",
                "title": "TransferUpdate"
              },
              {
                "$ref": "#/components/schemas/ServerMessageTranscript",
                "title": "Transcript"
              },
              {
                "$ref": "#/components/schemas/ServerMessageUserInterrupted",
                "title": "UserInterrupted"
              },
              {
                "$ref": "#/components/schemas/ServerMessageLanguageChangeDetected",
                "title": "LanguageChangeDetected"
              },
              {
                "$ref": "#/components/schemas/ServerMessageVoiceInput",
                "title": "VoiceInput"
              },
              {
                "$ref": "#/components/schemas/ServerMessageVoiceRequest",
                "title": "VoiceRequest"
              }
            ]
          }
        },
        "required": [
          "message"
        ]
      },
      "ServerMessageResponseAssistantRequest": {
        "type": "object",
        "properties": {
          "destination": {
            "description": "This is the destination to transfer the inbound call to. This will immediately transfer without using any assistants.\n\nIf this is sent, `assistantId`, `assistant`, `squadId`, and `squad` are ignored.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "assistantId": {
            "type": "string",
            "description": "This is the assistant ID that will be used for the call. To use a transient assistant, use `assistant` instead.\n\nTo start a call with:\n- Assistant, use `assistantId` or `assistant`\n- Squad, use `squadId` or `squad`\n- Workflow, use `workflowId` or `workflow`"
          },
          "assistant": {
            "description": "This is the assistant that will be used for the call. To use an existing assistant, use `assistantId` instead.\n\nTo start a call with:\n- Assistant, use `assistant`\n- Squad, use `squad`\n- Workflow, use `workflow`",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateAssistantDTO"
              }
            ]
          },
          "assistantOverrides": {
            "description": "These are the overrides for the `assistant` or `assistantId`'s settings and template variables.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AssistantOverrides"
              }
            ]
          },
          "squadId": {
            "type": "string",
            "description": "This is the squad that will be used for the call. To use a transient squad, use `squad` instead.\n\nTo start a call with:\n- Assistant, use `assistant` or `assistantId`\n- Squad, use `squad` or `squadId`\n- Workflow, use `workflow` or `workflowId`"
          },
          "squad": {
            "description": "This is a squad that will be used for the call. To use an existing squad, use `squadId` instead.\n\nTo start a call with:\n- Assistant, use `assistant` or `assistantId`\n- Squad, use `squad` or `squadId`\n- Workflow, use `workflow` or `workflowId`",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateSquadDTO"
              }
            ]
          },
          "workflowId": {
            "type": "string",
            "description": "[BETA] This feature is in active development. The API and behavior are subject to change as we refine it based on user feedback.\n\nThis is the workflow that will be used for the call. To use a transient workflow, use `workflow` instead.\n\nTo start a call with:\n- Assistant, use `assistant` or `assistantId`\n- Squad, use `squad` or `squadId`\n- Workflow, use `workflow` or `workflowId`"
          },
          "workflow": {
            "description": "[BETA] This feature is in active development. The API and behavior are subject to change as we refine it based on user feedback.\n\nThis is a workflow that will be used for the call. To use an existing workflow, use `workflowId` instead.\n\nTo start a call with:\n- Assistant, use `assistant` or `assistantId`\n- Squad, use `squad` or `squadId`\n- Workflow, use `workflow` or `workflowId`",
            "allOf": [
              {
                "$ref": "#/components/schemas/CreateWorkflowDTO"
              }
            ]
          },
          "error": {
            "type": "string",
            "description": "This is the error if the call shouldn't be accepted. This is spoken to the customer.\n\nIf this is sent, `assistantId`, `assistant`, `squadId`, `squad`, and `destination` are ignored."
          }
        }
      },
      "KnowledgeBaseResponseDocument": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string",
            "description": "This is the content of the document."
          },
          "similarity": {
            "type": "number",
            "description": "This is the similarity score of the document."
          },
          "uuid": {
            "type": "string",
            "description": "This is the uuid of the document."
          }
        },
        "required": [
          "content",
          "similarity"
        ]
      },
      "ServerMessageResponseKnowledgeBaseRequest": {
        "type": "object",
        "properties": {
          "documents": {
            "description": "This is the list of documents that will be sent to the model alongside the `messages` to generate a response.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/KnowledgeBaseResponseDocument"
            }
          },
          "message": {
            "description": "This can be used to skip the model output generation and speak a custom message.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CustomMessage"
              }
            ]
          }
        }
      },
      "ToolCallResult": {
        "type": "object",
        "properties": {
          "message": {
            "description": "This is the message that will be spoken to the user.\n\nIf this is not returned, assistant will speak:\n1. a `request-complete` or `request-failed` message from `tool.messages`, if it exists\n2. a response generated by the model, if not",
            "oneOf": [
              {
                "$ref": "#/components/schemas/ToolMessageComplete",
                "title": "ToolMessageComplete"
              },
              {
                "$ref": "#/components/schemas/ToolMessageFailed",
                "title": "ToolMessageFailed"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "This is the name of the function the model called."
          },
          "toolCallId": {
            "type": "string",
            "description": "This is the unique identifier for the tool call."
          },
          "result": {
            "type": "string",
            "description": "This is the result if the tool call was successful. This is added to the conversation history.\n\nFurther, if this is returned, assistant will speak:\n1. the `message`, if it exists and is of type `request-complete`\n2. a `request-complete` message from `tool.messages`, if it exists\n3. a response generated by the model, if neither exist"
          },
          "error": {
            "type": "string",
            "description": "This is the error if the tool call was not successful. This is added to the conversation history.\n\nFurther, if this is returned, assistant will speak:\n1. the `message`, if it exists and is of type `request-failed`\n2. a `request-failed` message from `tool.messages`, if it exists\n3. a response generated by the model, if neither exist"
          },
          "metadata": {
            "type": "object",
            "description": "This is optional metadata for the tool call result to be sent to the client."
          }
        },
        "required": [
          "name",
          "toolCallId"
        ]
      },
      "ServerMessageResponseToolCalls": {
        "type": "object",
        "properties": {
          "results": {
            "description": "These are the results of the \"tool-calls\" message.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ToolCallResult"
            }
          },
          "error": {
            "type": "string",
            "description": "This is the error message if the tool call was not successful."
          }
        }
      },
      "ServerMessageResponseTransferDestinationRequest": {
        "type": "object",
        "properties": {
          "destination": {
            "description": "This is the destination you'd like the call to be transferred to.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationAssistant",
                "title": "Assistant"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "Number"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "Sip"
              }
            ]
          },
          "error": {
            "type": "string",
            "description": "This is the error message if the transfer should not be made."
          }
        }
      },
      "ServerMessageResponseVoiceRequest": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "description": "DO NOT respond to a `voice-request` webhook with this schema of { data }. This schema just exists to document what the response should look like. Follow these instructions:\n\nHere is what the request will look like:\n\nPOST https://{assistant.voice.server.url}\nContent-Type: application/json\n\n{\n  \"messsage\": {\n    \"type\": \"voice-request\",\n    \"text\": \"Hello, world!\",\n    \"sampleRate\": 24000,\n    ...other metadata about the call...\n  }\n}\n\nThe expected response is 1-channel 16-bit raw PCM audio at the sample rate specified in the request. Here is how the response will be piped to the transport:\n```\nresponse.on('data', (chunk: Buffer) => {\n  outputStream.write(chunk);\n});\n```"
          }
        },
        "required": [
          "data"
        ]
      },
      "ServerMessageResponse": {
        "type": "object",
        "properties": {
          "messageResponse": {
            "description": "This is the response that is expected from the server to the message.\n\nNote: Most messages don't expect a response. Only \"assistant-request\", \"tool-calls\" and \"transfer-destination-request\" do.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/ServerMessageResponseAssistantRequest",
                "title": "AssistantRequest"
              },
              {
                "$ref": "#/components/schemas/ServerMessageResponseKnowledgeBaseRequest",
                "title": "KnowledgeBaseRequest"
              },
              {
                "$ref": "#/components/schemas/ServerMessageResponseToolCalls",
                "title": "ToolCalls"
              },
              {
                "$ref": "#/components/schemas/ServerMessageResponseTransferDestinationRequest",
                "title": "TransferDestinationRequest"
              },
              {
                "$ref": "#/components/schemas/ServerMessageResponseVoiceRequest",
                "title": "VoiceRequest"
              }
            ]
          }
        },
        "required": [
          "messageResponse"
        ]
      },
      "ClientInboundMessageAddMessage": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of the message. Send \"add-message\" message to add a message to the conversation history.",
            "enum": [
              "add-message"
            ]
          },
          "message": {
            "description": "This is the message to add to the conversation.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIMessage"
              }
            ]
          },
          "triggerResponseEnabled": {
            "type": "boolean",
            "description": "This is the flag to trigger a response, or to insert the message into the conversation history silently. Defaults to `true`.\n\nUsage:\n- Use `true` to trigger a response.\n- Use `false` to insert the message into the conversation history silently.\n\n@default true",
            "default": true
          }
        },
        "required": [
          "type",
          "message"
        ]
      },
      "ClientInboundMessageControl": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of the message. Send \"control\" message to control the assistant. `control` options are:\n- \"mute-assistant\" - mute the assistant\n- \"unmute-assistant\" - unmute the assistant\n- \"say-first-message\" - say the first message (this is used when video recording is enabled and the conversation is only started once the client side kicks off the recording)",
            "enum": [
              "control"
            ]
          },
          "control": {
            "type": "string",
            "description": "This is the control action",
            "enum": [
              "mute-assistant",
              "unmute-assistant",
              "say-first-message"
            ]
          }
        },
        "required": [
          "type",
          "control"
        ]
      },
      "ClientInboundMessageSay": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of the message. Send \"say\" message to make the assistant say something.",
            "enum": [
              "say"
            ]
          },
          "content": {
            "type": "string",
            "description": "This is the content to say."
          },
          "endCallAfterSpoken": {
            "type": "boolean",
            "description": "This is the flag to end call after content is spoken."
          },
          "interruptionsEnabled": {
            "type": "boolean",
            "description": "This is the flag for whether the message is interruptible."
          }
        }
      },
      "ClientInboundMessageEndCall": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of the message. Send \"end-call\" message to end the call.",
            "enum": [
              "end-call"
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "ClientInboundMessageTransfer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of the message. Send \"transfer\" message to transfer the call to a destination.",
            "enum": [
              "transfer"
            ]
          },
          "destination": {
            "description": "This is the destination to transfer the call to.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TransferDestinationNumber",
                "title": "NumberTransferDestination"
              },
              {
                "$ref": "#/components/schemas/TransferDestinationSip",
                "title": "SipTransferDestination"
              }
            ]
          },
          "content": {
            "type": "string",
            "description": "This is the content to say."
          }
        },
        "required": [
          "type"
        ]
      },
      "ClientInboundMessage": {
        "type": "object",
        "properties": {
          "message": {
            "description": "These are the messages that can be sent from client-side SDKs to control the call.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/ClientInboundMessageAddMessage",
                "title": "AddMessage"
              },
              {
                "$ref": "#/components/schemas/ClientInboundMessageControl",
                "title": "Control"
              },
              {
                "$ref": "#/components/schemas/ClientInboundMessageSay",
                "title": "Say"
              },
              {
                "$ref": "#/components/schemas/ClientInboundMessageEndCall",
                "title": "EndCall"
              },
              {
                "$ref": "#/components/schemas/ClientInboundMessageTransfer",
                "title": "Transfer"
              }
            ]
          }
        },
        "required": [
          "message"
        ]
      },
      "BotMessage": {
        "type": "object",
        "properties": {
          "role": {
            "type": "string",
            "description": "The role of the bot in the conversation."
          },
          "message": {
            "type": "string",
            "description": "The message content from the bot."
          },
          "time": {
            "type": "number",
            "description": "The timestamp when the message was sent."
          },
          "endTime": {
            "type": "number",
            "description": "The timestamp when the message ended."
          },
          "secondsFromStart": {
            "type": "number",
            "description": "The number of seconds from the start of the conversation."
          },
          "source": {
            "type": "string",
            "description": "The source of the message."
          },
          "duration": {
            "type": "number",
            "description": "The duration of the message in seconds."
          }
        },
        "required": [
          "role",
          "message",
          "time",
          "endTime",
          "secondsFromStart"
        ]
      },
      "ToolCallMessage": {
        "type": "object",
        "properties": {
          "role": {
            "type": "string",
            "description": "The role of the tool call in the conversation."
          },
          "toolCalls": {
            "description": "The list of tool calls made during the conversation.",
            "type": "array",
            "items": {
              "type": "object"
            }
          },
          "message": {
            "type": "string",
            "description": "The message content for the tool call."
          },
          "time": {
            "type": "number",
            "description": "The timestamp when the message was sent."
          },
          "secondsFromStart": {
            "type": "number",
            "description": "The number of seconds from the start of the conversation."
          }
        },
        "required": [
          "role",
          "toolCalls",
          "message",
          "time",
          "secondsFromStart"
        ]
      },
      "ToolCallResultMessage": {
        "type": "object",
        "properties": {
          "role": {
            "type": "string",
            "description": "The role of the tool call result in the conversation."
          },
          "toolCallId": {
            "type": "string",
            "description": "The ID of the tool call."
          },
          "name": {
            "type": "string",
            "description": "The name of the tool that returned the result."
          },
          "result": {
            "type": "string",
            "description": "The result of the tool call in JSON format."
          },
          "time": {
            "type": "number",
            "description": "The timestamp when the message was sent."
          },
          "secondsFromStart": {
            "type": "number",
            "description": "The number of seconds from the start of the conversation."
          },
          "metadata": {
            "type": "object",
            "description": "The metadata for the tool call result."
          }
        },
        "required": [
          "role",
          "toolCallId",
          "name",
          "result",
          "time",
          "secondsFromStart"
        ]
      },
      "TransportCost": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of cost, always 'transport' for this class.",
            "enum": [
              "transport"
            ]
          },
          "provider": {
            "type": "string",
            "enum": [
              "twilio",
              "vonage",
              "vapi"
            ]
          },
          "minutes": {
            "type": "number",
            "description": "This is the minutes of `transport` usage. This should match `call.endedAt` - `call.startedAt`."
          },
          "cost": {
            "type": "number",
            "description": "This is the cost of the component in USD."
          }
        },
        "required": [
          "type",
          "minutes",
          "cost"
        ]
      },
      "TranscriberCost": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of cost, always 'transcriber' for this class.",
            "enum": [
              "transcriber"
            ]
          },
          "transcriber": {
            "type": "object",
            "description": "This is the transcriber that was used during the call.\n\nThis matches one of the below:\n- `call.assistant.transcriber`,\n- `call.assistantId->transcriber`,\n- `call.squad[n].assistant.transcriber`,\n- `call.squad[n].assistantId->transcriber`,\n- `call.squadId->[n].assistant.transcriber`,\n- `call.squadId->[n].assistantId->transcriber`."
          },
          "minutes": {
            "type": "number",
            "description": "This is the minutes of `transcriber` usage. This should match `call.endedAt` - `call.startedAt` for single assistant calls, while squad calls will have multiple transcriber costs one for each assistant that was used."
          },
          "cost": {
            "type": "number",
            "description": "This is the cost of the component in USD."
          }
        },
        "required": [
          "type",
          "transcriber",
          "minutes",
          "cost"
        ]
      },
      "ModelCost": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of cost, always 'model' for this class.",
            "enum": [
              "model"
            ]
          },
          "model": {
            "type": "object",
            "description": "This is the model that was used during the call.\n\nThis matches one of the following:\n- `call.assistant.model`,\n- `call.assistantId->model`,\n- `call.squad[n].assistant.model`,\n- `call.squad[n].assistantId->model`,\n- `call.squadId->[n].assistant.model`,\n- `call.squadId->[n].assistantId->model`."
          },
          "promptTokens": {
            "type": "number",
            "description": "This is the number of prompt tokens used in the call. These should be total prompt tokens used in the call for single assistant calls, while squad calls will have multiple model costs one for each assistant that was used."
          },
          "completionTokens": {
            "type": "number",
            "description": "This is the number of completion tokens generated in the call. These should be total completion tokens used in the call for single assistant calls, while squad calls will have multiple model costs one for each assistant that was used."
          },
          "cost": {
            "type": "number",
            "description": "This is the cost of the component in USD."
          }
        },
        "required": [
          "type",
          "model",
          "promptTokens",
          "completionTokens",
          "cost"
        ]
      },
      "VoiceCost": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of cost, always 'voice' for this class.",
            "enum": [
              "voice"
            ]
          },
          "voice": {
            "type": "object",
            "description": "This is the voice that was used during the call.\n\nThis matches one of the following:\n- `call.assistant.voice`,\n- `call.assistantId->voice`,\n- `call.squad[n].assistant.voice`,\n- `call.squad[n].assistantId->voice`,\n- `call.squadId->[n].assistant.voice`,\n- `call.squadId->[n].assistantId->voice`."
          },
          "characters": {
            "type": "number",
            "description": "This is the number of characters that were generated during the call. These should be total characters used in the call for single assistant calls, while squad calls will have multiple voice costs one for each assistant that was used."
          },
          "cost": {
            "type": "number",
            "description": "This is the cost of the component in USD."
          }
        },
        "required": [
          "type",
          "voice",
          "characters",
          "cost"
        ]
      },
      "VapiCost": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of cost, always 'vapi' for this class.",
            "enum": [
              "vapi"
            ]
          },
          "subType": {
            "type": "string",
            "description": "This is the sub type of the cost.",
            "enum": [
              "normal",
              "overage"
            ]
          },
          "minutes": {
            "type": "number",
            "description": "This is the minutes of Vapi usage. This should match `call.endedAt` - `call.startedAt`."
          },
          "cost": {
            "type": "number",
            "description": "This is the cost of the component in USD."
          }
        },
        "required": [
          "type",
          "subType",
          "minutes",
          "cost"
        ]
      },
      "AnalysisCost": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of cost, always 'analysis' for this class.",
            "enum": [
              "analysis"
            ]
          },
          "analysisType": {
            "type": "string",
            "description": "This is the type of analysis performed.",
            "enum": [
              "summary",
              "structuredData",
              "successEvaluation"
            ]
          },
          "model": {
            "type": "object",
            "description": "This is the model that was used to perform the analysis."
          },
          "promptTokens": {
            "type": "number",
            "description": "This is the number of prompt tokens used in the analysis."
          },
          "completionTokens": {
            "type": "number",
            "description": "This is the number of completion tokens generated in the analysis."
          },
          "cost": {
            "type": "number",
            "description": "This is the cost of the component in USD."
          }
        },
        "required": [
          "type",
          "analysisType",
          "model",
          "promptTokens",
          "completionTokens",
          "cost"
        ]
      },
      "VoicemailDetectionCost": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of cost, always 'voicemail-detection' for this class.",
            "enum": [
              "voicemail-detection"
            ]
          },
          "model": {
            "type": "object",
            "description": "This is the model that was used to perform the analysis."
          },
          "provider": {
            "type": "string",
            "description": "This is the provider that was used to detect the voicemail.",
            "enum": [
              "twilio",
              "google",
              "openai",
              "vapi"
            ]
          },
          "promptTextTokens": {
            "type": "number",
            "description": "This is the number of prompt text tokens used in the voicemail detection."
          },
          "promptAudioTokens": {
            "type": "number",
            "description": "This is the number of prompt audio tokens used in the voicemail detection."
          },
          "completionTextTokens": {
            "type": "number",
            "description": "This is the number of completion text tokens used in the voicemail detection."
          },
          "completionAudioTokens": {
            "type": "number",
            "description": "This is the number of completion audio tokens used in the voicemail detection."
          },
          "cost": {
            "type": "number",
            "description": "This is the cost of the component in USD."
          }
        },
        "required": [
          "type",
          "model",
          "provider",
          "promptTextTokens",
          "promptAudioTokens",
          "completionTextTokens",
          "completionAudioTokens",
          "cost"
        ]
      },
      "KnowledgeBaseCost": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "This is the type of cost, always 'knowledge-base' for this class.",
            "enum": [
              "knowledge-base"
            ]
          },
          "model": {
            "type": "object",
            "description": "This is the model that was used for processing the knowledge base."
          },
          "promptTokens": {
            "type": "number",
            "description": "This is the number of prompt tokens used in the knowledge base query."
          },
          "completionTokens": {
            "type": "number",
            "description": "This is the number of completion tokens generated in the knowledge base query."
          },
          "cost": {
            "type": "number",
            "description": "This is the cost of the component in USD."
          }
        },
        "required": [
          "type",
          "model",
          "promptTokens",
          "completionTokens",
          "cost"
        ]
      },
      "FunctionToolWithToolCall": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "function"
            ],
            "description": "The type of tool. \"function\" for Function tool."
          },
          "async": {
            "type": "boolean",
            "example": false,
            "description": "This determines if the tool is async.\n\n  If async, the assistant will move forward without waiting for your server to respond. This is useful if you just want to trigger something on your server.\n\n  If sync, the assistant will wait for your server to respond. This is useful if want assistant to respond with the result from your server.\n\n  Defaults to synchronous (`false`)."
          },
          "server": {
            "description": "\n  This is the server where a `tool-calls` webhook will be sent.\n\n  Notes:\n  - Webhook is sent to this server when a tool call is made.\n  - Webhook contains the call, assistant, and phone number objects.\n  - Webhook contains the variables set on the assistant.\n  - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.\n  - Webhook expects a response with tool call result.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "toolCall": {
            "$ref": "#/components/schemas/ToolCall"
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "toolCall"
        ]
      },
      "GhlToolWithToolCall": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "ghl"
            ],
            "description": "The type of tool. \"ghl\" for GHL tool."
          },
          "toolCall": {
            "$ref": "#/components/schemas/ToolCall"
          },
          "metadata": {
            "$ref": "#/components/schemas/GhlToolMetadata"
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "toolCall",
          "metadata"
        ]
      },
      "MakeToolWithToolCall": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "make"
            ],
            "description": "The type of tool. \"make\" for Make tool."
          },
          "toolCall": {
            "$ref": "#/components/schemas/ToolCall"
          },
          "metadata": {
            "$ref": "#/components/schemas/MakeToolMetadata"
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "toolCall",
          "metadata"
        ]
      },
      "BashToolWithToolCall": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "bash"
            ],
            "description": "The type of tool. \"bash\" for Bash tool."
          },
          "subType": {
            "type": "string",
            "enum": [
              "bash_20241022"
            ],
            "description": "The sub type of tool."
          },
          "server": {
            "description": "\n  This is the server where a `tool-calls` webhook will be sent.\n\n  Notes:\n  - Webhook is sent to this server when a tool call is made.\n  - Webhook contains the call, assistant, and phone number objects.\n  - Webhook contains the variables set on the assistant.\n  - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.\n  - Webhook expects a response with tool call result.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "toolCall": {
            "$ref": "#/components/schemas/ToolCall"
          },
          "name": {
            "type": "string",
            "description": "The name of the tool, fixed to 'bash'",
            "default": "bash",
            "enum": [
              "bash"
            ]
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "subType",
          "toolCall",
          "name"
        ]
      },
      "ComputerToolWithToolCall": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "computer"
            ],
            "description": "The type of tool. \"computer\" for Computer tool."
          },
          "subType": {
            "type": "string",
            "enum": [
              "computer_20241022"
            ],
            "description": "The sub type of tool."
          },
          "server": {
            "description": "\n  This is the server where a `tool-calls` webhook will be sent.\n\n  Notes:\n  - Webhook is sent to this server when a tool call is made.\n  - Webhook contains the call, assistant, and phone number objects.\n  - Webhook contains the variables set on the assistant.\n  - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.\n  - Webhook expects a response with tool call result.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "toolCall": {
            "$ref": "#/components/schemas/ToolCall"
          },
          "name": {
            "type": "string",
            "description": "The name of the tool, fixed to 'computer'",
            "default": "computer",
            "enum": [
              "computer"
            ]
          },
          "displayWidthPx": {
            "type": "number",
            "description": "The display width in pixels"
          },
          "displayHeightPx": {
            "type": "number",
            "description": "The display height in pixels"
          },
          "displayNumber": {
            "type": "number",
            "description": "Optional display number"
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "subType",
          "toolCall",
          "name",
          "displayWidthPx",
          "displayHeightPx"
        ]
      },
      "TextEditorToolWithToolCall": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "textEditor"
            ],
            "description": "The type of tool. \"textEditor\" for Text Editor tool."
          },
          "subType": {
            "type": "string",
            "enum": [
              "text_editor_20241022"
            ],
            "description": "The sub type of tool."
          },
          "server": {
            "description": "\n  This is the server where a `tool-calls` webhook will be sent.\n\n  Notes:\n  - Webhook is sent to this server when a tool call is made.\n  - Webhook contains the call, assistant, and phone number objects.\n  - Webhook contains the variables set on the assistant.\n  - Webhook is sent to the first available URL in this order: {{tool.server.url}}, {{assistant.server.url}}, {{phoneNumber.server.url}}, {{org.server.url}}.\n  - Webhook expects a response with tool call result.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Server"
              }
            ]
          },
          "toolCall": {
            "$ref": "#/components/schemas/ToolCall"
          },
          "name": {
            "type": "string",
            "description": "The name of the tool, fixed to 'str_replace_editor'",
            "default": "str_replace_editor",
            "enum": [
              "str_replace_editor"
            ]
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "subType",
          "toolCall",
          "name"
        ]
      },
      "GoogleCalendarCreateEventToolWithToolCall": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "google.calendar.event.create"
            ],
            "description": "The type of tool. \"google.calendar.event.create\" for Google Calendar tool."
          },
          "toolCall": {
            "$ref": "#/components/schemas/ToolCall"
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "toolCall"
        ]
      },
      "GoogleSheetsRowAppendToolWithToolCall": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "google.sheets.row.append"
            ],
            "description": "The type of tool. \"google.sheets.row.append\" for Google Sheets tool."
          },
          "toolCall": {
            "$ref": "#/components/schemas/ToolCall"
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "toolCall"
        ]
      },
      "GoHighLevelCalendarAvailabilityToolWithToolCall": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "gohighlevel.calendar.availability.check"
            ],
            "description": "The type of tool. \"gohighlevel.calendar.availability.check\" for GoHighLevel Calendar availability check tool."
          },
          "toolCall": {
            "$ref": "#/components/schemas/ToolCall"
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "toolCall"
        ]
      },
      "GoHighLevelCalendarEventCreateToolWithToolCall": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "gohighlevel.calendar.event.create"
            ],
            "description": "The type of tool. \"gohighlevel.calendar.event.create\" for GoHighLevel Calendar event create tool."
          },
          "toolCall": {
            "$ref": "#/components/schemas/ToolCall"
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "toolCall"
        ]
      },
      "GoHighLevelContactCreateToolWithToolCall": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "gohighlevel.contact.create"
            ],
            "description": "The type of tool. \"gohighlevel.contact.create\" for GoHighLevel contact create tool."
          },
          "toolCall": {
            "$ref": "#/components/schemas/ToolCall"
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "toolCall"
        ]
      },
      "GoHighLevelContactGetToolWithToolCall": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "These are the messages that will be spoken to the user as the tool is running.\n\nFor some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ToolMessageStart",
                  "title": "ToolMessageStart"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageComplete",
                  "title": "ToolMessageComplete"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageFailed",
                  "title": "ToolMessageFailed"
                },
                {
                  "$ref": "#/components/schemas/ToolMessageDelayed",
                  "title": "ToolMessageDelayed"
                }
              ]
            }
          },
          "type": {
            "type": "string",
            "enum": [
              "gohighlevel.contact.get"
            ],
            "description": "The type of tool. \"gohighlevel.contact.get\" for GoHighLevel contact get tool."
          },
          "toolCall": {
            "$ref": "#/components/schemas/ToolCall"
          },
          "function": {
            "description": "This is the function definition of the tool.\n\nFor `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.\n\nAn example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument \"reason\". Then, in `messages` array, you can have many \"request-complete\" messages. One of these messages will be triggered if the `messages[].conditions` matches the \"reason\" argument.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OpenAIFunction"
              }
            ]
          }
        },
        "required": [
          "type",
          "toolCall"
        ]
      }
    }
  }
}
